<script lang="ts">
    import { math } from 'mathlifier';
	import Hoverable from '$lib/components/Hoverable.svelte';
    import wikiSummaryGreatest_common_divisor from './wiki/wikiSummaryGreatest_common_divisor.html?raw';
    import wikiSummaryEuclidean_algorithm from './wiki/wikiSummaryEuclidean_algorithm.html?raw';


    function setActive(e){
        console.log(e)
    }

</script>

<h2>Solution</h2>
<p>The factoring problem can be solved with the following simple, but very time-consuming algorithm:</p>
<ol>
<li>
<p>We pick a random number <span on:mouseenter={() => setActive(["a", "N"])}>{@html math("a \\in \\mathbb{N}, 1 < a < N")}</span> and make sure that <span on:mouseenter={() => setActive(["a"])}>{@html math("a")}</span> and <span on:mouseenter={() => setActive(["N"])}>{@html math("N")}</span> are relative primes, meaning <span on:mouseenter={() => setActive(["a", "N"])}>{@html math("\\gcd(a, N) = 1,")}</span> where <span on:mouseenter={() => setActive([])}>{@html math("\\gcd")}</span> stands for <Hoverable hovertext={wikiSummaryGreatest_common_divisor}>greatest common divisor</Hoverable>. (In case <span on:mouseenter={() => setActive(["a"])}>{@html math("a")}</span> happens to be a factor of <span on:mouseenter={() => setActive(["N"])}>{@html math("N,")}</span> the entire problem is solved and no further steps are required, but that is highly unlikely if <span on:mouseenter={() => setActive(["N"])}>{@html math("N")}</span> is large.)</p>
</li>
<li>
<p>Next, we construct the function <span on:mouseenter={() => setActive(["r", "a", "N", "f"])}>{@html math("f_{a, N}(r): \\mathbb{N} \\rightarrow \\mathbb{N} = a^r \\mod N")}</span> and find the smallest integer <span on:mouseenter={() => setActive(["r", "N"])}>{@html math("0 < \\hat{r} < N")}</span> such that <span on:mouseenter={() => setActive(["r", "a", "N", "f"])}>{@html math("f_{a, N}(\\hat{r}) = 1.")}</span> If <span on:mouseenter={() => setActive(["r"])}>{@html math("\\hat{r}")}</span> turns out to be odd, we unfortunately have to repeat the entire procedure with a different <span on:mouseenter={() => setActive(["a"])}>{@html math("a")}</span> parameter.</p>
</li>
<li>
<p>If we're lucky and <span on:mouseenter={() => setActive(["r"])}>{@html math("\\hat{r}")}</span> is even, we can proceed. From the definition of <span on:mouseenter={() => setActive(["r"])}>{@html math("\\hat{r}")}</span> follows that there's <span on:mouseenter={() => setActive(["N", "m"])}>{@html math("m \\in \\mathbb{N}")}</span> such that <span on:mouseenter={() => setActive(["r", "a", "N", "m"])}>{@html math("a^{\\hat{r}} = m \\cdot N + 1.")}</span> We can then define the integer <span on:mouseenter={() => setActive(["r", "a", "b"])}>{@html math("b = a^{\\frac{\\hat{r}}{2}},")}</span> which means <span on:mouseenter={() => setActive(["r", "a", "b"])}>{@html math("b^2 = (a^{\\frac{\\hat{r}}{2}})^2 = a^{\\hat{r}}.")}</span> Next, we make use of a well-known algebraic identity to write <span on:mouseenter={() => setActive(["b"])}>{@html math("b^2 - 1 = (b + 1)(b - 1).")}</span> Putting together these three equations, we find that <span on:mouseenter={() => setActive(["N", "b", "m"])}>{@html math("(b + 1)(b - 1) = m \\cdot N.")}</span></p>
</li>
<li>
<p>For this step, we need to make sure that neither terms on the left of the expression above are divisible by <span on:mouseenter={() => setActive(["N"])}>{@html math("N")}</span>. Note that we know for sure <span on:mouseenter={() => setActive(["N", "b"])}>{@html math("(b - 1) \\mod N \\neq 0,")}</span> because that would imply <span on:mouseenter={() => setActive(["N", "r", "a", "b"])}>{@html math("b = a^{\\frac{\\hat{r}}{2}} \\mod N = 1,")}</span> and we defined <span on:mouseenter={() => setActive(["r"])}>{@html math("\\hat{r}")}</span> as the smallest positive integer, for which that equality holds, so it cannot hold for <span on:mouseenter={() => setActive(["r"])}>{@html math("\\frac{\\hat{r}}{2} < \\hat{r}")}</span>. Unfortunately, we cannot guarantee the same for the other term, so if <span on:mouseenter={() => setActive(["N", "b"])}>{@html math("(b + 1) \\mod N = 0,")}</span> we have to choose a new <span on:mouseenter={() => setActive(["a"])}>{@html math("a")}</span> and start from the beginning. If <span on:mouseenter={() => setActive(["N", "b"])}>{@html math("(b + 1) \\mod N \\neq 0,")}</span> however, we have solved the problem, because the prime factors we're looking for are <span on:mouseenter={() => setActive(["N", "b"])}>{@html math("\\gcd(b - 1, N)")}</span> and <span on:mouseenter={() => setActive(["N", "b"])}>{@html math("\\gcd(b + 1, N),")}</span> and these are very easy to compute with the help of <Hoverable hovertext={wikiSummaryEuclidean_algorithm}>Euclid's algorithm</Hoverable>. To see why this is true, consider the following. We have established that neither <span on:mouseenter={() => setActive(["b"])}>{@html math("(b - 1)")}</span> nor <span on:mouseenter={() => setActive(["b"])}>{@html math("(b + 1)")}</span> are divisible by <span on:mouseenter={() => setActive(["N"])}>{@html math("N,")}</span> but their product is, as it equals <span on:mouseenter={() => setActive(["N", "m"])}>{@html math("m \\cdot N")}</span>. This is only possible, if both of them share a factor with <span on:mouseenter={() => setActive(["N"])}>{@html math("N,")}</span> and the factors they share are different.</p>
</li>
</ol>
<p>If you're not entirely satisfied with the explanation above, check out the video <a href="https://www.youtube.com/watch?v=wUwZZaI5u0c&amp;t=731s">Hacking at Quantum Speed with Shor's Algorithm</a> by PBS Infinite Series.</p>
<p>The problem with this solution is that in order to find <span on:mouseenter={() => setActive(["r"])}>{@html math("\\hat{r},")}</span> we might have to check all possible values between <span on:mouseenter={() => setActive([])}>{@html math("1")}</span> and <span on:mouseenter={() => setActive(["N"])}>{@html math("N")}</span> one after the other, which is an insane amount of computation if <span on:mouseenter={() => setActive(["N"])}>{@html math("N")}</span> is number with several hundreds of digits. But that's only the case if we're trying with a classical computer.</p>
<!-- TODO edit the example according to the notation used here + elaborate on step 4. -->