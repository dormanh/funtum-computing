<script lang="ts">
    import { math } from 'mathlifier';
	import Hoverable from '$lib/components/Hoverable.svelte';
    import wikiSummaryPeriodic_function from './wiki/wikiSummaryPeriodic_function.html?raw';
    import wikiSummaryWave_interference from './wiki/wikiSummaryWave_interference.html?raw';


    function setActive(e){
        console.log(e)
    }

</script>

<h2>The period-finding problem</h2>
<p>Recall the steps for computing the prime factors of a large integer <span on:mouseenter={() => setActive(["N"])}>{@html math("N,")}</span> the hard part of which was finding the smallest <span on:mouseenter={() => setActive(["r", "N"])}>{@html math("1 < \\hat{r} < N")}</span> such that <span on:mouseenter={() => setActive(["r", "a", "N", "f"])}>{@html math("f_{a, N}(\\hat{r}) = a^{\\hat{r}} \\mod N = 1.")}</span> It turns out that <span on:mouseenter={() => setActive(["a", "N", "f"])}>{@html math("f_{a, N}")}</span> is a <Hoverable hovertext={wikiSummaryPeriodic_function}>periodic</Hoverable> function, and below we'll show that the number <span on:mouseenter={() => setActive(["r"])}>{@html math("\\hat{r}")}</span> we're looking for is exactly its period.</p>
<p>In general, the period of a function <span on:mouseenter={() => setActive(["g"])}>{@html math("g")}</span> is defined as the smallest positive number <span on:mouseenter={() => setActive(["p"])}>{@html math("0 < p,")}</span> for which <span on:mouseenter={() => setActive(["p", "g", "x"])}>{@html math("g(x) = g(x + p)")}</span> for all <span on:mouseenter={() => setActive(["x"])}>{@html math("x")}</span> in the domain of <span on:mouseenter={() => setActive(["g"])}>{@html math("g.")}</span> (In other words, <span on:mouseenter={() => setActive(["g"])}>{@html math("g")}</span> is a repeating sequence of the same pattern with length <span on:mouseenter={() => setActive(["p"])}>{@html math("p.")}</span>) Specifically for <span on:mouseenter={() => setActive(["a", "N", "f"])}>{@html math("f_{a, N},")}</span> because its domain is <span on:mouseenter={() => setActive(["N"])}>{@html math("\\mathbb{N},")}</span> its period has to be an integer.</p>
<p>Let <span on:mouseenter={() => setActive(["p", "N"])}>{@html math("\\hat{p} \\in \\mathbb{N}")}</span> denote the period of <span on:mouseenter={() => setActive(["a", "N", "f"])}>{@html math("f_{a, N}.")}</span> We know for sure that <span on:mouseenter={() => setActive(["a", "N", "f"])}>{@html math("f_{a, N}(0) = a^{0} \\mod N = 1 \\mod N = 1,")}</span> from which follows that <span on:mouseenter={() => setActive(["a", "p", "N", "f"])}>{@html math("f_{a, N}(0) = f_{a, N}(0 + \\hat{p}) = f_{a, N}(\\hat{p}) = 1.")}</span> Thus, the <span on:mouseenter={() => setActive(["p"])}>{@html math("\\hat{p}")}</span> is the smallest positive integer, for which the value of <span on:mouseenter={() => setActive(["a", "N", "f"])}>{@html math("f_{a, N}")}</span> equals <span on:mouseenter={() => setActive([])}>{@html math("1.")}</span> Notice that this is exactly how we originally defined <span on:mouseenter={() => setActive(["r"])}>{@html math("\\hat{r},")}</span> and so <span on:mouseenter={() => setActive(["r", "p"])}>{@html math("\\hat{r} = \\hat{p}.")}</span> </p>
<p>Thus, the factoring problem can essentially be reformulated as the problem of finding the period of the function <span on:mouseenter={() => setActive(["a", "N", "f"])}>{@html math("f_{a, N},")}</span> for which the quantum Fourier transform turns out to be really useful.</p>
<h2>The algorithm</h2>
<h4>Step 1.</h4>
<p>In order to implement Shor's algorithm, we'll need two quantum register with at least <span on:mouseenter={() => setActive(["N"])}>{@html math("\\log_2N")}</span> qubits, as that is the number of digits required to represent <span on:mouseenter={() => setActive(["N"])}>{@html math("N")}</span> in binary notation. (In case <span on:mouseenter={() => setActive(["N"])}>{@html math("\\log_2N")}</span> is not an integer, we have to round it up.) Note that this is a lower limit, and the more qubits we use, the faster we'll find the solution.</p>
<p>Let <span on:mouseenter={() => setActive(["N", "n"])}>{@html math("\\log_2N \\leq n")}</span> denote the number of qubits we chose to construct the both registers, and <span on:mouseenter={() => setActive(["\\psi"])}>{@html math("|\\psi_1\\rangle, |\\psi_2\\rangle")}</span> the current state of the two registers. Let's ignore the second register for now, and start with all qubits of the first register being in the basis state <span on:mouseenter={() => setActive([])}>{@html math("|0\\rangle,")}</span> thus we can write its state as <span on:mouseenter={() => setActive(["m", "n", "r", "s", "t", "\\psi"])}>{@html math("|\\psi_1\\rangle = \\underbrace{|0\\rangle \\otimes \\ldots \\otimes |0\\rangle}_\\text{n terms}.")}</span></p>
<h4>Step 2.</h4>
<p>Next, we apply the so called <span on:mouseenter={() => setActive(["H"])}>{@html math("H")}</span> (Hadamard) gate to each qubit of the first register, in order to set them into an equal superposition of the two basis states. This means the state of the register is now <span on:mouseenter={() => setActive(["m", "n", "r", "s", "t", "\\psi"])}>{@html math("|\\psi_1\\rangle = \\underbrace{\\frac{1}{\\sqrt{2}}(|0\\rangle + |1\\rangle) \\otimes \\ldots \\otimes \\frac{1}{\\sqrt{2}}(|0\\rangle + |1\\rangle)}_\\text{n terms}.")}</span> We can factor out the <span on:mouseenter={() => setActive([])}>{@html math("\\frac{1}{\\sqrt{2}}")}</span> terms to obtain <span on:mouseenter={() => setActive(["\\psi", "n"])}>{@html math("|\\psi_1\\rangle = \\frac{1}{\\sqrt{2^n}}(|0\\rangle + |1\\rangle) \\otimes \\ldots \\otimes (|0\\rangle + |1\\rangle).")}</span></p>
<p>Let <span on:mouseenter={() => setActive(["x"])}>{@html math("x")}</span> denote the number represented by the qubits of the first register (that is, the number we get if we read out the state as a sequence of binary digits). As we already saw in the case of the QFT, each qubit being in an equal superposition of the two basis states translates to the entire register being in the superposition of all combinations of these basis states, and consequently <span on:mouseenter={() => setActive(["x"])}>{@html math("x")}</span> being in the superposition of all values from <span on:mouseenter={() => setActive([])}>{@html math("0")}</span> to <span on:mouseenter={() => setActive(["n"])}>{@html math("2^n - 1.")}</span> Let's express the state as the superposition of these values: <span on:mouseenter={() => setActive(["x", "\\psi", "n"])}>{@html math("|\\psi_1\\rangle = \\displaystyle{\\frac{1}{\\sqrt{2^n}}\\sum_{x=0}^{2^n-1}|x\\rangle}.")}</span> Thus, if we now measure the entire register and read out <span on:mouseenter={() => setActive(["x"])}>{@html math("x,")}</span> we're going to get each possible value with an equal probability of <span on:mouseenter={() => setActive(["n"])}>{@html math("\\frac{1}{2^n}.")}</span></p>
<h4>Step 3.</h4>
<p>This is the point where the second register enters the picture. We begin with all qubits of this register being in the basis state <span on:mouseenter={() => setActive([])}>{@html math("|1\\rangle,")}</span> so <span on:mouseenter={() => setActive(["m", "n", "r", "s", "t", "\\psi"])}>{@html math("|\\psi_2\\rangle = \\underbrace{|0\\rangle \\otimes \\ldots \\otimes |0\\rangle}_\\text{n terms}.")}</span> Let <span on:mouseenter={() => setActive(["y"])}>{@html math("y")}</span> denote the number represented by the second register, analogously to <span on:mouseenter={() => setActive(["x"])}>{@html math("x.")}</span> Next, we apply a combination of gates to entangle the qubits of the two registers in a special way, in order to implement the function <span on:mouseenter={() => setActive(["x", "a", "N", "f"])}>{@html math("f_{a, N}(x) = a^x \\mod N.")}</span> To see what this means, let's take a step back and assume all qubits of the first register are in one particular basis state, and so <span on:mouseenter={() => setActive(["x"])}>{@html math("x")}</span> is a definite value between <span on:mouseenter={() => setActive([])}>{@html math("0")}</span> and <span on:mouseenter={() => setActive(["n"])}>{@html math("2^n - 1,")}</span> instead of a superposition of values. If we now applied the current step of the algorithm to the registers, it would set <span on:mouseenter={() => setActive(["y", "a", "N", "x"])}>{@html math("y = a^x \\mod N.")}</span></p>
<p>But because in our case the first register is actually in a superposition of all possible values of <span on:mouseenter={() => setActive(["x"])}>{@html math("x,")}</span> after this step, the second register is also going to be in a superposition of representing <span on:mouseenter={() => setActive(["y", "a", "N", "x"])}>{@html math("y = a^x \\mod N")}</span> for all values of <span on:mouseenter={() => setActive(["x"])}>{@html math("x.")}</span> Thus, we can write its state as <span on:mouseenter={() => setActive(["N", "a", "n", "x", "y", "\\psi"])}>{@html math("\\displaystyle{|\\psi_2\\rangle = \\sum_{x=0}^{2^n - 1} |y\\rangle = \\sum_{x=0}^{2^n - 1} |a^x \\mod N\\rangle}.")}</span></p>
<h4>Step 4.</h4>
<p>Next, we measure the second register. This will make all qubits of the second register into one of the basis states randomly, and so <span on:mouseenter={() => setActive(["y"])}>{@html math("y")}</span> will take on a definite value. Furthermore, the measurement will not only modify <span on:mouseenter={() => setActive(["\\psi"])}>{@html math("|\\psi_2,")}</span> but also <span on:mouseenter={() => setActive(["\\psi"])}>{@html math("\\psi_1,")}</span> because the qubits of the two registers are entangled. The value of <span on:mouseenter={() => setActive(["y"])}>{@html math("y")}</span> is a function of the value of <span on:mouseenter={() => setActive(["x"])}>{@html math("x,")}</span> and so if we measure a particular <span on:mouseenter={() => setActive(["y"])}>{@html math("y,")}</span> the superposition of the first register can only contains those values of <span on:mouseenter={() => setActive(["x"])}>{@html math("x")}</span> that are consistent with the measurement, namely for which <span on:mouseenter={() => setActive(["y", "a", "N", "x"])}>{@html math("a^x \\mod N = y.")}</span> So, although the measurement does not make the superposition of the first register disappear entirely, it filters it to the values of <span on:mouseenter={() => setActive(["x"])}>{@html math("x")}</span> that fulfil this criterion. And because <span on:mouseenter={() => setActive(["a", "N", "f"])}>{@html math("f_{a, N}")}</span> is a repeating pattern with period <span on:mouseenter={() => setActive(["p"])}>{@html math("\\hat{p},")}</span> those values are going to be <span on:mouseenter={() => setActive(["p"])}>{@html math("\\hat{p}")}</span> apart from each other. Let the sequence <span on:mouseenter={() => setActive(["k", "n", "x"])}>{@html math("0 \\leq x_0, \\ldots, x_k < 2^n")}</span> denote these values. Thus, we can write the state of the first register as <span on:mouseenter={() => setActive(["k", "\\psi", "x"])}>{@html math("\\displaystyle{|\\psi_1\\rangle = \\sum_{i=0}^{k} |x_i\\rangle},")}</span> where <span on:mouseenter={() => setActive(["p", "x"])}>{@html math("x_{i + 1} - x_i = \\hat{p}")}</span> for all <span on:mouseenter={() => setActive(["k"])}>{@html math("i < k.")}</span></p>
<h4>Step 5.</h4>
<p>Now, we apply the QFT to the first register. For a definite value of <span on:mouseenter={() => setActive(["x"])}>{@html math("x,")}</span> this would yield the state <span on:mouseenter={() => setActive(["y", "x", "\\psi", "n"])}>{@html math("\\displaystyle{|\\psi_1\\rangle = \\frac{1}{\\sqrt{2^n}} \\sum_{y=0}^{2^n - 1} e^{\\frac{2 \\pi i x y}{2^n}} |y\\rangle}.")}</span> But just like above, the register is in a superposition, and so the state after is going to be a linear combination of the QFT for all values of <span on:mouseenter={() => setActive(["x"])}>{@html math("x")}</span>: <span on:mouseenter={() => setActive(["x", "n", "k", "y", "\\psi"])}>{@html math("\\displaystyle{|\\psi_1\\rangle = \\frac{1}{\\sqrt{2^n}} \\sum_{i=0}^{k} \\sum_{x=0}^{2^n - 1} e^{\\frac{2 \\pi i x_i y}{2^n}} |x\\rangle}.")}</span></p>
<h4>Step 6.</h4>
<p>We saw in the section on the QFT that for a given <span on:mouseenter={() => setActive(["x"])}>{@html math("x,")}</span> the resulting phases form a sinusoidal wave pattern with a frequency of <span on:mouseenter={() => setActive(["x"])}>{@html math("x.")}</span> In this case, because of the superposition, the resulting phases are going to form a linear combination of sinusoidal wave patterns with frequencies <span on:mouseenter={() => setActive(["k", "x"])}>{@html math("x_0, \\ldots, x_k.")}</span> And this is the key to the solution, because these waves are going to <Hoverable hovertext={wikiSummaryWave_interference}>interfere</Hoverable> with each other in a particular way. Remember that the phases generated by the QFT were complex vectors of unit length. Now, we're adding those vectors together for <span on:mouseenter={() => setActive(["k", "x"])}>{@html math("x_0, \\ldots, x_k,")}</span> and so the length of the resulting vectors will no longer be <span on:mouseenter={() => setActive([])}>{@html math("1.")}</span></p>
<p>Instead, at certain points (values of <span on:mouseenter={() => setActive(["x"])}>{@html math("x")}</span>), the waves constructively interfere, meaning their displacements sum up to a large positive or negative value, and so the measurement probabilities of those points get amplified. At other points, the displacements cancel each other out, leading to probability amplitudes near zero. If we then measure the register and read out the represented value <span on:mouseenter={() => setActive(["x"])}>{@html math("x,")}</span> it's most likely going to be one of the points of constructive interference. And the points, at which this constructive interference happens are related to the period in a special way. Namely, they are the points <span on:mouseenter={() => setActive(["j", "p", "N"])}>{@html math("\\frac{j\\cdot N}{\\hat{p}}")}</span> for <span on:mouseenter={() => setActive(["j", "p"])}>{@html math("j = 0, \\ldots, \\hat{p} - 1.")}</span> Thus, all we have to do now is measure the final state of the first register a sufficient number of times to get a statistically reliable estimation of the period.</p>
<!-- TODO: include visualizations and finish text -->