<script lang="ts">
    import { math } from 'mathlifier';
	import Hoverable from '$lib/components/Hoverable.svelte';
    import wikiSummarySemiprime from './wiki/wikiSummarySemiprime.html?raw';
    import wikiSummaryGeneral_number_field_sieve from './wiki/wikiSummaryGeneral_number_field_sieve.html?raw';
    import wikiSummaryExponential_function from './wiki/wikiSummaryExponential_function.html?raw';
    import wikiSummaryQuantum_computing from './wiki/wikiSummaryQuantum_computing.html?raw';
    import wikiSummaryCubic_function from './wiki/wikiSummaryCubic_function.html?raw';
    import wikiSummaryComputational_complexity from './wiki/wikiSummaryComputational_complexity.html?raw';
    import wikiSummaryLinear_function from './wiki/wikiSummaryLinear_function.html?raw';


    function setActive(e){
        console.log(e)
    }

</script>

<h2>Description of the problem</h2>
<p>We would like to find the prime factors <span on:mouseenter={() => setActive(["P", "p", "q"])}>{@html math("p, q \\in \\mathbb{P}")}</span> of a large <Hoverable hovertext={wikiSummarySemiprime}>semiprime</Hoverable> <span on:mouseenter={() => setActive(["N"])}>{@html math("N \\in \\mathbb{N}")}</span> (so that <span on:mouseenter={() => setActive(["p", "N", "q"])}>{@html math("N = p \\cdot q")}</span>). Finding these factors for a small number, such as <span on:mouseenter={() => setActive([])}>{@html math("15,")}</span> is quite easy. In fact, you may figure it out just by looking at it and recalling your grade school studies: the factors are <span on:mouseenter={() => setActive([])}>{@html math("3")}</span> and <span on:mouseenter={() => setActive([])}>{@html math("5.")}</span> But what are the prime factors of, say, <span on:mouseenter={() => setActive([])}>{@html math("62615533")}</span>? It turns out that, using the best known classical (meaning non-quantum) algorithm (the so called <Hoverable hovertext={wikiSummaryGeneral_number_field_sieve}>number field sieve</Hoverable>), solving the factoring problem scales <Hoverable hovertext={wikiSummaryExponential_function}>exponentially</Hoverable> with the number of digits of the semiprime that we want to factor. With the help of Shor's algorithm and a sufficiently large <Hoverable hovertext={wikiSummaryQuantum_computing}>quantum computer</Hoverable>, the same problem scales roughly <Hoverable hovertext={wikiSummaryCubic_function}>cubically</Hoverable> with the number of digits. (In fact, the algorithm does slighly better than that, but the precise formula is a bit complicated and is beside the point.) To illustrate what this means in practical terms, imagine the following. If factoring a <span on:mouseenter={() => setActive([])}>{@html math("100")}</span>-digit number with Shor's algorithm on a quantum computer takes one second, factoring the same number with the number field sieve on a classical computer takes more than <span on:mouseenter={() => setActive([])}>{@html math("3")}</span> hours. If we now try with a <span on:mouseenter={() => setActive([])}>{@html math("200")}</span>-digit number, Shor's algorithm finishes in roughly <span on:mouseenter={() => setActive([])}>{@html math("5")}</span> seconds, while the classical solution would take more than a year!</p>
<p><Hoverable hovertext={wikiSummaryComputational_complexity}>Computational complexity</Hoverable> refers to how the time - or number of elementary operations - required to solve a given problem algorithmically grows with the size of the input. Let's say you have to find the longest book you have ever read. One way to approach this problem is to list the books you have read one by one, label the first one as the longest, and whenever you encounter an even longer book, it takes the place of the former. This way, you only have to keep track of the largest page number so far, and the book associated with it. The "elementary operation" in this case is checking the number of pages of the next book and comparing that with the previous maximum. If you have twice or three times as many books, this procedure requires twice or three times as many elementary operations. In other words, it grows <Hoverable hovertext={wikiSummaryLinear_function}>linearly</Hoverable> in the number of books. So, while the solution can be found using the same algorithm, the number of elementary operations required to carry out that algorithm depends on the size of the input. This is true for almost all algorithms that are designed to solve mathematical problems. However, how fast that growth is, makes all the difference between them.</p>
<!-- TODO add and link to some use cases like RSA here and explain how this is important and strange. -->