<script lang="ts">
    import { math } from 'mathlifier';
	import Hoverable from '$lib/components/Hoverable.svelte';
    import wikiSummarySemiprime from './wiki/wikiSummarySemiprime.html?raw';
    import wikiSummaryComputational_complexity from './wiki/wikiSummaryComputational_complexity.html?raw';


    function setActive(e){
        console.log(e)
    }

</script>

<p>Take a large composite <Hoverable hovertext={wikiSummarySemiprime}>(semiprime)</Hoverable> number <span on:mouseenter={() => setActive(["a", "b"])}>{@html math("N")}</span> we try to find factors for, so that <span on:mouseenter={() => setActive(["a", "b"])}>{@html math("N = p \\cdot q")}</span>. Finding the prime factors of a small semiprime, such as <span on:mouseenter={() => setActive(["a", "b"])}>{@html math("15")}</span>, is quite easy. In fact, you may figure it out just by looking at it and recalling your grade school studies: the factors are <span on:mouseenter={() => setActive(["a", "b"])}>{@html math("3")}</span> and <span on:mouseenter={() => setActive(["a", "b"])}>{@html math("5")}</span>. But what are the prime factors of, say, <span on:mouseenter={() => setActive(["a", "b"])}>{@html math("62615533")}</span>? It turns out that, using the best known <em>classical</em> algorithm (the so called <em>number field sieve</em>), solving the factoring problem scales <em>exponentially</em> with the number of digits of the semiprime that we want to factor. With the help of Shor's algorithm and a sufficiently large quantum computer, the same problem scales roughly <em>cubically</em> with the number of digits, meaning that the number of elementary operations required is proportional to (the number of digits)<span on:mouseenter={() => setActive(["a", "b"])}>{@html math("^3")}</span>. (In fact, the algorithm does slighly better than that, but the precise formula is a bit complicated and is beside the point.) To illustrate what this means in practical terms, imagine the following. If factoring a 100-digit number with Shor's algorithm on a quantum computer takes one second, factoring the same number with the number field sieve on a classical computer takes more than 3 hours. If we now try with a 200-digit number, Shor's algorithm finishes in roughly 5 seconds, while the classical solution would take more than a year!</p>
<p><Hoverable hovertext={wikiSummaryComputational_complexity}>Computational complexity</Hoverable> refers to how the time - or number of <em>elementary operations</em> - required to solve a given problem algorithmically grows with the size of the <em>input</em>. Let's say you have to find the longest book you have ever read. One way to approach this problem is to list the books you have read one by one, label the first one as the longest, and whenever you encounter an even longer book, it takes the place of the former. This way, you only have to keep track of the largest page number so far, and the book associated with it. The "elementary operation" in this case is checking the number of pages of the next book and comparing that with the previous maximum. If you have twice or three times as many books, this procedure requires twice or three times as many elementary operations. In other words, it grows <em>linearly</em> in the number of books. So, while the solution can be found using the same algorithm, the number of elementary operations required to carry out that algorithm depends on the size of the input. This is true for almost all algorithms that are designed to solve mathematical problems. However, how <em>fast</em> that growth is, makes all the difference between them.</p>
<h1>TODO</h1>
<blockquote>
<p>add and link to some use cases like RSA here and explain how this is important and strange.</p>
</blockquote>