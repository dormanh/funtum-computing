<script lang="ts">
    import { math } from 'mathlifier';
	import Hoverable from '$lib/components/Hoverable.svelte';
    


    function setActive(e){
        console.log(e)
    }

</script>

<h1>Quantum Fourier transform</h1>
<h2>Binary number system</h2>
<p>In the decimal number system, there are <span on:mouseenter={() => setActive([])}>{@html math("10")}</span> distinct symbols used to represent numbers: <span on:mouseenter={() => setActive([])}>{@html math("0, 1, 2, 3, 4, 5, 6, 7, 8, 9")}</span>. The value of these symbols depends on their place in a given number. For example, in the number <span on:mouseenter={() => setActive([])}>{@html math("325")}</span>, the symbol <span on:mouseenter={() => setActive([])}>{@html math("2")}</span> stands for <span on:mouseenter={() => setActive([])}>{@html math("2 \\cdot 10")}</span>, whereas in the number <span on:mouseenter={() => setActive([])}>{@html math("2847")}</span>, it represents <span on:mouseenter={() => setActive([])}>{@html math("2 \\cdot 1000")}</span>. In general, an integer in decimal notation with <span on:mouseenter={() => setActive(["n"])}>{@html math("n")}</span> digits equals <span on:mouseenter={() => setActive(["n", "d", "k"])}>{@html math("\\displaystyle{\\sum_{k = 1}^{n} d_k \\cdot 10^{n - k}}")}</span>, where <span on:mouseenter={() => setActive(["d", "k"])}>{@html math("d_k")}</span> is the <span on:mouseenter={() => setActive(["k"])}>{@html math("k")}</span>-th digit (going from left to right). To illustrate this with a concrete example, the number above <span on:mouseenter={() => setActive([])}>{@html math("2847 = 2 \\cdot 10^3 + 8 \\cdot 10^2 + 4 \\cdot 10^1 + 7 \\cdot 10^0 = 2 \\cdot 1000 + 8 \\cdot 100 + 4 \\cdot 10 + 7 \\cdot 1")}</span>.</p>
<p>Analogously, in the binary number system, there are <span on:mouseenter={() => setActive([])}>{@html math("2")}</span> distinct symbols used to represent numbers: <span on:mouseenter={() => setActive([])}>{@html math("0")}</span> and <span on:mouseenter={() => setActive([])}>{@html math("1")}</span>. The value of an integer in binary notation equals to <span on:mouseenter={() => setActive(["n", "d", "k"])}>{@html math("\\displaystyle{\\sum_{k = 1}^{n} d_k \\cdot 2^{n - k}}")}</span>, where <span on:mouseenter={() => setActive(["d", "k"])}>{@html math("d_k")}</span> is the <span on:mouseenter={() => setActive(["k"])}>{@html math("k")}</span>-th (binary) digit. For instance, the binary number <span on:mouseenter={() => setActive([])}>{@html math("1011 = 1 \\cdot 2^3 + 0 \\cdot 2^2 + 1 \\cdot 2^1 + 1 \\cdot 2^0 = 1 \\cdot 8 + 0 \\cdot 4 + 1 \\cdot 2 + 1 \\cdot 1 = 11")}</span>.</p>
<h2>Representing numbers with qubits</h2>
<p>Consider <span on:mouseenter={() => setActive(["n"])}>{@html math("n")}</span> qubits aranged in a row, each of which are in either of the two basis states <span on:mouseenter={() => setActive([])}>{@html math("|0\\rangle")}</span> or <span on:mouseenter={() => setActive([])}>{@html math("|1\\rangle")}</span>. With a little combinatorics, we can see that there are <span on:mouseenter={() => setActive(["n", "t", "m", "s"])}>{@html math("\\underbrace{2 \\cdot \\ldots \\cdot 2}_\\text{n times} = 2^n")}</span> such combinations. For ease of notation, let <span on:mouseenter={() => setActive(["n", "N"])}>{@html math("N := 2^n")}</span>.</p>
<p>For our purposes, we'll interpret these combinations as the binary representations of the numbers from <span on:mouseenter={() => setActive([])}>{@html math("0")}</span> to <span on:mouseenter={() => setActive(["N"])}>{@html math("N - 1")}</span>. For example, let <span on:mouseenter={() => setActive(["n"])}>{@html math("n = 5")}</span> and the qubits be in the following state: <span on:mouseenter={() => setActive([])}>{@html math("|0\\rangle \\otimes |1\\rangle \\otimes |0\\rangle \\otimes |0\\rangle \\otimes |1\\rangle")}</span>. We can "read out" this state as the binary number <span on:mouseenter={() => setActive([])}>{@html math("01001")}</span>, which - as we saw above - is equal to <span on:mouseenter={() => setActive([])}>{@html math("0 \\cdot 2^4 + 1 \\cdot 2^3 + 0 \\cdot 2^2 + 0 \\cdot 2^1 + 1 \\cdot 2^0 = 0 + 8 + 0 + 0 + 1 = 9")}</span>.</p>
<h2>QFT on the qubit level</h2>
<p>The quantum Fourier transform is an operation that modifies the states of qubits in a particular way. (How this is done in practice is another topic, for now we'll only look at the mathematics.) Namely, if <span on:mouseenter={() => setActive(["x"])}>{@html math("x")}</span> is the number represented by the qubits (in the example above, <span on:mouseenter={() => setActive(["x"])}>{@html math("x = 9")}</span>), the QFT sets the state of the <span on:mouseenter={() => setActive(["k"])}>{@html math("k")}</span>-th qubit to <span on:mouseenter={() => setActive(["x", "k"])}>{@html math("\\frac{1}{\\sqrt{2}} \\left( |0\\rangle + e^{\\frac{2 \\pi i x}{2^k}} |1\\rangle \\right)")}</span>. In other words, it sets <span on:mouseenter={() => setActive(["\\alpha", "k"])}>{@html math("\\alpha_k = \\frac{1}{\\sqrt{2}}")}</span> and <span on:mouseenter={() => setActive(["x", "\\beta", "k"])}>{@html math("\\beta_k = \\frac{1}{\\sqrt{2}} e^{\\frac{2 \\pi i x}{2^k}}")}</span> for all <span on:mouseenter={() => setActive(["n", "k"])}>{@html math("k = 1, ..., n")}</span>.</p>
<p>Notice that even though <span on:mouseenter={() => setActive(["\\alpha", "\\beta", "k"])}>{@html math("\\alpha_k \\neq \\beta_k")}</span>, the associated measurement probabilities <span on:mouseenter={() => setActive(["\\alpha", "\\beta", "k"])}>{@html math("\\Vert{\\alpha_k}\\Vert^2 = \\Vert{\\beta_k}\\Vert^2 = \\frac{1}{2}")}</span> for all <span on:mouseenter={() => setActive(["n", "k"])}>{@html math("k = 1, ..., n")}</span>. This is because the <span on:mouseenter={() => setActive(["x", "k"])}>{@html math("e^{\\frac{2 \\pi i x}{2^k}}")}</span> term - as we saw in section 2.3 - indicates the qubit's phase and does not affect measurement probabilities.</p>
<p>Just like the state of a single qubit can be the linear combination of <span on:mouseenter={() => setActive([])}>{@html math("|0\\rangle")}</span> and <span on:mouseenter={() => setActive([])}>{@html math("|1\\rangle")}</span>, the joint state of these <span on:mouseenter={() => setActive(["n"])}>{@html math("n")}</span> qubits is essentially the linear combination of all the possible combinations of the <span on:mouseenter={() => setActive(["n"])}>{@html math("n")}</span> basis states - which, as we saw in the previous section, represent the integers from <span on:mouseenter={() => setActive([])}>{@html math("0")}</span> to <span on:mouseenter={() => setActive(["N"])}>{@html math("N - 1")}</span>. Since both basis states are measured with a probability of <span on:mouseenter={() => setActive([])}>{@html math("\\frac{1}{2}")}</span> for each qubit, one particular combination of the <span on:mouseenter={() => setActive(["n"])}>{@html math("n")}</span> basis states is measured with a probability of <span on:mouseenter={() => setActive(["r", "n", "t", "s", "m", "N"])}>{@html math("\\underbrace{\\frac{1}{2} \\cdot \\ldots \\cdot \\frac{1}{2}}_\\text{n terms} = \\frac{1}{2^n} = \\frac{1}{N}")}</span>. What differs across these combinations are the phase, as we'll see in the next section.</p>
<h2>QFT on the representation level</h2>
<p>Next, let's write out the joint state of the qubits:</p>
<p><span on:mouseenter={() => setActive(["r", "n", "t", "s", "x", "m"])}>{@html math("\\underbrace{ \\frac{1}{\\sqrt{2}} \\left( |0\\rangle + e^{ \\frac{2 \\pi i x}{2^1} } |1\\rangle \\right) \\otimes \\ldots \\otimes \\frac{1}{\\sqrt{2}} \\left( |0\\rangle + e^{ \\frac{2 \\pi i x}{2^n} } |1\\rangle \\right) }_\\text{n terms}")}</span></p>
<p>We can factor out the <span on:mouseenter={() => setActive([])}>{@html math("\\frac{1}{\\sqrt{2}}")}</span> term to get:</p>
<p><span on:mouseenter={() => setActive(["n", "x", "N"])}>{@html math("\\frac{1}{\\sqrt{2^n}} \\left(\\left( |0\\rangle + e^{\\frac{2 \\pi i x}{2^1}} |1\\rangle \\right) \\otimes \\ldots \\otimes \\left( |0\\rangle + e^{\\frac{2 \\pi i x}{2^n}} |1\\rangle \\right) \\right) = \\frac{1}{\\sqrt{N}} \\left(\\left( |0\\rangle + e^{\\frac{2 \\pi i x}{2^1}} |1\\rangle \\right) \\otimes \\ldots \\otimes \\left( |0\\rangle + e^{\\frac{2 \\pi i x}{2^n}} |1\\rangle \\right) \\right)")}</span></p>
<p>Let <span on:mouseenter={() => setActive(["y", "k"])}>{@html math("y_k")}</span> denote the <span on:mouseenter={() => setActive(["k"])}>{@html math("k")}</span>-th digit of the binary number represented by the <span on:mouseenter={() => setActive(["n"])}>{@html math("n")}</span> qubits in a given basis state. In other words, <span on:mouseenter={() => setActive(["y", "k"])}>{@html math("y_k = 0")}</span> if the <span on:mouseenter={() => setActive(["k"])}>{@html math("k")}</span>-th qubit is in the <span on:mouseenter={() => setActive([])}>{@html math("|0\\rangle")}</span> state, and <span on:mouseenter={() => setActive(["y", "k"])}>{@html math("y_k = 1")}</span> if it's in the <span on:mouseenter={() => setActive([])}>{@html math("|1\\rangle")}</span> state for all <span on:mouseenter={() => setActive(["n", "k"])}>{@html math("k = 1, \\ldots, n")}</span>. Using this notation, we can write the expression above in the form of a sum instead of a product:</p>
<p><span on:mouseenter={() => setActive(["r", "n", "t", "s", "x", "m", "N", "y"])}>{@html math("{\\displaystyle \\frac{1}{\\sqrt{N}} \\underbrace{ \\sum_{y_1=0}^1 \\ldots \\sum_{y_{n}=0}^1}_\\text{n terms} \\overbrace{e^{2 \\pi i x \\frac{y_1}{2^1}} |y_1\\rangle \\otimes \\ldots \\otimes e^{2 \\pi i x \\frac{y_n}{2^n}}|y_n\\rangle}^\\text{n terms} }")}</span></p>
<p>The formula above includes all possible combinations of basis states with <em>equal weight</em>, but <em>different phases</em>. Let's define the <em>phase of the combination</em> as the product of the phases of individual qubits within that combination. We can then factor out this phase as we iterate over the combinations:</p>
<p><span on:mouseenter={() => setActive(["n", "x", "y", "N"])}>{@html math("\\displaystyle \\frac{1}{\\sqrt{N}} \\sum_{y_1=0}^1 \\ldots \\sum_{y_{n}=0}^1 \\left( e^{2 \\pi i x \\frac{y_1}{2^1}} \\cdot \\ldots \\cdot e^{2 \\pi i x \\frac{y_n}{2^n}} \\right) \\left( |y_1\\rangle \\otimes \\ldots \\otimes |y_n\\rangle \\right) =")}</span></p>
<p><span on:mouseenter={() => setActive(["n", "x", "N", "y", "k"])}>{@html math("\\displaystyle = \\frac{1}{\\sqrt{N}} \\sum_{y_1=0}^1 \\ldots \\sum_{y_{n}=0}^1 \\prod_{k=1}^n e^{2 \\pi i x \\frac{y_k}{2^k}} \\left( |y_1\\rangle \\otimes \\ldots \\otimes |y_n\\rangle \\right) =")}</span></p>
<p><span on:mouseenter={() => setActive(["n", "x", "N", "y", "k"])}>{@html math("\\displaystyle = \\frac{1}{\\sqrt{N}} \\sum_{y_1=0}^1 \\ldots \\sum_{y_{n}=0}^1 e^{2 \\pi i x \\sum_{k=1}^n \\frac{y_k}{2^k}} \\left( |y_1\\rangle \\otimes \\ldots \\otimes |y_n\\rangle \\right)")}</span></p>
<p>Notice that if <span on:mouseenter={() => setActive(["y", "k"])}>{@html math("y_k = 0")}</span>, the exponential term can be simplified the following way: <span on:mouseenter={() => setActive(["x", "y", "k"])}>{@html math("e^{2 \\pi i x \\frac{y_k}{2^k}} = e^{2 \\pi i x \\frac{0}{2^k}} = e^0 = 1")}</span>.</p>
<!-- TODO a lot -->