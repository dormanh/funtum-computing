<script lang="ts">
    import { math } from 'mathlifier';
	import Hoverable from '$lib/components/Hoverable.svelte';
    import wikiSummaryBinary_number from './wiki/wikiSummaryBinary_number.html?raw';
    import wikiSummaryQuantum_Fourier_transform from './wiki/wikiSummaryQuantum_Fourier_transform.html?raw';


    function setActive(e){
        console.log(e)
    }

</script>

<h2>Quantum Fourier transform (QFT)</h2>
<h2>Representing numbers with qubits</h2>
<p>Consider <span on:mouseenter={() => setActive(["n"])}>{@html math("n")}</span> qubits aranged in a row, each of which are in either of the two basis states <span on:mouseenter={() => setActive([])}>{@html math("|0\\rangle")}</span> or <span on:mouseenter={() => setActive([])}>{@html math("|1\\rangle")}</span>. With a little combinatorics, we can see that there are <span on:mouseenter={() => setActive(["n", "s", "t", "m"])}>{@html math("\\underbrace{2 \\cdot \\ldots \\cdot 2}_\\text{n times} = 2^n")}</span> such combinations. For ease of notation, let <span on:mouseenter={() => setActive(["n", "N"])}>{@html math("N := 2^n")}</span>.</p>
<p>For our purposes, we'll interpret these combinations as the <Hoverable hovertext={wikiSummaryBinary_number}>binary representations</Hoverable> of the numbers from <span on:mouseenter={() => setActive([])}>{@html math("0")}</span> to <span on:mouseenter={() => setActive(["N"])}>{@html math("N - 1")}</span>. For example, let <span on:mouseenter={() => setActive(["n"])}>{@html math("n = 5")}</span> and the qubits be in the following state: <span on:mouseenter={() => setActive([])}>{@html math("|0\\rangle \\otimes |1\\rangle \\otimes |0\\rangle \\otimes |0\\rangle \\otimes |1\\rangle")}</span>. We can "read out" this state as the binary number <span on:mouseenter={() => setActive([])}>{@html math("01001")}</span>, which is equal to <span on:mouseenter={() => setActive([])}>{@html math("\\small 0 \\cdot 2^4 + 1 \\cdot 2^3 + 0 \\cdot 2^2 + 0 \\cdot 2^1 + 1 \\cdot 2^0 = 0 + 8 + 0 + 0 + 1 = 9")}</span>.</p>
<h2>QFT on the qubit level</h2>
<p>The <Hoverable hovertext={wikiSummaryQuantum_Fourier_transform}>quantum Fourier transform</Hoverable> is an operation that modifies the states of qubits in a particular way. (How this is done in practice is another topic, for now we'll only look at the mathematics.) Namely, if <span on:mouseenter={() => setActive(["x"])}>{@html math("x")}</span> is the number represented by the qubits (in the example above, <span on:mouseenter={() => setActive(["x"])}>{@html math("x = 9")}</span>), the QFT sets the state of the <span on:mouseenter={() => setActive(["k"])}>{@html math("k")}</span>-th qubit to <span on:mouseenter={() => setActive(["k", "x"])}>{@html math("\\frac{1}{\\sqrt{2}} \\left( |0\\rangle + e^{\\frac{2 \\pi i x}{2^k}} |1\\rangle \\right)")}</span>. In other words, it sets <span on:mouseenter={() => setActive(["k", "\\alpha"])}>{@html math("\\alpha_k = \\frac{1}{\\sqrt{2}}")}</span> and <span on:mouseenter={() => setActive(["k", "x", "\\beta"])}>{@html math("\\beta_k = \\frac{1}{\\sqrt{2}} e^{\\frac{2 \\pi i x}{2^k}}")}</span> for all <span on:mouseenter={() => setActive(["n", "k"])}>{@html math("k = 1, ..., n")}</span>.</p>
<p>Notice that even though <span on:mouseenter={() => setActive(["k", "\\beta", "\\alpha"])}>{@html math("\\alpha_k \\neq \\beta_k")}</span>, the associated measurement probabilities <span on:mouseenter={() => setActive(["k", "\\beta", "\\alpha"])}>{@html math("\\Vert{\\alpha_k}\\Vert^2 = \\Vert{\\beta_k}\\Vert^2 = \\frac{1}{2}")}</span> for all <span on:mouseenter={() => setActive(["n", "k"])}>{@html math("k = 1, ..., n")}</span>. This is because the <span on:mouseenter={() => setActive(["k", "x"])}>{@html math("e^{\\frac{2 \\pi i x}{2^k}}")}</span> term - as we saw in the section about the Bloch-sphere - indicates the qubit's phase and does not affect measurement probabilities.</p>
<p>Just like the state of a single qubit can be the linear combination of <span on:mouseenter={() => setActive([])}>{@html math("|0\\rangle")}</span> and <span on:mouseenter={() => setActive([])}>{@html math("|1\\rangle")}</span>, the state of these <span on:mouseenter={() => setActive(["n"])}>{@html math("n")}</span> qubits is essentially the linear combination of all the possible combinations of the <span on:mouseenter={() => setActive(["n"])}>{@html math("n")}</span> basis states - which, as we saw in the previous section, represent the integers from <span on:mouseenter={() => setActive([])}>{@html math("0")}</span> to <span on:mouseenter={() => setActive(["N"])}>{@html math("N - 1")}</span>. Since both basis states are measured with a probability of <span on:mouseenter={() => setActive([])}>{@html math("\\frac{1}{2}")}</span> for each qubit, one particular combination of the <span on:mouseenter={() => setActive(["n"])}>{@html math("n")}</span> basis states is measured with a probability of <span on:mouseenter={() => setActive(["r", "t", "s", "N", "m", "n"])}>{@html math("\\underbrace{\\frac{1}{2} \\cdot \\ldots \\cdot \\frac{1}{2}}_\\text{n terms} = \\frac{1}{2^n} = \\frac{1}{N}")}</span>. What differs across these combinations is the phase, as we'll see in the next section.</p>
<h2>QFT on the representation level</h2>
<p>Let's denote the state of the entire sequence of qubits with <span on:mouseenter={() => setActive(["\\psi"])}>{@html math("|\\psi\\rangle")}</span> and write it out as shown below:</p>
<p><span on:mouseenter={() => setActive(["r", "t", "s", "m", "x", "\\psi", "n"])}>{@html math("|\\psi\\rangle = \\underbrace{ \\frac{1}{\\sqrt{2}} \\left( |0\\rangle + e^{ \\frac{2 \\pi i x}{2^1} } |1\\rangle \\right) \\otimes \\ldots \\otimes \\frac{1}{\\sqrt{2}} \\left( |0\\rangle + e^{ \\frac{2 \\pi i x}{2^n} } |1\\rangle \\right) }_\\text{n terms}")}</span></p>
<p>We can factor out the <span on:mouseenter={() => setActive([])}>{@html math("\\frac{1}{\\sqrt{2}}")}</span> term to get:</p>
<p><span on:mouseenter={() => setActive(["n", "x", "\\psi", "N"])}>{@html math("|\\psi\\rangle = \\frac{1}{\\sqrt{2^n}} \\left(\\left( |0\\rangle + e^{\\frac{2 \\pi i x}{2^1}} |1\\rangle \\right) \\otimes \\ldots \\otimes \\left( |0\\rangle + e^{\\frac{2 \\pi i x}{2^n}} |1\\rangle \\right) \\right) = \\frac{1}{\\sqrt{N}} \\left(\\left( |0\\rangle + e^{\\frac{2 \\pi i x}{2^1}} |1\\rangle \\right) \\otimes \\ldots \\otimes \\left( |0\\rangle + e^{\\frac{2 \\pi i x}{2^n}} |1\\rangle \\right) \\right)")}</span></p>
<p>Let <span on:mouseenter={() => setActive(["y"])}>{@html math("y")}</span> denote the binary number represented by the <span on:mouseenter={() => setActive(["n"])}>{@html math("n")}</span> qubits in a given basis state, and <span on:mouseenter={() => setActive(["k", "y"])}>{@html math("y_k")}</span> the <span on:mouseenter={() => setActive(["k"])}>{@html math("k")}</span>-th digit of <span on:mouseenter={() => setActive(["y"])}>{@html math("y")}</span>. In other words, <span on:mouseenter={() => setActive(["k", "y"])}>{@html math("y_k = 0")}</span> if the <span on:mouseenter={() => setActive(["k"])}>{@html math("k")}</span>-th qubit is in the <span on:mouseenter={() => setActive([])}>{@html math("|0\\rangle")}</span> state, and <span on:mouseenter={() => setActive(["k", "y"])}>{@html math("y_k = 1")}</span> if it's in the <span on:mouseenter={() => setActive([])}>{@html math("|1\\rangle")}</span> state for all <span on:mouseenter={() => setActive(["n", "k"])}>{@html math("k = 1, \\ldots, n")}</span>. Recalling our knowledge of binary numbers, we can write <span on:mouseenter={() => setActive(["y"])}>{@html math("y")}</span> as the weighted sum of its digits: <span on:mouseenter={() => setActive(["n", "k", "y"])}>{@html math("\\displaystyle{ y = \\sum_{k=1}^n y_k \\cdot 2^{n - k}}")}</span>. Notice that the <span on:mouseenter={() => setActive(["n"])}>{@html math("2^n")}</span> term within the sum does not depend on <span on:mouseenter={() => setActive(["k"])}>{@html math("k")}</span> and so we can factor it out: <span on:mouseenter={() => setActive(["n", "k", "y", "N"])}>{@html math("\\displaystyle{ y = 2^n \\cdot \\sum_{k=1}^n y_k \\cdot 2^{-k} = N \\cdot \\sum_{k=1}^n \\frac{y_k}{2^k}}")}</span>. Remember this step, as it is going to be important shortly!</p>
<p>Using this new notation, we can write the state of the qubits in the form of a sum instead of a product:</p>
<p><span on:mouseenter={() => setActive(["r", "t", "s", "N", "m", "x", "\\psi", "n", "y"])}>{@html math("|\\psi\\rangle = \\displaystyle{ \\frac{1}{\\sqrt{N}} \\underbrace{ \\sum_{y_1=0}^1 \\ldots \\sum_{y_{n}=0}^1}_\\text{n terms} \\overbrace{e^{\\frac{2 \\pi i x y_1}{2^1}} |y_1\\rangle \\otimes \\ldots \\otimes e^{\\frac{2 \\pi i x y_n}{2^n}}|y_n\\rangle}^\\text{n terms} }")}</span></p>
<p>In case you're wondering how the formula above can be derived from the definition we started with, note that for all <span on:mouseenter={() => setActive(["k"])}>{@html math("k")}</span>, the term <span on:mouseenter={() => setActive(["k", "x", "y"])}>{@html math("e^{\\frac{2 \\pi i x y_k}{2^k}}|y_k\\rangle")}</span> equals</p>
<ul>
<li><span on:mouseenter={() => setActive(["k", "x"])}>{@html math("e^{\\frac{2 \\pi i x \\cdot 0}{2^k}}|0\\rangle = 1 \\cdot |0\\rangle = |0\\rangle")}</span> if <span on:mouseenter={() => setActive(["k", "y"])}>{@html math("y_k = 0")}</span>, and</li>
<li><span on:mouseenter={() => setActive(["k", "x"])}>{@html math("e^{\\frac{2 \\pi i x \\cdot 1}{2^k}}|1\\rangle = e^{\\frac{2 \\pi i x }{2^k}}|1\\rangle")}</span> if <span on:mouseenter={() => setActive(["k", "y"])}>{@html math("y_k = 1")}</span>, </li>
</ul>
<p>which is exactly how we defined the QFT.</p>
<p>The <span on:mouseenter={() => setActive(["n"])}>{@html math("n")}</span> embedded summations might seem confusing at first, but what they actually do is iterate over all possible combinations of basis states. In the final sum, these are included with <em>equal weight</em> (meaning they are measured with equal probability), but the composing basis states will have <em>different phases</em> in each combination, as already mentioned at the end of the previous section.</p>
<p>Let's now define the <em>phase of the combination</em> as the product of the phases of individual qubits within that combination, and factor it out as shown below:</p>
<p><span on:mouseenter={() => setActive(["N", "x", "\\psi", "n", "y"])}>{@html math("|\\psi\\rangle = \\displaystyle{ \\frac{1}{\\sqrt{N}} \\sum_{y_1=0}^1 \\ldots \\sum_{y_{n}=0}^1 \\left( e^{\\frac{2 \\pi i x y_1}{2^1}} \\cdot \\ldots \\cdot e^{\\frac{2 \\pi i x y_n}{2^n}} \\right) \\left( |y_1\\rangle \\otimes \\ldots \\otimes |y_n\\rangle \\right)}")}</span></p>
<p><span on:mouseenter={() => setActive(["N", "x", "\\psi", "n", "k", "y"])}>{@html math("|\\psi\\rangle = \\displaystyle{ = \\frac{1}{\\sqrt{N}} \\sum_{y_1=0}^1 \\ldots \\sum_{y_{n}=0}^1 \\prod_{k=1}^n e^{\\frac{2 \\pi i x y_k}{2^k}} \\left( |y_1\\rangle \\otimes \\ldots \\otimes |y_n\\rangle \\right)}")}</span></p>
<p>After making use of the product rule for exponents...</p>
<p><span on:mouseenter={() => setActive(["N", "x", "\\psi", "n", "k", "y"])}>{@html math("|\\psi\\rangle = \\displaystyle{ = \\frac{1}{\\sqrt{N}} \\sum_{y_1=0}^1 \\ldots \\sum_{y_{n}=0}^1 e^{\\sum_{k=1}^n \\frac{2 \\pi i x y_k}{2^k}} \\left( |y_1\\rangle \\otimes \\ldots \\otimes |y_n\\rangle \\right)}")}</span></p>
<p>and factoring out the <span on:mouseenter={() => setActive(["x"])}>{@html math("2 \\pi i x")}</span> term that does not depend on <span on:mouseenter={() => setActive(["k"])}>{@html math("k")}</span>, we arrive at the formula below:</p>
<p><span on:mouseenter={() => setActive(["N", "x", "\\psi", "n", "k", "y"])}>{@html math("|\\psi\\rangle = \\displaystyle{ = \\frac{1}{\\sqrt{N}} \\sum_{y_1=0}^1 \\ldots \\sum_{y_{n}=0}^1 e^{2 \\pi i x \\sum_{k=1}^n \\frac{y_k}{2^k}} \\left( |y_1\\rangle \\otimes \\ldots \\otimes |y_n\\rangle \\right)}")}</span></p>
<p>Recall what I asked you to keep in mind a few paragraphs ago, and notice that the sum in the exponential <span on:mouseenter={() => setActive(["n", "k", "y"])}>{@html math("\\displaystyle{ \\sum_{k=1}^n \\frac{y_k}{2^k}}")}</span> is actually equal to <span on:mouseenter={() => setActive(["y", "N"])}>{@html math("\\frac{y}{N}")}</span>. Thus, we can now replace the individual <span on:mouseenter={() => setActive(["k", "y"])}>{@html math("y_k")}</span> digits with the number <span on:mouseenter={() => setActive(["y"])}>{@html math("y")}</span> itself and the multiple, embedded summations with a single one that iterates over all possible values of <span on:mouseenter={() => setActive(["y"])}>{@html math("y")}</span>. In addition, let's abbreviate the notation we used for the product of the basis states with <span on:mouseenter={() => setActive(["n", "y"])}>{@html math("|y\\rangle = |y_1\\rangle \\otimes \\ldots \\otimes |y_n\\rangle")}</span>, to finally obtain this way more elegant formula for the QFT:</p>
<p><span on:mouseenter={() => setActive(["x", "\\psi", "y", "N"])}>{@html math("|\\psi\\rangle = \\displaystyle{ \\frac{1}{\\sqrt{N}} \\sum_{y=0}^{N - 1} e^{\\frac{2 \\pi i x y}{N}} |y\\rangle}")}</span></p>
<p>The elegance comes from the fact that it shows what the qubits represent on a symbolic level, as opposed to the expression we started with that is a direct insight into the bit-level implementation.</p>
<p>Now let's illustrate visually what the formula above actually means. To give a proper intuition, we'll look at multiple systems with increasing number of qubits. For a chosen value of <span on:mouseenter={() => setActive(["x"])}>{@html math("x")}</span>, the plot below shows the <span on:mouseenter={() => setActive(["x", "y", "N"])}>{@html math("e^{\\frac{2 \\pi i x y}{N}}")}</span> terms for all possible values of <span on:mouseenter={() => setActive(["y"])}>{@html math("y")}</span> that these systems can represent. Because this term is a complex number, the geometric representation of which would require two dimensions, the real and imaginary components are shown separately. Notice that as the number of qubits increases, the plots gradually turn into sinusoidal wave patterns. Furthermore, the number of peaks of these waves - their frequency - equals <span on:mouseenter={() => setActive(["x"])}>{@html math("x")}</span>, which you can verify by modifying <span on:mouseenter={() => setActive(["x"])}>{@html math("x")}</span> with the help of the slider.</p>
<!-- TODO a lot, e.g. remove and link to binary numbers, insert interactive plot that shows the waves! -->