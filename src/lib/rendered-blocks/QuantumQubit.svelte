<script lang="ts">
    import { math } from 'mathlifier';
	import Hoverable from '$lib/components/Hoverable.svelte';
    import wikiSummaryComplex_number from './wiki/wikiSummaryComplex_number.html?raw';
    import wikiSummaryImaginary_number from './wiki/wikiSummaryImaginary_number.html?raw';
    import wikiSummaryReal_number from './wiki/wikiSummaryReal_number.html?raw';
    import wikiSummaryComplex_plane from './wiki/wikiSummaryComplex_plane.html?raw';
    import wikiSummaryBit from './wiki/wikiSummaryBit.html?raw';
    import wikiSummaryInformation_theory from './wiki/wikiSummaryInformation_theory.html?raw';
    import wikiSummaryQubit from './wiki/wikiSummaryQubit.html?raw';
    import wikiSummaryMeasurement_in_quantum_mechanics from './wiki/wikiSummaryMeasurement_in_quantum_mechanics.html?raw';
    import wikiSummaryQuantum_state from './wiki/wikiSummaryQuantum_state.html?raw';
    import wikiSummaryLinear_combination from './wiki/wikiSummaryLinear_combination.html?raw';


    function setActive(e){
        console.log(e)
    }

</script>

<h2>Important properties of complex numbers</h2>
<p>The general form of a <Hoverable hovertext={wikiSummaryComplex_number}>complex number</Hoverable> <span on:mouseenter={() => setActive(["C", "z"])}>{@html math("z \\in \\mathbb{C}")}</span> is the following: <span on:mouseenter={() => setActive(["a", "b", "z"])}>{@html math("z = a i + b")}</span>, where <span on:mouseenter={() => setActive(["a", "b", "R"])}>{@html math("a, b \\in \\mathbb{R}")}</span> and <span on:mouseenter={() => setActive([])}>{@html math("i = \\sqrt{-1}")}</span>. <span on:mouseenter={() => setActive(["a"])}>{@html math("a")}</span> is called the <Hoverable hovertext={wikiSummaryImaginary_number}>imaginary</Hoverable> and <span on:mouseenter={() => setActive(["b"])}>{@html math("b")}</span> the <Hoverable hovertext={wikiSummaryReal_number}>real</Hoverable> component of <span on:mouseenter={() => setActive(["z"])}>{@html math("z")}</span>. In fact, all real numbers are complex numbers, the imaginary component of which is zero (<span on:mouseenter={() => setActive(["a"])}>{@html math("a=0")}</span>).</p>
<p>Complex numbers can be represented geometrically as two-dimensional vectors in the so called <Hoverable hovertext={wikiSummaryComplex_plane}>complex plane</Hoverable>, where the <span on:mouseenter={() => setActive(["x"])}>{@html math("x")}</span>-axis stands for the real, and the <span on:mouseenter={() => setActive(["y"])}>{@html math("y")}</span>-axis for the imaginary component.</p>
<p>Let <span on:mouseenter={() => setActive(["a", "b", "z"])}>{@html math("\\Vert{z}\\Vert = \\sqrt{a^2 + b^2}")}</span> denote the Euclidean norm of the vector associated with the complex number <span on:mouseenter={() => setActive(["z"])}>{@html math("z")}</span>. Consequently, <span on:mouseenter={() => setActive(["a", "b", "z"])}>{@html math("\\Vert{z}\\Vert^2 = a^2 + b^2")}</span> is the square of this norm, and it's going to play an important role in what follows.</p>
<p>Another important thing to note is that each 2-dimensional vector is uniquely defined by two properties: its length and angle of rotation. Consequently, a complex number <span on:mouseenter={() => setActive(["z"])}>{@html math("z")}</span> can be expressed as <span on:mouseenter={() => setActive(["\\phi", "z"])}>{@html math("\\Vert{z}\\Vert \\cdot e^{i \\phi_z}")}</span>, where <span on:mouseenter={() => setActive(["\\phi", "z"])}>{@html math("\\phi_z \\in [0, 2\\pi]")}</span>. Here, <span on:mouseenter={() => setActive(["\\phi", "z"])}>{@html math("e^{i \\phi_z}")}</span> is a vector of unit length in the complex plane, rotated around the origin by an angle of <span on:mouseenter={() => setActive(["\\phi", "z"])}>{@html math("\\phi_z")}</span> (<span on:mouseenter={() => setActive([])}>{@html math("2\\pi")}</span> corresponds to a full rotation). All we have to do to get back <span on:mouseenter={() => setActive(["z"])}>{@html math("z")}</span>, then, is multiply this rotated unit vector by <span on:mouseenter={() => setActive(["z"])}>{@html math("\\Vert{z}\\Vert")}</span> to adjust its norm.</p>
<h2>Qubit states</h2>
<p>The elementary units of information in classical computing are <Hoverable hovertext={wikiSummaryBit}>bits</Hoverable>. As their name suggests, bits represent one single <Hoverable hovertext={wikiSummaryInformation_theory}>bit of information</Hoverable>, which means they can take on either of two values <span on:mouseenter={() => setActive([])}>{@html math("0")}</span> and <span on:mouseenter={() => setActive([])}>{@html math("1")}</span> at a time.</p>
<p><Hoverable hovertext={wikiSummaryQubit}>Qubits</Hoverable> are the quantum computing equivalent of bits. They differ from classical bits - among other things - in that they can take on a multitude of values instead of just <span on:mouseenter={() => setActive([])}>{@html math("0")}</span> and <span on:mouseenter={() => setActive([])}>{@html math("1")}</span>, until that value is <Hoverable hovertext={wikiSummaryMeasurement_in_quantum_mechanics}>measured</Hoverable>, at which point they behave just like classical bits. To explain what this means exactly, we'll need to introduce some further concepts.</p>
<p>Let <span on:mouseenter={() => setActive([])}>{@html math("|0\\rangle")}</span> and <span on:mouseenter={() => setActive([])}>{@html math("|1\\rangle")}</span> denote the so called basis states of a qubit that are the quantum-equivalent of classical bit states. If you look at a qubit directly to learn it's value, you'll see one of these basis states. But while you're not looking - due to it's quantum nature - the <Hoverable hovertext={wikiSummaryQuantum_state}>state</Hoverable> of a qubit may be something more intricate. Generally, it can be expressed as the <Hoverable hovertext={wikiSummaryLinear_combination}>linear combination</Hoverable> of the two basis states: <span on:mouseenter={() => setActive(["\\beta", "\\alpha"])}>{@html math("\\alpha |0\\rangle + \\beta |1\\rangle")}</span>. Here, <span on:mouseenter={() => setActive(["\\alpha"])}>{@html math("\\alpha")}</span> and <span on:mouseenter={() => setActive(["\\beta"])}>{@html math("\\beta")}</span> are complex numbers that indicate the relative weight, with which the two basis states are present in this combination. More precisely, if we now look at the qubit, we'll see the basis state <span on:mouseenter={() => setActive([])}>{@html math("|0\\rangle")}</span> with a probability of <span on:mouseenter={() => setActive(["\\alpha"])}>{@html math("\\Vert{\\alpha}\\Vert^2")}</span>, and the basis state <span on:mouseenter={() => setActive([])}>{@html math("|1\\rangle")}</span> with a probability of <span on:mouseenter={() => setActive(["\\beta"])}>{@html math("\\Vert{\\beta}\\Vert^2")}</span>. Because these probabilities must add up to one - as <span on:mouseenter={() => setActive([])}>{@html math("|0\\rangle")}</span> and <span on:mouseenter={() => setActive([])}>{@html math("|1\\rangle")}</span> are the only possible outcomes - the equation <span on:mouseenter={() => setActive(["\\beta", "\\alpha"])}>{@html math("\\Vert{\\alpha}\\Vert^2 + \\Vert{\\beta}\\Vert^2 = 1")}</span> must hold for all possible qubit states. Let's call <span on:mouseenter={() => setActive(["\\alpha"])}>{@html math("\\Vert{\\alpha}\\Vert^2")}</span> and <span on:mouseenter={() => setActive(["\\beta"])}>{@html math("\\Vert{\\beta}\\Vert^2")}</span> the measurement probabilities of the basis states.</p>
<!-- TODO introduce the interactivity -->