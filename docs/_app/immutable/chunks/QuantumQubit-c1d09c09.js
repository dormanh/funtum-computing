import{S as qt,i as kt,s as St,F as ea,l as h,a as Me,m as u,p,c as Ne,h as s,q as Et,b as q,H as a,L as d,I as ta,J as aa,K as na,f as F,t as oe,M as Ht,N as sa,a3 as ra,n as oa,u as r,x as le,v as o,y as he,z as ue,C as pe}from"./index-ca49edcf.js";import{m as _}from"./index-ba7e8b36.js";function ia(t){return t<.5?4*t*t*t:.5*Math.pow(2*t-2,3)+1}function Lt(t){const e=t-1;return e*e*e+1}function la(t){return--t*t*t*t*t+1}function Ca(t,{delay:e=0,duration:n=400,easing:i=Lt}={}){const l=getComputedStyle(t),E=+l.opacity,g=parseFloat(l.height),$=parseFloat(l.paddingTop),v=parseFloat(l.paddingBottom),w=parseFloat(l.marginTop),H=parseFloat(l.marginBottom),ce=parseFloat(l.borderTopWidth),I=parseFloat(l.borderBottomWidth);return{delay:e,duration:n,easing:i,css:x=>`overflow: hidden;opacity: ${Math.min(x*20,1)*E};height: ${x*g}px;padding-top: ${x*$}px;padding-bottom: ${x*v}px;margin-top: ${x*w}px;margin-bottom: ${x*H}px;border-top-width: ${x*ce}px;border-bottom-width: ${x*I}px;`}}function ha(t,{delay:e=0,duration:n=400,easing:i=Lt,start:l=0,opacity:E=0}={}){const g=getComputedStyle(t),$=+g.opacity,v=g.transform==="none"?"":g.transform,w=1-l,H=$*(1-E);return{delay:e,duration:n,easing:i,css:(ce,I)=>`
			transform: ${v} scale(${1-w*I});
			opacity: ${$-H*I}
		`}}function za(t,{delay:e=0,speed:n,duration:i,easing:l=ia}={}){let E=t.getTotalLength();const g=getComputedStyle(t);return g.strokeLinecap!=="butt"&&(E+=parseInt(g.strokeWidth)),i===void 0?n===void 0?i=800:i=E/n:typeof i=="function"&&(i=i(E)),{delay:e,duration:i,easing:l,css:($,v)=>`stroke-dasharray: ${$*E} ${v*E}`}}function Pt(t){let e,n;return{c(){e=h("div"),this.h()},l(i){e=u(i,"DIV",{class:!0});var l=p(e);l.forEach(s),this.h()},h(){Et(e,"class","hover-inner svelte-ybj98s")},m(i,l){q(i,e,l),e.innerHTML=t[0]},p(i,l){t=i,l&1&&(e.innerHTML=t[0])},i(i){n||sa(()=>{n=ra(e,ha,{duration:150,easing:la,opacity:0}),n.start()})},o:oa,d(i){i&&s(e)}}}function ua(t){let e,n,i,l,E;const g=t[5].default,$=ea(g,t,t[4],null);let v=t[1]&&Pt(t);return{c(){e=h("span"),$&&$.c(),n=Me(),v&&v.c(),this.h()},l(w){e=u(w,"SPAN",{class:!0});var H=p(e);$&&$.l(H),n=Ne(H),v&&v.l(H),H.forEach(s),this.h()},h(){Et(e,"class","hover-outer svelte-ybj98s")},m(w,H){q(w,e,H),$&&$.m(e,null),a(e,n),v&&v.m(e,null),i=!0,l||(E=[d(e,"mouseenter",t[2]),d(e,"mouseleave",t[3])],l=!0)},p(w,[H]){$&&$.p&&(!i||H&16)&&ta($,g,w,w[4],i?na(g,w[4],H,null):aa(w[4]),null),w[1]?v?(v.p(w,H),H&2&&F(v,1)):(v=Pt(w),v.c(),F(v,1),v.m(e,null)):v&&(v.d(1),v=null)},i(w){i||(F($,w),F(v),i=!0)},o(w){oe($,w),i=!1},d(w){w&&s(e),$&&$.d(w),v&&v.d(),l=!1,Ht(E)}}}function pa(t,e,n){let{$$slots:i={},$$scope:l}=e,{hovertext:E}=e,g=!1;const $=()=>n(1,g=!0),v=()=>n(1,g=!1);return t.$$set=w=>{"hovertext"in w&&n(0,E=w.hovertext),"$$scope"in w&&n(4,l=w.$$scope)},[E,g,$,v,l,i]}class me extends qt{constructor(e){super(),kt(this,e,pa,ua,St,{hovertext:0})}}const ma='<a href="https://en.wikipedia.org/wiki/Projection_(linear_algebra)"><h3>Projection (linear algebra)</h3></a><p>In linear algebra and functional analysis, a <b>projection</b> is a linear transformation <span class="mwe-math-element"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/b4dc73bf40314945ff376bd363916a738548d40a" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align:-0.338ex;width:1.745ex;height:2.176ex" /></span> from a vector space to itself such that <span class="mwe-math-element"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/5369d895625034bc50c9f28975e3293ef6f2105b" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align:-0.338ex;width:10.529ex;height:2.176ex" /></span>. That is, whenever <span class="mwe-math-element"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/b4dc73bf40314945ff376bd363916a738548d40a" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align:-0.338ex;width:1.745ex;height:2.176ex" /></span> is applied twice to any vector, it gives the same result as if it were applied once. It leaves its image unchanged. This definition of "projection" formalizes and generalizes the idea of graphical projection. One can also consider the effect of a projection on a geometrical object by examining the effect of the projection on points in the object.</p>',ca='<a href="https://en.wikipedia.org/wiki/Bloch_sphere"><h3>Bloch sphere</h3></a><p>In quantum mechanics and computing, the <b>Bloch sphere</b> is a geometrical representation of the pure state space of a two-level quantum mechanical system (qubit), named after the physicist Felix Bloch.</p>',fa='<a href="https://en.wikipedia.org/wiki/Degrees_of_freedom"><h3>Degrees of freedom</h3></a><p><b>Degrees of freedom</b> refers to the number of independent variables or parameters of a system. In various scientific fields, the word "freedom" is used to describe the limits to which physical movement or other physical processes are possible. This relates to the philosophical concept to the extent that people may be considered to have as much freedom as they are physically able to exercise.</p>',da='<a href="https://en.wikipedia.org/wiki/Phase_factor"><h3>Phase factor</h3></a><p>For any complex number written in polar form, the <b>phase factor</b> is the complex exponential factor. As such, the term "phase factor" is related to the more general term phasor, which may have any magnitude. The phase factor is a unit complex number, i.e. a complex number of absolute value 1. It is commonly used in quantum mechanics.</p>';function _a(t){let e;return{c(){e=r("projection")},l(n){e=o(n,"projection")},m(n,i){q(n,e,i)},d(n){n&&s(e)}}}function ba(t){let e;return{c(){e=r("Bloch sphere")},l(n){e=o(n,"Bloch sphere")},m(n,i){q(n,e,i)},d(n){n&&s(e)}}}function va(t){let e;return{c(){e=r("degrees of freedom")},l(n){e=o(n,"degrees of freedom")},m(n,i){q(n,e,i)},d(n){n&&s(e)}}}function wa(t){let e;return{c(){e=r("phase")},l(n){e=o(n,"phase")},m(n,i){q(n,e,i)},d(n){n&&s(e)}}}function ga(t){let e,n,i,l,E,g,$=_("\\alpha")+"",v,w,H=_("\\beta")+"",ce,I,x=_("\\alpha = \\Vert{\\alpha}\\Vert \\cdot e^{i \\phi_{\\alpha}}")+"",xe,ne,ye=_("\\beta = \\Vert{\\beta}\\Vert \\cdot e^{i \\phi_{\\beta}}.")+"",V,j,Ue=_("\\Vert{\\alpha}\\Vert \\cdot e^{i \\phi_{\\alpha}} |0\\rangle + \\Vert{\\beta}\\Vert \\cdot e^{i \\phi_{\\beta}} |1\\rangle.")+"",se,k,Te,D,ot=_("e^{i \\phi_{\\alpha}}")+"",qe,Q,Xe=_("\\Vert{e^{i \\phi_{\\alpha}}}\\Vert^2")+"",ke,c,Ye=_("1.")+"",fe,Se,Ze=_("\\phi_{\\alpha}")+"",de,He,et=_("\\phi_{\\beta}")+"",re,_e,be=_("e^{i \\phi_{\\alpha}}")+"",Ve,W,pt=_("\\Vert{\\alpha}\\Vert \\cdot |0\\rangle + \\Vert{\\beta}\\Vert \\cdot \\frac{e^{i \\phi_{\\beta}}}{e^{i \\phi_{\\alpha}}} |1\\rangle.")+"",Be,G,mt=_("\\frac{e^{i \\phi_{\\beta}}}{e^{i \\phi_{\\alpha}}} = e^{i (\\phi_{\\beta} - \\phi_{\\alpha})}.")+"",Ie,O,ct=_("\\phi = \\phi_{\\beta} - \\phi_{\\alpha},")+"",je,z,tt=_("\\Vert{\\alpha}\\Vert \\cdot |0\\rangle + \\Vert{\\beta}\\Vert \\cdot e^{i \\phi} |1\\rangle.")+"",ie,y,Qe,R,ft=_("\\Vert{\\alpha}\\Vert^2 + \\Vert{\\beta}\\Vert^2 = 1.")+"",Ce,K,dt=_("\\theta.")+"",ze,U,_t=_("\\cos{(\\frac{\\theta}{2})} \\cdot |0 \\rangle + \\sin{(\\frac{\\theta}{2})} \\cdot e^{i \\phi} |1 \\rangle.")+"",Fe,J,bt=_("\\theta")+"",De,X,vt=_("\\phi.")+"",We,Y,wt=_("\\theta")+"",Ge,Z,gt=_("z")+"",Oe,ee,$t=_("\\phi")+"",Re,te,Ke,ge,m=_("x-y")+"",T,M,Pe,$e,S,Ee,ae,b,Le,yt=_("\\theta")+"",at,Ae,Tt=_("\\phi")+"",nt,ve,st,Je,rt,it;return te=new me({props:{hovertext:ma,$$slots:{default:[_a]},$$scope:{ctx:t}}}),M=new me({props:{hovertext:ca,$$slots:{default:[ba]},$$scope:{ctx:t}}}),ae=new me({props:{hovertext:fa,$$slots:{default:[va]},$$scope:{ctx:t}}}),ve=new me({props:{hovertext:da,$$slots:{default:[wa]},$$scope:{ctx:t}}}),{c(){e=h("h2"),n=r("The Bloch-sphere"),i=Me(),l=h("p"),E=r("As the coefficients "),g=h("span"),v=r(" and "),w=h("span"),ce=r(" are complex numbers, they can be expressed in the form "),I=h("span"),xe=r(" and "),ne=h("span"),V=r(" Thus, the state of the qubit can be rewritten as "),j=h("span"),se=Me(),k=h("p"),Te=r("Remember that "),D=h("span"),qe=r(" is a unit vector rotated around the origin, and therefore the square of its norm "),Q=h("span"),ke=r(" also equals to "),c=h("span"),fe=r(" This means that we can modify the angles "),Se=h("span"),de=r(" and "),He=h("span"),re=r(" freely without affecting the measurement probabilities. Therefore, we can do an algebraic trick to simplify the expression above. Namely, let's divide the state by "),_e=h("span"),Ve=r(" to obtain "),W=h("span"),Be=r(" By the rules of exponentiation, "),G=h("span"),Ie=r(" Next, let's introduce a new variable "),O=h("span"),je=r(" with the help of which the state can be further simplified to "),z=h("span"),ie=Me(),y=h("p"),Qe=r("We know that "),R=h("span"),Ce=r(" Consequently, these two numbers can also be represented geometrically as vector of unit length rotated around the origin by some angle, the double of which we'll denote as "),K=h("span"),ze=r(" Using trigonometry, we can now rewrite the state as "),U=h("span"),Fe=r(" Notice that we now only need two variables to express the state of the qubit: the angles "),J=h("span"),De=r(" and "),X=h("span"),We=r(" Geometrically, this can be represented as a vector pointing to the surface of 3-dimensional sphere with unit radius, where "),Y=h("span"),Ge=r(" is the angle of the vector and the "),Z=h("span"),Oe=r(" axis, and "),ee=h("span"),Re=r(" is the angle of the vertical "),le(te.$$.fragment),Ke=r(" of the vector on the "),ge=h("span"),T=r(" plane. This representation of qubit states is called the "),le(M.$$.fragment),Pe=r("."),$e=Me(),S=h("p"),Ee=r("It's important to note that of the two "),le(ae.$$.fragment),b=r(" on the Bloch sphere, only the angle "),Le=h("span"),at=r(" is related to measurement probabilities. "),Ae=h("span"),nt=r(" is an inherently quantum property called the "),le(ve.$$.fragment),st=r(" that does not have physical manifestation directly observable to us. Because of this, it's hard to find any intuitive analogy from everyday life that could help us understand what exactly the phase is. The most useful approach in this context is to look at the phase as a matematical property of quantum objects that we can leverage to design clever algorithms.")},l(f){e=u(f,"H2",{});var A=p(e);n=o(A,"The Bloch-sphere"),A.forEach(s),i=Ne(f),l=u(f,"P",{});var C=p(l);E=o(C,"As the coefficients "),g=u(C,"SPAN",{});var lt=p(g);lt.forEach(s),v=o(C," and "),w=u(C,"SPAN",{});var ht=p(w);ht.forEach(s),ce=o(C," are complex numbers, they can be expressed in the form "),I=u(C,"SPAN",{});var ut=p(I);ut.forEach(s),xe=o(C," and "),ne=u(C,"SPAN",{});var At=p(ne);At.forEach(s),V=o(C," Thus, the state of the qubit can be rewritten as "),j=u(C,"SPAN",{});var Mt=p(j);Mt.forEach(s),C.forEach(s),se=Ne(f),k=u(f,"P",{});var N=p(k);Te=o(N,"Remember that "),D=u(N,"SPAN",{});var Nt=p(D);Nt.forEach(s),qe=o(N," is a unit vector rotated around the origin, and therefore the square of its norm "),Q=u(N,"SPAN",{});var xt=p(Q);xt.forEach(s),ke=o(N," also equals to "),c=u(N,"SPAN",{});var Vt=p(c);Vt.forEach(s),fe=o(N," This means that we can modify the angles "),Se=u(N,"SPAN",{});var Bt=p(Se);Bt.forEach(s),de=o(N," and "),He=u(N,"SPAN",{});var It=p(He);It.forEach(s),re=o(N," freely without affecting the measurement probabilities. Therefore, we can do an algebraic trick to simplify the expression above. Namely, let's divide the state by "),_e=u(N,"SPAN",{});var jt=p(_e);jt.forEach(s),Ve=o(N," to obtain "),W=u(N,"SPAN",{});var Qt=p(W);Qt.forEach(s),Be=o(N," By the rules of exponentiation, "),G=u(N,"SPAN",{});var Ct=p(G);Ct.forEach(s),Ie=o(N," Next, let's introduce a new variable "),O=u(N,"SPAN",{});var zt=p(O);zt.forEach(s),je=o(N," with the help of which the state can be further simplified to "),z=u(N,"SPAN",{});var Ft=p(z);Ft.forEach(s),N.forEach(s),ie=Ne(f),y=u(f,"P",{});var L=p(y);Qe=o(L,"We know that "),R=u(L,"SPAN",{});var Dt=p(R);Dt.forEach(s),Ce=o(L," Consequently, these two numbers can also be represented geometrically as vector of unit length rotated around the origin by some angle, the double of which we'll denote as "),K=u(L,"SPAN",{});var Wt=p(K);Wt.forEach(s),ze=o(L," Using trigonometry, we can now rewrite the state as "),U=u(L,"SPAN",{});var Gt=p(U);Gt.forEach(s),Fe=o(L," Notice that we now only need two variables to express the state of the qubit: the angles "),J=u(L,"SPAN",{});var Ot=p(J);Ot.forEach(s),De=o(L," and "),X=u(L,"SPAN",{});var Rt=p(X);Rt.forEach(s),We=o(L," Geometrically, this can be represented as a vector pointing to the surface of 3-dimensional sphere with unit radius, where "),Y=u(L,"SPAN",{});var Kt=p(Y);Kt.forEach(s),Ge=o(L," is the angle of the vector and the "),Z=u(L,"SPAN",{});var Ut=p(Z);Ut.forEach(s),Oe=o(L," axis, and "),ee=u(L,"SPAN",{});var Jt=p(ee);Jt.forEach(s),Re=o(L," is the angle of the vertical "),he(te.$$.fragment,L),Ke=o(L," of the vector on the "),ge=u(L,"SPAN",{});var Xt=p(ge);Xt.forEach(s),T=o(L," plane. This representation of qubit states is called the "),he(M.$$.fragment,L),Pe=o(L,"."),L.forEach(s),$e=Ne(f),S=u(f,"P",{});var we=p(S);Ee=o(we,"It's important to note that of the two "),he(ae.$$.fragment,we),b=o(we," on the Bloch sphere, only the angle "),Le=u(we,"SPAN",{});var Yt=p(Le);Yt.forEach(s),at=o(we," is related to measurement probabilities. "),Ae=u(we,"SPAN",{});var Zt=p(Ae);Zt.forEach(s),nt=o(we," is an inherently quantum property called the "),he(ve.$$.fragment,we),st=o(we," that does not have physical manifestation directly observable to us. Because of this, it's hard to find any intuitive analogy from everyday life that could help us understand what exactly the phase is. The most useful approach in this context is to look at the phase as a matematical property of quantum objects that we can leverage to design clever algorithms."),we.forEach(s)},m(f,A){q(f,e,A),a(e,n),q(f,i,A),q(f,l,A),a(l,E),a(l,g),g.innerHTML=$,a(l,v),a(l,w),w.innerHTML=H,a(l,ce),a(l,I),I.innerHTML=x,a(l,xe),a(l,ne),ne.innerHTML=ye,a(l,V),a(l,j),j.innerHTML=Ue,q(f,se,A),q(f,k,A),a(k,Te),a(k,D),D.innerHTML=ot,a(k,qe),a(k,Q),Q.innerHTML=Xe,a(k,ke),a(k,c),c.innerHTML=Ye,a(k,fe),a(k,Se),Se.innerHTML=Ze,a(k,de),a(k,He),He.innerHTML=et,a(k,re),a(k,_e),_e.innerHTML=be,a(k,Ve),a(k,W),W.innerHTML=pt,a(k,Be),a(k,G),G.innerHTML=mt,a(k,Ie),a(k,O),O.innerHTML=ct,a(k,je),a(k,z),z.innerHTML=tt,q(f,ie,A),q(f,y,A),a(y,Qe),a(y,R),R.innerHTML=ft,a(y,Ce),a(y,K),K.innerHTML=dt,a(y,ze),a(y,U),U.innerHTML=_t,a(y,Fe),a(y,J),J.innerHTML=bt,a(y,De),a(y,X),X.innerHTML=vt,a(y,We),a(y,Y),Y.innerHTML=wt,a(y,Ge),a(y,Z),Z.innerHTML=gt,a(y,Oe),a(y,ee),ee.innerHTML=$t,a(y,Re),ue(te,y,null),a(y,Ke),a(y,ge),ge.innerHTML=m,a(y,T),ue(M,y,null),a(y,Pe),q(f,$e,A),q(f,S,A),a(S,Ee),ue(ae,S,null),a(S,b),a(S,Le),Le.innerHTML=yt,a(S,at),a(S,Ae),Ae.innerHTML=Tt,a(S,nt),ue(ve,S,null),a(S,st),Je=!0,rt||(it=[d(g,"mouseenter",t[0]),d(w,"mouseenter",t[1]),d(I,"mouseenter",t[2]),d(ne,"mouseenter",t[3]),d(j,"mouseenter",t[4]),d(D,"mouseenter",t[5]),d(Q,"mouseenter",t[6]),d(c,"mouseenter",t[7]),d(Se,"mouseenter",t[8]),d(He,"mouseenter",t[9]),d(_e,"mouseenter",t[10]),d(W,"mouseenter",t[11]),d(G,"mouseenter",t[12]),d(O,"mouseenter",t[13]),d(z,"mouseenter",t[14]),d(R,"mouseenter",t[15]),d(K,"mouseenter",t[16]),d(U,"mouseenter",t[17]),d(J,"mouseenter",t[18]),d(X,"mouseenter",t[19]),d(Y,"mouseenter",t[20]),d(Z,"mouseenter",t[21]),d(ee,"mouseenter",t[22]),d(ge,"mouseenter",t[23]),d(Le,"mouseenter",t[24]),d(Ae,"mouseenter",t[25])],rt=!0)},p(f,[A]){const C={};A&67108864&&(C.$$scope={dirty:A,ctx:f}),te.$set(C);const lt={};A&67108864&&(lt.$$scope={dirty:A,ctx:f}),M.$set(lt);const ht={};A&67108864&&(ht.$$scope={dirty:A,ctx:f}),ae.$set(ht);const ut={};A&67108864&&(ut.$$scope={dirty:A,ctx:f}),ve.$set(ut)},i(f){Je||(F(te.$$.fragment,f),F(M.$$.fragment,f),F(ae.$$.fragment,f),F(ve.$$.fragment,f),Je=!0)},o(f){oe(te.$$.fragment,f),oe(M.$$.fragment,f),oe(ae.$$.fragment,f),oe(ve.$$.fragment,f),Je=!1},d(f){f&&s(e),f&&s(i),f&&s(l),f&&s(se),f&&s(k),f&&s(ie),f&&s(y),pe(te),pe(M),f&&s($e),f&&s(S),pe(ae),pe(ve),rt=!1,Ht(it)}}}function P(t){console.log(t)}function $a(t){return[()=>P(["\\alpha"]),()=>P(["\\beta"]),()=>P(["\\phi","\\alpha"]),()=>P(["\\phi","\\beta"]),()=>P(["\\phi","\\alpha","\\beta"]),()=>P(["\\phi","\\alpha"]),()=>P(["\\phi","\\alpha"]),()=>P([]),()=>P(["\\phi","\\alpha"]),()=>P(["\\phi","\\beta"]),()=>P(["\\phi","\\alpha"]),()=>P(["\\phi","\\alpha","\\beta"]),()=>P(["\\phi","\\alpha","\\beta"]),()=>P(["\\phi","\\alpha","\\beta"]),()=>P(["\\phi","\\alpha","\\beta"]),()=>P(["\\alpha","\\beta"]),()=>P(["\\theta"]),()=>P(["\\phi","\\theta"]),()=>P(["\\theta"]),()=>P(["\\phi"]),()=>P(["\\theta"]),()=>P(["z"]),()=>P(["\\phi"]),()=>P(["y","x"]),()=>P(["\\theta"]),()=>P(["\\phi"])]}class Fa extends qt{constructor(e){super(),kt(this,e,$a,ga,St,{})}}const ya='<a href="https://en.wikipedia.org/wiki/Bit"><h3 class="text-lg font-semibold">Bit</h3></a><p>The <b>bit</b> is the most basic unit of information in computing and digital communications. The name is a portmanteau of <b>binary digit</b>. The bit represents a logical state with one of two possible values. These values are most commonly represented as either <span class="nowrap">"<span class="monospaced">1</span>" or "<span class="monospaced">0</span>"</span>, but other representations such as <i>true</i>/<i>false</i>, <i>yes</i>/<i>no</i>, <i>on</i>/<i>off</i>, or <i>+</i>/<i>\u2212</i> are also commonly used.</p>',Ta='<a href="https://en.wikipedia.org/wiki/Information_theory"><h3>Information theory</h3></a><p><b>Information theory</b> is the scientific study of the quantification, storage, and communication of digital information. The field was fundamentally established by the works of Harry Nyquist and Ralph Hartley, in the 1920s, and Claude Shannon in the 1940s. The field is at the intersection of probability theory, statistics, computer science, statistical mechanics, information engineering, and electrical engineering.</p>',qa='<a href="https://en.wikipedia.org/wiki/Qubit"><h3 class="text-lg font-semibold">Qubit</h3></a><p>In quantum computing, a <b>qubit</b> or <b>quantum bit</b> is a basic unit of quantum information\u2014the quantum version of the classic binary bit physically realized with a two-state device. A qubit is a two-state quantum-mechanical system, one of the simplest quantum systems displaying the peculiarity of quantum mechanics. Examples include the spin of the electron in which the two levels can be taken as spin up and spin down; or the polarization of a single photon in which the two states can be taken to be the vertical polarization and the horizontal polarization. In a classical system, a bit would have to be in one state or the other. However, quantum mechanics allows the qubit to be in a coherent superposition of both states simultaneously, a property that is fundamental to quantum mechanics and quantum computing.</p>',ka='<a href="https://en.wikipedia.org/wiki/Measurement_in_quantum_mechanics"><h3>Measurement in quantum mechanics</h3></a><p>In quantum physics, a <b>measurement</b> is the testing or manipulation of a physical system to yield a numerical result. The predictions that quantum physics makes are in general probabilistic. The mathematical tools for making predictions about what measurement outcomes may occur were developed during the 20th century and make use of linear algebra and functional analysis.</p>',Sa=`<a href="https://en.wikipedia.org/wiki/Quantum_state"><h3>Quantum state</h3></a><p>In quantum physics, a <b>quantum state</b> is a mathematical entity that provides a probability distribution for the outcomes of each possible measurement on a system. Knowledge of the quantum state together with the rules for the system's evolution in time exhausts all that can be predicted about the system's behavior. A mixture of quantum states is again a quantum state. Quantum states that cannot be written as a mixture of other states are called <b>pure quantum states</b>, while all other states are called <b>mixed quantum states</b>. A pure quantum state can be represented by a ray in a Hilbert space over the complex numbers, while mixed states are represented by density matrices, which are positive semidefinite operators that act on Hilbert spaces.</p>`,Ha=`<a href="https://en.wikipedia.org/wiki/Linear_combination"><h3>Linear combination</h3></a><p>In mathematics, a <b>linear combination</b> is an expression constructed from a set of terms by multiplying each term by a constant and adding the results. The concept of linear combinations is central to linear algebra and related fields of mathematics.
Most of this article deals with linear combinations in the context of a vector space over a field, with some generalizations given at the end of the article.</p>`,Pa='<a href="https://en.wikipedia.org/wiki/Complex_number"><h3 class="text-lg font-semibold">Complex number</h3></a><p>In mathematics, a <b>complex number</b> is an element of a number system that extends the real numbers with a specific element denoted <span class="texhtml mvar" style="font-style:italic">i</span>, called the imaginary unit and satisfying the equation <span class="texhtml "><i>i</i><sup>2</sup> = \u22121</span>; every complex number can be expressed in the form <span class="texhtml "><i>a</i> + <i>bi</i></span>, where <span class="texhtml mvar" style="font-style:italic">a</span> and <span class="texhtml mvar" style="font-style:italic">b</span> are real numbers. Because no real number satisfies the above equation, <span class="texhtml mvar" style="font-style:italic">i</span> was called an imaginary number by Ren\xE9 Descartes. For the complex number <span class="texhtml "><i>a</i> + <i>bi</i></span>, <span class="texhtml mvar" style="font-style:italic">a</span> is called the <b><span class="vanchor"><span class="vanchor-text">real part</span></span></b> and <span class="texhtml mvar" style="font-style:italic">b</span> is called the <b><span class="vanchor"><span class="vanchor-text">imaginary part</span></span></b>. The set of complex numbers is denoted by either of the symbols <span class="mwe-math-element"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f9add4085095b9b6d28d045fd9c92c2c09f549a7" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align:-0.338ex;width:1.678ex;height:2.176ex" /></span> or <span class="texhtml "><b>C</b></span>. Despite the historical nomenclature "imaginary", complex numbers are regarded in the mathematical sciences as just as "real" as the real numbers and are fundamental in many aspects of the scientific description of the natural world.</p>';function Ea(t){let e;return{c(){e=r("bits")},l(n){e=o(n,"bits")},m(n,i){q(n,e,i)},d(n){n&&s(e)}}}function La(t){let e;return{c(){e=r("bit of information")},l(n){e=o(n,"bit of information")},m(n,i){q(n,e,i)},d(n){n&&s(e)}}}function Aa(t){let e;return{c(){e=r("Qubits")},l(n){e=o(n,"Qubits")},m(n,i){q(n,e,i)},d(n){n&&s(e)}}}function Ma(t){let e;return{c(){e=r("measured")},l(n){e=o(n,"measured")},m(n,i){q(n,e,i)},d(n){n&&s(e)}}}function Na(t){let e;return{c(){e=r("state")},l(n){e=o(n,"state")},m(n,i){q(n,e,i)},d(n){n&&s(e)}}}function xa(t){let e;return{c(){e=r("linear combination")},l(n){e=o(n,"linear combination")},m(n,i){q(n,e,i)},d(n){n&&s(e)}}}function Va(t){let e;return{c(){e=r("complex numbers")},l(n){e=o(n,"complex numbers")},m(n,i){q(n,e,i)},d(n){n&&s(e)}}}function Ba(t){let e,n,i,l,E,g,$,v,w,H,ce=_("0")+"",I,x,xe=_("1")+"",ne,ye,V,j,Ue,se,k=_("0")+"",Te,D,ot=_("1,")+"",qe,Q,Xe,ke,c,Ye,fe,Se=_("|0\\rangle")+"",Ze,de,He=_("|1\\rangle")+"",et,re,_e,be,Ve,W,pt=_("\\alpha |0\\rangle + \\beta |1\\rangle.")+"",Be,G,mt=_("\\alpha")+"",Ie,O,ct=_("\\beta")+"",je,z,tt,ie,y=_("|0\\rangle")+"",Qe,R,ft=_("\\Vert{\\alpha}\\Vert^2,")+"",Ce,K,dt=_("|1\\rangle")+"",ze,U,_t=_("\\Vert{\\beta}\\Vert^2.")+"",Fe,J,bt=_("|0\\rangle")+"",De,X,vt=_("|1\\rangle")+"",We,Y,wt=_("\\Vert{\\alpha}\\Vert^2 + \\Vert{\\beta}\\Vert^2 = 1")+"",Ge,Z,gt=_("\\Vert{\\alpha}\\Vert^2")+"",Oe,ee,$t=_("\\Vert{\\beta}\\Vert^2")+"",Re,te,Ke,ge;return g=new me({props:{hovertext:ya,$$slots:{default:[Ea]},$$scope:{ctx:t}}}),v=new me({props:{hovertext:Ta,$$slots:{default:[La]},$$scope:{ctx:t}}}),j=new me({props:{hovertext:qa,$$slots:{default:[Aa]},$$scope:{ctx:t}}}),Q=new me({props:{hovertext:ka,$$slots:{default:[Ma]},$$scope:{ctx:t}}}),re=new me({props:{hovertext:Sa,$$slots:{default:[Na]},$$scope:{ctx:t}}}),be=new me({props:{hovertext:Ha,$$slots:{default:[xa]},$$scope:{ctx:t}}}),z=new me({props:{hovertext:Pa,$$slots:{default:[Va]},$$scope:{ctx:t}}}),{c(){e=h("h2"),n=r("Qubit states"),i=Me(),l=h("p"),E=r("The elementary units of information in classical computing are "),le(g.$$.fragment),$=r(". As their name suggests, bits represent one single "),le(v.$$.fragment),w=r(", which means they can take on either of two values "),H=h("span"),I=r(" and "),x=h("span"),ne=r(" at a time."),ye=Me(),V=h("p"),le(j.$$.fragment),Ue=r(" are the quantum computing equivalent of bits. They differ from classical bits - among other things - in that they can take on a multitude of values instead of just "),se=h("span"),Te=r(" and "),D=h("span"),qe=r(" until that value is "),le(Q.$$.fragment),Xe=r(", at which point they behave just like classical bits. To explain what this means exactly, we'll need to introduce some further concepts."),ke=Me(),c=h("p"),Ye=r("Let "),fe=h("span"),Ze=r(" and "),de=h("span"),et=r(" denote the so called basis states of a qubit that are the quantum-equivalent of classical bit states. If you look at a qubit directly to learn it's value, you'll see one of these basis states. But while you're not looking - due to it's quantum nature - the "),le(re.$$.fragment),_e=r(" of a qubit may be something more intricate. Generally, it can be expressed as the "),le(be.$$.fragment),Ve=r(" of the two basis states: "),W=h("span"),Be=r(" Here, "),G=h("span"),Ie=r(" and "),O=h("span"),je=r(" are "),le(z.$$.fragment),tt=r(" that indicate the relative weight, with which the two basis states are present in this combination. More precisely, if we now look at the qubit, we'll see the basis state "),ie=h("span"),Qe=r(" with a probability of "),R=h("span"),Ce=r(" and the basis state "),K=h("span"),ze=r(" with a probability of "),U=h("span"),Fe=r(" Because these probabilities must add up to one - as "),J=h("span"),De=r(" and "),X=h("span"),We=r(" are the only possible outcomes - the equation "),Y=h("span"),Ge=r(" must hold for all possible qubit states. Let's call "),Z=h("span"),Oe=r(" and "),ee=h("span"),Re=r(" the measurement probabilities of the basis states.")},l(m){e=u(m,"H2",{});var T=p(e);n=o(T,"Qubit states"),T.forEach(s),i=Ne(m),l=u(m,"P",{});var M=p(l);E=o(M,"The elementary units of information in classical computing are "),he(g.$$.fragment,M),$=o(M,". As their name suggests, bits represent one single "),he(v.$$.fragment,M),w=o(M,", which means they can take on either of two values "),H=u(M,"SPAN",{});var Pe=p(H);Pe.forEach(s),I=o(M," and "),x=u(M,"SPAN",{});var $e=p(x);$e.forEach(s),ne=o(M," at a time."),M.forEach(s),ye=Ne(m),V=u(m,"P",{});var S=p(V);he(j.$$.fragment,S),Ue=o(S," are the quantum computing equivalent of bits. They differ from classical bits - among other things - in that they can take on a multitude of values instead of just "),se=u(S,"SPAN",{});var Ee=p(se);Ee.forEach(s),Te=o(S," and "),D=u(S,"SPAN",{});var ae=p(D);ae.forEach(s),qe=o(S," until that value is "),he(Q.$$.fragment,S),Xe=o(S,", at which point they behave just like classical bits. To explain what this means exactly, we'll need to introduce some further concepts."),S.forEach(s),ke=Ne(m),c=u(m,"P",{});var b=p(c);Ye=o(b,"Let "),fe=u(b,"SPAN",{});var Le=p(fe);Le.forEach(s),Ze=o(b," and "),de=u(b,"SPAN",{});var yt=p(de);yt.forEach(s),et=o(b," denote the so called basis states of a qubit that are the quantum-equivalent of classical bit states. If you look at a qubit directly to learn it's value, you'll see one of these basis states. But while you're not looking - due to it's quantum nature - the "),he(re.$$.fragment,b),_e=o(b," of a qubit may be something more intricate. Generally, it can be expressed as the "),he(be.$$.fragment,b),Ve=o(b," of the two basis states: "),W=u(b,"SPAN",{});var at=p(W);at.forEach(s),Be=o(b," Here, "),G=u(b,"SPAN",{});var Ae=p(G);Ae.forEach(s),Ie=o(b," and "),O=u(b,"SPAN",{});var Tt=p(O);Tt.forEach(s),je=o(b," are "),he(z.$$.fragment,b),tt=o(b," that indicate the relative weight, with which the two basis states are present in this combination. More precisely, if we now look at the qubit, we'll see the basis state "),ie=u(b,"SPAN",{});var nt=p(ie);nt.forEach(s),Qe=o(b," with a probability of "),R=u(b,"SPAN",{});var ve=p(R);ve.forEach(s),Ce=o(b," and the basis state "),K=u(b,"SPAN",{});var st=p(K);st.forEach(s),ze=o(b," with a probability of "),U=u(b,"SPAN",{});var Je=p(U);Je.forEach(s),Fe=o(b," Because these probabilities must add up to one - as "),J=u(b,"SPAN",{});var rt=p(J);rt.forEach(s),De=o(b," and "),X=u(b,"SPAN",{});var it=p(X);it.forEach(s),We=o(b," are the only possible outcomes - the equation "),Y=u(b,"SPAN",{});var f=p(Y);f.forEach(s),Ge=o(b," must hold for all possible qubit states. Let's call "),Z=u(b,"SPAN",{});var A=p(Z);A.forEach(s),Oe=o(b," and "),ee=u(b,"SPAN",{});var C=p(ee);C.forEach(s),Re=o(b," the measurement probabilities of the basis states."),b.forEach(s)},m(m,T){q(m,e,T),a(e,n),q(m,i,T),q(m,l,T),a(l,E),ue(g,l,null),a(l,$),ue(v,l,null),a(l,w),a(l,H),H.innerHTML=ce,a(l,I),a(l,x),x.innerHTML=xe,a(l,ne),q(m,ye,T),q(m,V,T),ue(j,V,null),a(V,Ue),a(V,se),se.innerHTML=k,a(V,Te),a(V,D),D.innerHTML=ot,a(V,qe),ue(Q,V,null),a(V,Xe),q(m,ke,T),q(m,c,T),a(c,Ye),a(c,fe),fe.innerHTML=Se,a(c,Ze),a(c,de),de.innerHTML=He,a(c,et),ue(re,c,null),a(c,_e),ue(be,c,null),a(c,Ve),a(c,W),W.innerHTML=pt,a(c,Be),a(c,G),G.innerHTML=mt,a(c,Ie),a(c,O),O.innerHTML=ct,a(c,je),ue(z,c,null),a(c,tt),a(c,ie),ie.innerHTML=y,a(c,Qe),a(c,R),R.innerHTML=ft,a(c,Ce),a(c,K),K.innerHTML=dt,a(c,ze),a(c,U),U.innerHTML=_t,a(c,Fe),a(c,J),J.innerHTML=bt,a(c,De),a(c,X),X.innerHTML=vt,a(c,We),a(c,Y),Y.innerHTML=wt,a(c,Ge),a(c,Z),Z.innerHTML=gt,a(c,Oe),a(c,ee),ee.innerHTML=$t,a(c,Re),te=!0,Ke||(ge=[d(H,"mouseenter",t[0]),d(x,"mouseenter",t[1]),d(se,"mouseenter",t[2]),d(D,"mouseenter",t[3]),d(fe,"mouseenter",t[4]),d(de,"mouseenter",t[5]),d(W,"mouseenter",t[6]),d(G,"mouseenter",t[7]),d(O,"mouseenter",t[8]),d(ie,"mouseenter",t[9]),d(R,"mouseenter",t[10]),d(K,"mouseenter",t[11]),d(U,"mouseenter",t[12]),d(J,"mouseenter",t[13]),d(X,"mouseenter",t[14]),d(Y,"mouseenter",t[15]),d(Z,"mouseenter",t[16]),d(ee,"mouseenter",t[17])],Ke=!0)},p(m,[T]){const M={};T&262144&&(M.$$scope={dirty:T,ctx:m}),g.$set(M);const Pe={};T&262144&&(Pe.$$scope={dirty:T,ctx:m}),v.$set(Pe);const $e={};T&262144&&($e.$$scope={dirty:T,ctx:m}),j.$set($e);const S={};T&262144&&(S.$$scope={dirty:T,ctx:m}),Q.$set(S);const Ee={};T&262144&&(Ee.$$scope={dirty:T,ctx:m}),re.$set(Ee);const ae={};T&262144&&(ae.$$scope={dirty:T,ctx:m}),be.$set(ae);const b={};T&262144&&(b.$$scope={dirty:T,ctx:m}),z.$set(b)},i(m){te||(F(g.$$.fragment,m),F(v.$$.fragment,m),F(j.$$.fragment,m),F(Q.$$.fragment,m),F(re.$$.fragment,m),F(be.$$.fragment,m),F(z.$$.fragment,m),te=!0)},o(m){oe(g.$$.fragment,m),oe(v.$$.fragment,m),oe(j.$$.fragment,m),oe(Q.$$.fragment,m),oe(re.$$.fragment,m),oe(be.$$.fragment,m),oe(z.$$.fragment,m),te=!1},d(m){m&&s(e),m&&s(i),m&&s(l),pe(g),pe(v),m&&s(ye),m&&s(V),pe(j),pe(Q),m&&s(ke),m&&s(c),pe(re),pe(be),pe(z),Ke=!1,Ht(ge)}}}function B(t){console.log(t)}function Ia(t){return[()=>B([]),()=>B([]),()=>B([]),()=>B([]),()=>B([]),()=>B([]),()=>B(["\\alpha","\\beta"]),()=>B(["\\alpha"]),()=>B(["\\beta"]),()=>B([]),()=>B(["\\alpha"]),()=>B([]),()=>B(["\\beta"]),()=>B([]),()=>B([]),()=>B(["\\alpha","\\beta"]),()=>B(["\\alpha"]),()=>B(["\\beta"])]}class Da extends qt{constructor(e){super(),kt(this,e,Ia,Ba,St,{})}}export{me as H,Da as Q,Fa as a,za as d,Ca as s};
