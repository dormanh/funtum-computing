import{S as Ht,i as qt,s as Lt,l as o,u as s,a as j,L as Se,e as Cs,m as l,p as i,v as r,h as t,c as D,M as Ae,q as fe,b as w,H as e,N as Qt,O as u,P as Bo,Q as ua,R as zo,n as at,T as Ut,F as Qo,I as Co,J as Wo,K as jo,f as ze,t as Ge,U as Do,V as Uo,x as Ye,y as xe,z as et,C as tt,W as Es,X as Ns,Y as $s,Z as Ws}from"../chunks/index-bb217d03.js";import{m as h,g as _n,Q as js,C as Ko,p as Ds}from"../chunks/CameraControl-d03be3a0.js";function Ro(a){let n,p,m,f=h(`K = ${a[6]}`)+"",y,d,_=h("r")+"",g,E,I=h("a^r \\mod N = 1")+"",v,k,V,H,L,G=h("r")+"",U,A,B=h(`${a[1]}^{${a[2]}} \\mod ${a[0]} = 1`)+"",q,C,P=h("m")+"",J,S,z=h(`${a[1]}^{${a[2]}} = m \\cdot ${a[0]} + 1`)+"",Z,W;function x(T,O){return T[2]%2==0?Go:Xo}let $=x(a),M=$(a);return{c(){n=o("p"),p=s("As "),m=new Se(!1),y=s(", the value of "),d=new Se(!1),g=s(" in "),E=new Se(!1),v=s(` will
		be informative.`),k=j(),V=o("p"),H=s(`As these are all relatively small numbers, we can try all relevant possible values for
		`),L=new Se(!1),U=s(" rather quickly and find that "),A=new Se(!1),q=s(` which means
		that there is an `),C=new Se(!1),J=s(" for which "),S=new Se(!1),Z=j(),W=o("p"),M.c(),this.h()},l(T){n=l(T,"P",{});var O=i(n);p=r(O,"As "),m=Ae(O,!1),y=r(O,", the value of "),d=Ae(O,!1),g=r(O," in "),E=Ae(O,!1),v=r(O,` will
		be informative.`),O.forEach(t),k=D(T),V=l(T,"P",{});var X=i(V);H=r(X,`As these are all relatively small numbers, we can try all relevant possible values for
		`),L=Ae(X,!1),U=r(X," rather quickly and find that "),A=Ae(X,!1),q=r(X,` which means
		that there is an `),C=Ae(X,!1),J=r(X," for which "),S=Ae(X,!1),X.forEach(t),Z=D(T),W=l(T,"P",{});var Ne=i(W);M.l(Ne),Ne.forEach(t),this.h()},h(){m.a=y,d.a=g,E.a=v,L.a=U,A.a=q,C.a=J,S.a=null},m(T,O){w(T,n,O),e(n,p),m.m(f,n),e(n,y),d.m(_,n),e(n,g),E.m(I,n),e(n,v),w(T,k,O),w(T,V,O),e(V,H),L.m(G,V),e(V,U),A.m(B,V),e(V,q),C.m(P,V),e(V,J),S.m(z,V),w(T,Z,O),w(T,W,O),M.m(W,null)},p(T,O){O&64&&f!==(f=h(`K = ${T[6]}`)+"")&&m.p(f),O&7&&B!==(B=h(`${T[1]}^{${T[2]}} \\mod ${T[0]} = 1`)+"")&&A.p(B),O&7&&z!==(z=h(`${T[1]}^{${T[2]}} = m \\cdot ${T[0]} + 1`)+"")&&S.p(z),$===($=x(T))&&M?M.p(T,O):(M.d(1),M=$(T),M&&(M.c(),M.m(W,null)))},d(T){T&&t(n),T&&t(k),T&&t(V),T&&t(Z),T&&t(W),M.d()}}}function Oo(a){let n,p,m,f=h("K \\neq 1")+"",y,d,_=h("a")+"",g,E,I=h("N")+"",v,k,V=h(`K=${a[6]}`)+"",H,L,G=h("a")+"",U;return{c(){n=o("p"),p=s("As in this case "),m=new Se(!1),y=s(", a new "),d=new Se(!1),g=s(` is needed. Or to put a more positive
		spin on it, we instantly can found a prime factor for `),E=new Se(!1),v=s(`, which in fact
		`),k=new Se(!1),H=s(` is. However, in order to see the whole algorithm in action, we should choose
		a new `),L=new Se(!1),U=s("."),this.h()},l(A){n=l(A,"P",{});var B=i(n);p=r(B,"As in this case "),m=Ae(B,!1),y=r(B,", a new "),d=Ae(B,!1),g=r(B,` is needed. Or to put a more positive
		spin on it, we instantly can found a prime factor for `),E=Ae(B,!1),v=r(B,`, which in fact
		`),k=Ae(B,!1),H=r(B,` is. However, in order to see the whole algorithm in action, we should choose
		a new `),L=Ae(B,!1),U=r(B,"."),B.forEach(t),this.h()},h(){m.a=y,d.a=g,E.a=v,k.a=H,L.a=U},m(A,B){w(A,n,B),e(n,p),m.m(f,n),e(n,y),d.m(_,n),e(n,g),E.m(I,n),e(n,v),k.m(V,n),e(n,H),L.m(G,n),e(n,U)},p(A,B){B&64&&V!==(V=h(`K=${A[6]}`)+"")&&k.p(V)},d(A){A&&t(n)}}}function Xo(a){let n,p=h("r")+"",m,f,y=h("a")+"",d;return{c(){n=new Se(!1),m=s(" is odd, we need a new "),f=new Se(!1),d=s("."),this.h()},l(_){n=Ae(_,!1),m=r(_," is odd, we need a new "),f=Ae(_,!1),d=r(_,"."),this.h()},h(){n.a=m,f.a=d},m(_,g){n.m(p,_,g),w(_,m,g),f.m(y,_,g),w(_,d,g)},p:at,d(_){_&&n.d(),_&&t(m),_&&f.d(),_&&t(d)}}}function Go(a){let n,p,m=h("r")+"",f,y,d=h("b = a^{\\frac{r}{2}}")+"",_,g,E=h("a^r = m \\cdot N + 1 \\Rightarrow b^2-1 = (b + 1)(b - 1) = m \\cdot N")+"",I,v,k=h(`b = ${a[5]}`)+"",V,H,L=h("N")+"",G,U,A=h("b-1")+"",B,q,C=h("b+1")+"",P,J,S=h(`${_n(a[0],a[5]-1)}`)+"",z,Z,W=h(`${_n(a[0],a[5]+1)}`)+"",x;return{c(){n=s("As "),p=new Se(!1),f=s(" is even, so we can create "),y=new Se(!1),_=s(`, and
			expand the above so that
			`),g=new Se(!1),I=s(`. In this
			case, as `),v=new Se(!1),V=s(`, we can calculate the greatest common divisor for
			`),H=new Se(!1),G=s(" with "),U=new Se(!1),B=s(" and "),q=new Se(!1),P=s(` very quickly, which are
			`),J=new Se(!1),z=s(" and "),Z=new Se(!1),x=s(" respectively"),this.h()},l($){n=r($,"As "),p=Ae($,!1),f=r($," is even, so we can create "),y=Ae($,!1),_=r($,`, and
			expand the above so that
			`),g=Ae($,!1),I=r($,`. In this
			case, as `),v=Ae($,!1),V=r($,`, we can calculate the greatest common divisor for
			`),H=Ae($,!1),G=r($," with "),U=Ae($,!1),B=r($," and "),q=Ae($,!1),P=r($,` very quickly, which are
			`),J=Ae($,!1),z=r($," and "),Z=Ae($,!1),x=r($," respectively"),this.h()},h(){p.a=f,y.a=_,g.a=I,v.a=V,H.a=G,U.a=B,q.a=P,J.a=z,Z.a=x},m($,M){w($,n,M),p.m(m,$,M),w($,f,M),y.m(d,$,M),w($,_,M),g.m(E,$,M),w($,I,M),v.m(k,$,M),w($,V,M),H.m(L,$,M),w($,G,M),U.m(A,$,M),w($,B,M),q.m(C,$,M),w($,P,M),J.m(S,$,M),w($,z,M),Z.m(W,$,M),w($,x,M)},p($,M){M&32&&k!==(k=h(`b = ${$[5]}`)+"")&&v.p(k),M&33&&S!==(S=h(`${_n($[0],$[5]-1)}`)+"")&&J.p(S),M&33&&W!==(W=h(`${_n($[0],$[5]+1)}`)+"")&&Z.p(W)},d($){$&&t(n),$&&p.d(),$&&t(f),$&&y.d(),$&&t(_),$&&g.d(),$&&t(I),$&&v.d(),$&&t(V),$&&H.d(),$&&t(G),$&&U.d(),$&&t(B),$&&q.d(),$&&t(P),$&&J.d(),$&&t(z),$&&Z.d(),$&&t(x)}}}function Jo(a){let n,p,m,f,y,d,_,g,E,I,v,k,V,H,L,G,U,A=h(` = ${a[3]} \\cdot ${a[4]}`)+"",B,q,C,P,J=h(`a = ${a[1]}`)+"",S,z,Z=h(`N = ${a[0]}`)+"",W,x,$=h(`K = ${a[6]}`)+"",M,T,O,X,Ne;function K(c,N){return c[6]!=1?Oo:Ro}let F=K(a),we=F(a);return{c(){n=o("div"),p=o("div"),m=s("a:"),f=j(),y=o("input"),_=j(),g=o("input"),I=j(),v=o("div"),k=s("N:"),V=j(),H=o("input"),G=j(),U=o("div"),B=j(),q=o("p"),C=s("The greatest common divisor of "),P=new Se(!1),S=s(" and "),z=new Se(!1),W=s(` is
	`),x=new Se(!1),M=s(". This is very quick to calculate."),T=j(),we.c(),O=Cs(),this.h()},l(c){n=l(c,"DIV",{class:!0});var N=i(n);p=l(N,"DIV",{class:!0});var de=i(p);m=r(de,"a:"),de.forEach(t),f=D(N),y=l(N,"INPUT",{class:!0,type:!0,min:!0,max:!0}),_=D(N),g=l(N,"INPUT",{class:!0,type:!0,min:!0,max:!0}),I=D(N),v=l(N,"DIV",{class:!0});var te=i(v);k=r(te,"N:"),te.forEach(t),V=D(N),H=l(N,"INPUT",{class:!0,type:!0,min:!0,max:!0}),G=D(N),U=l(N,"DIV",{id:!0,class:!0});var ee=i(U);ee.forEach(t),N.forEach(t),B=D(c),q=l(c,"P",{});var ye=i(q);C=r(ye,"The greatest common divisor of "),P=Ae(ye,!1),S=r(ye," and "),z=Ae(ye,!1),W=r(ye,` is
	`),x=Ae(ye,!1),M=r(ye,". This is very quick to calculate."),ye.forEach(t),T=D(c),we.l(c),O=Cs(),this.h()},h(){fe(p,"class","varlabel svelte-zwcizk"),fe(y,"class","numsel svelte-zwcizk"),fe(y,"type","number"),fe(y,"min",2),fe(y,"max",d=a[0]-1),fe(g,"class","slider svelte-zwcizk"),fe(g,"type","range"),fe(g,"min",2),fe(g,"max",E=a[0]-1),fe(v,"class","varlabel svelte-zwcizk"),fe(H,"class","numsel svelte-zwcizk"),fe(H,"type","number"),fe(H,"min","1"),fe(H,"max",a[7]),fe(U,"id","decomp"),fe(U,"class","svelte-zwcizk"),fe(n,"class","cpanel svelte-zwcizk"),P.a=S,z.a=W,x.a=M},m(c,N){w(c,n,N),e(n,p),e(p,m),e(n,f),e(n,y),Qt(y,a[1]),e(n,_),e(n,g),Qt(g,a[1]),e(n,I),e(n,v),e(v,k),e(n,V),e(n,H),Qt(H,a[0]),e(n,G),e(n,U),U.innerHTML=A,w(c,B,N),w(c,q,N),e(q,C),P.m(J,q),e(q,S),z.m(Z,q),e(q,W),x.m($,q),e(q,M),w(c,T,N),we.m(c,N),w(c,O,N),X||(Ne=[u(y,"input",a[10]),u(g,"change",a[11]),u(g,"input",a[11]),Bo(L=a[8].call(null,H,a[0])),u(H,"input",a[12])],X=!0)},p(c,[N]){N&1&&d!==(d=c[0]-1)&&fe(y,"max",d),N&2&&ua(y.value)!==c[1]&&Qt(y,c[1]),N&1&&E!==(E=c[0]-1)&&fe(g,"max",E),N&2&&Qt(g,c[1]),L&&zo(L.update)&&N&1&&L.update.call(null,c[0]),N&1&&ua(H.value)!==c[0]&&Qt(H,c[0]),N&24&&A!==(A=h(` = ${c[3]} \\cdot ${c[4]}`)+"")&&(U.innerHTML=A),N&2&&J!==(J=h(`a = ${c[1]}`)+"")&&P.p(J),N&1&&Z!==(Z=h(`N = ${c[0]}`)+"")&&z.p(Z),N&64&&$!==($=h(`K = ${c[6]}`)+"")&&x.p($),F===(F=K(c))&&we?we.p(c,N):(we.d(1),we=F(c),we&&(we.c(),we.m(O.parentNode,O)))},i:at,o:at,d(c){c&&t(n),c&&t(B),c&&t(q),c&&t(T),we.d(c),c&&t(O),X=!1,Ut(Ne)}}}function Zo(a,n){for(let p=1;p<n;p++){let m=a%n;for(let f=1;f<p;f++)m=m*a%n;if(m==1)return p}return 0}function Yo(a,n,p){let m,f,y,{bits:d=7}=n,_=Math.pow(2,d)-1;const g=new Set;for(let q=2;q<=_/2;q++){let C=!0;g.forEach(function(P){q%P==0&&(C=!1)}),C&&g.add(q)}let E=39,I=E,v=7,k,V;function H(q){for(const C of g)if(g.has(q/C))return p(3,k=C),p(4,V=q/C),!0;return!1}H(E);function L(q,C){return{update(P){let J=P-I;if(J!=0){for(;!H(P);)if(P+=J,P<=2||P>=_)return;G(P)}}}}function G(q){p(0,E=q),I=E,p(1,v=v>=E?E-1:v)}function U(){v=ua(this.value),p(1,v)}function A(){v=ua(this.value),p(1,v)}function B(){E=ua(this.value),p(0,E)}return a.$$set=q=>{"bits"in q&&p(9,d=q.bits)},a.$$.update=()=>{a.$$.dirty&3&&p(2,m=Zo(v,E)),a.$$.dirty&3&&p(6,f=_n(E,v)),a.$$.dirty&6&&p(5,y=Math.pow(v,m/2))},[E,v,m,k,V,y,f,_,L,d,U,A,B]}class xo extends Ht{constructor(n){super(),qt(this,n,Yo,Jo,Lt,{bits:9})}}function el(a){const n=a-1;return n*n*n+1}function tl(a){return--a*a*a*a*a+1}function al(a,{delay:n=0,duration:p=400,easing:m=el,start:f=0,opacity:y=0}={}){const d=getComputedStyle(a),_=+d.opacity,g=d.transform==="none"?"":d.transform,E=1-f,I=_*(1-y);return{delay:n,duration:p,easing:m,css:(v,k)=>`
			transform: ${g} scale(${1-E*k});
			opacity: ${_-I*k}
		`}}function Us(a){let n,p;return{c(){n=o("div"),this.h()},l(m){n=l(m,"DIV",{class:!0});var f=i(n);f.forEach(t),this.h()},h(){fe(n,"class","hover-inner svelte-5qv8za")},m(m,f){w(m,n,f),n.innerHTML=a[0]},p(m,f){a=m,f&1&&(n.innerHTML=a[0])},i(m){p||Do(()=>{p=Uo(n,al,{duration:150,easing:tl,opacity:0}),p.start()})},o:at,d(m){m&&t(n)}}}function nl(a){let n,p,m,f;const y=a[5].default,d=Qo(y,a,a[4],null);let _=a[1]&&Us(a);return{c(){n=o("span"),d&&d.c(),_&&_.c(),this.h()},l(g){n=l(g,"SPAN",{class:!0});var E=i(n);d&&d.l(E),_&&_.l(E),E.forEach(t),this.h()},h(){fe(n,"class","hover-outer svelte-5qv8za")},m(g,E){w(g,n,E),d&&d.m(n,null),_&&_.m(n,null),p=!0,m||(f=[u(n,"mouseenter",a[2]),u(n,"mouseleave",a[3])],m=!0)},p(g,[E]){d&&d.p&&(!p||E&16)&&Co(d,y,g,g[4],p?jo(y,g[4],E,null):Wo(g[4]),null),g[1]?_?(_.p(g,E),E&2&&ze(_,1)):(_=Us(g),_.c(),ze(_,1),_.m(n,null)):_&&(_.d(1),_=null)},i(g){p||(ze(d,g),ze(_),p=!0)},o(g){Ge(d,g),p=!1},d(g){g&&t(n),d&&d.d(g),_&&_.d(),m=!1,Ut(f)}}}function sl(a,n,p){let{$$slots:m={},$$scope:f}=n,{hovertext:y}=n,d=!1;const _=()=>p(1,d=!0),g=()=>p(1,d=!1);return a.$$set=E=>{"hovertext"in E&&p(0,y=E.hovertext),"$$scope"in E&&p(4,f=E.$$scope)},[y,d,_,g,f,m]}class sn extends Ht{constructor(n){super(),qt(this,n,sl,nl,Lt,{hovertext:0})}}const rl=`<a href="https://en.wikipedia.org/wiki/Semiprime"><h3 class="text-lg font-semibold">Semiprime</h3></a><p>In mathematics, a <b>semiprime</b> is a natural number that is the product of exactly two prime numbers. The two primes in the product may equal each other, so the semiprimes include the squares of prime numbers.
Because there are infinitely many prime numbers, there are also infinitely many semiprimes. Semiprimes are also called <b>biprimes</b>.</p>`,ol='<a href="https://en.wikipedia.org/wiki/Computational_complexity"><h3 class="text-lg font-semibold">Computational complexity</h3></a><p>In computer science, the <b>computational complexity</b> or simply <b>complexity</b> of an algorithm is the amount of resources required to run it. Particular focus is given to time and memory requirements. The complexity of a problem is the complexity of the best algorithms that allow solving the problem.</p>';function ll(a){let n;return{c(){n=s("(semiprime)")},l(p){n=r(p,"(semiprime)")},m(p,m){w(p,n,m)},d(p){p&&t(n)}}}function il(a){let n;return{c(){n=s("Computational complexity")},l(p){n=r(p,"Computational complexity")},m(p,m){w(p,n,m)},d(p){p&&t(n)}}}function hl(a){let n,p,m,f,y,d=h("N")+"",_,g,E=h("N = p \\cdot q")+"",I,v,k=h("15")+"",V,H,L=h("3")+"",G,U,A=h("5")+"",B,q,C=h("62615533")+"",P,J,S,z,Z,W,x,$,M,T,O,X,Ne,K,F=h("^3")+"",we,c,N,de,te,ee,ye,he,re,ne,$e,ce,mt,qe,ve,pe,ke,Q,me,Le;return m=new sn({props:{hovertext:rl,$$slots:{default:[ll]},$$scope:{ctx:a}}}),de=new sn({props:{hovertext:ol,$$slots:{default:[il]},$$scope:{ctx:a}}}),{c(){n=o("p"),p=s("Take a large composite "),Ye(m.$$.fragment),f=s(" number "),y=o("span"),_=s(" we try to find factors for, so that "),g=o("span"),I=s(". Finding the prime factors of a small semiprime, such as "),v=o("span"),V=s(", is quite easy. In fact, you may figure it out just by looking at it and recalling your grade school studies: the factors are "),H=o("span"),G=s(" and "),U=o("span"),B=s(". But what are the prime factors of, say, "),q=o("span"),P=s("? It turns out that, using the best known "),J=o("em"),S=s("classical"),z=s(" algorithm (the so called "),Z=o("em"),W=s("number field sieve"),x=s("), solving the factoring problem scales "),$=o("em"),M=s("exponentially"),T=s(" with the number of digits of the semiprime that we want to factor. With the help of Shor's algorithm and a sufficiently large quantum computer, the same problem scales roughly "),O=o("em"),X=s("cubically"),Ne=s(" with the number of digits, meaning that the number of elementary operations required is proportional to (the number of digits)"),K=o("span"),we=s(". (In fact, the algorithm does slighly better than that, but the precise formula is a bit complicated and is beside the point.) To illustrate what this means in practical terms, imagine the following. If factoring a 100-digit number with Shor's algorithm on a quantum computer takes one second, factoring the same number with the number field sieve on a classical computer takes more than 3 hours. If we now try with a 200-digit number, Shor's algorithm finishes in roughly 5 seconds, while the classical solution would take more than a year!"),c=j(),N=o("p"),Ye(de.$$.fragment),te=s(" refers to how the time - or number of "),ee=o("em"),ye=s("elementary operations"),he=s(" - required to solve a given problem algorithmically grows with the size of the "),re=o("em"),ne=s("input"),$e=s(`. Let's say you have to find the longest book you have ever read. One way to approach this problem is to list the books you have read one by one, label the first one as the longest, and whenever you encounter an even longer book, it takes the place of the former. This way, you only have to keep track of the largest page number so far, and the book associated with it. The "elementary operation" in this case is checking the number of pages of the next book and comparing that with the previous maximum. If you have twice or three times as many books, this procedure requires twice or three times as many elementary operations. In other words, it grows `),ce=o("em"),mt=s("linearly"),qe=s(" in the number of books. So, while the solution can be found using the same algorithm, the number of elementary operations required to carry out that algorithm depends on the size of the input. This is true for almost all algorithms that are designed to solve mathematical problems. However, how "),ve=o("em"),pe=s("fast"),ke=s(" that growth is, makes all the difference between them.")},l(oe){n=l(oe,"P",{});var se=i(n);p=r(se,"Take a large composite "),xe(m.$$.fragment,se),f=r(se," number "),y=l(se,"SPAN",{});var Ie=i(y);Ie.forEach(t),_=r(se," we try to find factors for, so that "),g=l(se,"SPAN",{});var Te=i(g);Te.forEach(t),I=r(se,". Finding the prime factors of a small semiprime, such as "),v=l(se,"SPAN",{});var gt=i(v);gt.forEach(t),V=r(se,", is quite easy. In fact, you may figure it out just by looking at it and recalling your grade school studies: the factors are "),H=l(se,"SPAN",{});var Ue=i(H);Ue.forEach(t),G=r(se," and "),U=l(se,"SPAN",{});var Ve=i(U);Ve.forEach(t),B=r(se,". But what are the prime factors of, say, "),q=l(se,"SPAN",{});var Et=i(q);Et.forEach(t),P=r(se,"? It turns out that, using the best known "),J=l(se,"EM",{});var Qe=i(J);S=r(Qe,"classical"),Qe.forEach(t),z=r(se," algorithm (the so called "),Z=l(se,"EM",{});var Me=i(Z);W=r(Me,"number field sieve"),Me.forEach(t),x=r(se,"), solving the factoring problem scales "),$=l(se,"EM",{});var vt=i($);M=r(vt,"exponentially"),vt.forEach(t),T=r(se," with the number of digits of the semiprime that we want to factor. With the help of Shor's algorithm and a sufficiently large quantum computer, the same problem scales roughly "),O=l(se,"EM",{});var Ce=i(O);X=r(Ce,"cubically"),Ce.forEach(t),Ne=r(se," with the number of digits, meaning that the number of elementary operations required is proportional to (the number of digits)"),K=l(se,"SPAN",{});var Je=i(K);Je.forEach(t),we=r(se,". (In fact, the algorithm does slighly better than that, but the precise formula is a bit complicated and is beside the point.) To illustrate what this means in practical terms, imagine the following. If factoring a 100-digit number with Shor's algorithm on a quantum computer takes one second, factoring the same number with the number field sieve on a classical computer takes more than 3 hours. If we now try with a 200-digit number, Shor's algorithm finishes in roughly 5 seconds, while the classical solution would take more than a year!"),se.forEach(t),c=D(oe),N=l(oe,"P",{});var be=i(N);xe(de.$$.fragment,be),te=r(be," refers to how the time - or number of "),ee=l(be,"EM",{});var nt=i(ee);ye=r(nt,"elementary operations"),nt.forEach(t),he=r(be," - required to solve a given problem algorithmically grows with the size of the "),re=l(be,"EM",{});var Ke=i(re);ne=r(Ke,"input"),Ke.forEach(t),$e=r(be,`. Let's say you have to find the longest book you have ever read. One way to approach this problem is to list the books you have read one by one, label the first one as the longest, and whenever you encounter an even longer book, it takes the place of the former. This way, you only have to keep track of the largest page number so far, and the book associated with it. The "elementary operation" in this case is checking the number of pages of the next book and comparing that with the previous maximum. If you have twice or three times as many books, this procedure requires twice or three times as many elementary operations. In other words, it grows `),ce=l(be,"EM",{});var He=i(ce);mt=r(He,"linearly"),He.forEach(t),qe=r(be," in the number of books. So, while the solution can be found using the same algorithm, the number of elementary operations required to carry out that algorithm depends on the size of the input. This is true for almost all algorithms that are designed to solve mathematical problems. However, how "),ve=l(be,"EM",{});var st=i(ve);pe=r(st,"fast"),st.forEach(t),ke=r(be," that growth is, makes all the difference between them."),be.forEach(t)},m(oe,se){w(oe,n,se),e(n,p),et(m,n,null),e(n,f),e(n,y),y.innerHTML=d,e(n,_),e(n,g),g.innerHTML=E,e(n,I),e(n,v),v.innerHTML=k,e(n,V),e(n,H),H.innerHTML=L,e(n,G),e(n,U),U.innerHTML=A,e(n,B),e(n,q),q.innerHTML=C,e(n,P),e(n,J),e(J,S),e(n,z),e(n,Z),e(Z,W),e(n,x),e(n,$),e($,M),e(n,T),e(n,O),e(O,X),e(n,Ne),e(n,K),K.innerHTML=F,e(n,we),w(oe,c,se),w(oe,N,se),et(de,N,null),e(N,te),e(N,ee),e(ee,ye),e(N,he),e(N,re),e(re,ne),e(N,$e),e(N,ce),e(ce,mt),e(N,qe),e(N,ve),e(ve,pe),e(N,ke),Q=!0,me||(Le=[u(y,"mouseenter",a[0]),u(g,"mouseenter",a[1]),u(v,"mouseenter",a[2]),u(H,"mouseenter",a[3]),u(U,"mouseenter",a[4]),u(q,"mouseenter",a[5]),u(K,"mouseenter",a[6])],me=!0)},p(oe,[se]){const Ie={};se&128&&(Ie.$$scope={dirty:se,ctx:oe}),m.$set(Ie);const Te={};se&128&&(Te.$$scope={dirty:se,ctx:oe}),de.$set(Te)},i(oe){Q||(ze(m.$$.fragment,oe),ze(de.$$.fragment,oe),Q=!0)},o(oe){Ge(m.$$.fragment,oe),Ge(de.$$.fragment,oe),Q=!1},d(oe){oe&&t(n),tt(m),oe&&t(c),oe&&t(N),tt(de),me=!1,Ut(Le)}}}function fa(a){console.log(a)}function ul(a){return[()=>fa(["N"]),()=>fa(["p","q","N"]),()=>fa([]),()=>fa([]),()=>fa([]),()=>fa([]),()=>fa([])]}class ml extends Ht{constructor(n){super(),qt(this,n,ul,hl,Lt,{})}}function pl(a){let n,p,m,f=h("N")+"",y,d,_=h("a")+"",g,E,I=h("K = \\gcd(a, N) \\neq 1")+"",v,k,V=h("f(r) = a^r \\mod N")+"",H,L,G=h("r > 0")+"",U,A,B=h("f(r) = 1")+"",q,C,P=h("r")+"",J,S,z=h("a")+"",Z,W,x=h("r")+"",$,M,T=h("b = a^{\\frac{r}{2}}")+"",O,X,Ne=h("a^r \\mod N = 1")+"",K,F,we=h("m")+"",c,N,de=h("a^r = m \\cdot N + 1 \\Rightarrow b^2-1 = (b + 1)(b - 1) = m \\cdot N")+"",te,ee,ye=h("b+1")+"",he,re,ne=h("N")+"",$e,ce,mt=h("N")+"",qe,ve,pe;return{c(){n=o("p"),p=s("We can find the factors of "),m=o("span"),y=s(" by selecting "),d=o("span"),g=s(" in a way that the greatest common denominator "),E=o("span"),v=s(". We construct the function "),k=o("span"),H=s(" and we are searching for the value "),L=o("span"),U=s(" so that "),A=o("span"),q=s(". If "),C=o("span"),J=s(" is odd, we need to select a new "),S=o("span"),Z=s(", otherwise we proceed. With an even "),W=o("span"),$=s(", we can create an integer "),M=o("span"),O=s(". Also, due to "),X=o("span"),K=s(" we have a positive integer "),F=o("span"),c=s(" so that "),N=o("span"),te=s(". This way the greatest common denominator of "),ee=o("span"),he=s(" and "),re=o("span"),$e=s(" will be one of the factors of "),ce=o("span"),qe=s(".")},l(ke){n=l(ke,"P",{});var Q=i(n);p=r(Q,"We can find the factors of "),m=l(Q,"SPAN",{});var me=i(m);me.forEach(t),y=r(Q," by selecting "),d=l(Q,"SPAN",{});var Le=i(d);Le.forEach(t),g=r(Q," in a way that the greatest common denominator "),E=l(Q,"SPAN",{});var oe=i(E);oe.forEach(t),v=r(Q,". We construct the function "),k=l(Q,"SPAN",{});var se=i(k);se.forEach(t),H=r(Q," and we are searching for the value "),L=l(Q,"SPAN",{});var Ie=i(L);Ie.forEach(t),U=r(Q," so that "),A=l(Q,"SPAN",{});var Te=i(A);Te.forEach(t),q=r(Q,". If "),C=l(Q,"SPAN",{});var gt=i(C);gt.forEach(t),J=r(Q," is odd, we need to select a new "),S=l(Q,"SPAN",{});var Ue=i(S);Ue.forEach(t),Z=r(Q,", otherwise we proceed. With an even "),W=l(Q,"SPAN",{});var Ve=i(W);Ve.forEach(t),$=r(Q,", we can create an integer "),M=l(Q,"SPAN",{});var Et=i(M);Et.forEach(t),O=r(Q,". Also, due to "),X=l(Q,"SPAN",{});var Qe=i(X);Qe.forEach(t),K=r(Q," we have a positive integer "),F=l(Q,"SPAN",{});var Me=i(F);Me.forEach(t),c=r(Q," so that "),N=l(Q,"SPAN",{});var vt=i(N);vt.forEach(t),te=r(Q,". This way the greatest common denominator of "),ee=l(Q,"SPAN",{});var Ce=i(ee);Ce.forEach(t),he=r(Q," and "),re=l(Q,"SPAN",{});var Je=i(re);Je.forEach(t),$e=r(Q," will be one of the factors of "),ce=l(Q,"SPAN",{});var be=i(ce);be.forEach(t),qe=r(Q,"."),Q.forEach(t)},m(ke,Q){w(ke,n,Q),e(n,p),e(n,m),m.innerHTML=f,e(n,y),e(n,d),d.innerHTML=_,e(n,g),e(n,E),E.innerHTML=I,e(n,v),e(n,k),k.innerHTML=V,e(n,H),e(n,L),L.innerHTML=G,e(n,U),e(n,A),A.innerHTML=B,e(n,q),e(n,C),C.innerHTML=P,e(n,J),e(n,S),S.innerHTML=z,e(n,Z),e(n,W),W.innerHTML=x,e(n,$),e(n,M),M.innerHTML=T,e(n,O),e(n,X),X.innerHTML=Ne,e(n,K),e(n,F),F.innerHTML=we,e(n,c),e(n,N),N.innerHTML=de,e(n,te),e(n,ee),ee.innerHTML=ye,e(n,he),e(n,re),re.innerHTML=ne,e(n,$e),e(n,ce),ce.innerHTML=mt,e(n,qe),ve||(pe=[u(m,"mouseenter",a[0]),u(d,"mouseenter",a[1]),u(E,"mouseenter",a[2]),u(k,"mouseenter",a[3]),u(L,"mouseenter",a[4]),u(A,"mouseenter",a[5]),u(C,"mouseenter",a[6]),u(S,"mouseenter",a[7]),u(W,"mouseenter",a[8]),u(M,"mouseenter",a[9]),u(X,"mouseenter",a[10]),u(F,"mouseenter",a[11]),u(N,"mouseenter",a[12]),u(ee,"mouseenter",a[13]),u(re,"mouseenter",a[14]),u(ce,"mouseenter",a[15])],ve=!0)},p:at,i:at,o:at,d(ke){ke&&t(n),ve=!1,Ut(pe)}}}function St(a){console.log(a)}function fl(a){return[()=>St(["N"]),()=>St(["a"]),()=>St(["a","K","N"]),()=>St(["r","a","N","f"]),()=>St(["r"]),()=>St(["r","f"]),()=>St(["r"]),()=>St(["a"]),()=>St(["r"]),()=>St(["r","a","b"]),()=>St(["r","a","N"]),()=>St(["m"]),()=>St(["r","a","b","m","N"]),()=>St(["b"]),()=>St(["N"]),()=>St(["N"])]}class _l extends Ht{constructor(n){super(),qt(this,n,fl,pl,Lt,{})}}function dl(a){let n,p,m,f,y,d,_,g,E,I;return f=new ml({}),d=new _l({}),E=new xo({}),{c(){n=o("h2"),p=s("Factoring"),m=j(),Ye(f.$$.fragment),y=j(),Ye(d.$$.fragment),_=j(),g=o("div"),Ye(E.$$.fragment),this.h()},l(v){n=l(v,"H2",{});var k=i(n);p=r(k,"Factoring"),k.forEach(t),m=D(v),xe(f.$$.fragment,v),y=D(v),xe(d.$$.fragment,v),_=D(v),g=l(v,"DIV",{class:!0});var V=i(g);xe(E.$$.fragment,V),V.forEach(t),this.h()},h(){fe(g,"class","interaction")},m(v,k){w(v,n,k),e(n,p),w(v,m,k),et(f,v,k),w(v,y,k),et(d,v,k),w(v,_,k),w(v,g,k),et(E,g,null),I=!0},p:at,i(v){I||(ze(f.$$.fragment,v),ze(d.$$.fragment,v),ze(E.$$.fragment,v),I=!0)},o(v){Ge(f.$$.fragment,v),Ge(d.$$.fragment,v),Ge(E.$$.fragment,v),I=!1},d(v){v&&t(n),v&&t(m),tt(f,v),v&&t(y),tt(d,v),v&&t(_),v&&t(g),tt(E)}}}class cl extends Ht{constructor(n){super(),qt(this,n,null,dl,Lt,{})}}function vl(a){let n,p,m,f=h("f")+"",y,d,_=h("\\Large \\hat{f}(\\xi) = \\int_{-\\infty}^{\\infty}{ f(x) \\cdot e^{-2 \\pi i x \\xi} dx}")+"",g,E,I,v,k,V=h("\\large x_0, \\ldots, x_{N - 1}")+"",H,L,G,U,A,B=h("\\large X_k = \\sum_{n=1}^{N - 1}{x_n \\cdot e^{-2 \\pi i \\frac{k}{N} n}}")+"",q,C,P,J,S,z=h("\\large f(x) = \\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d\\xi")+"",Z,W,x,$,M,T=h("\\large x_n = \\frac{1}{N} \\sum_{k=1}^{N - 1} X_k \\cdot e^{2 \\pi i \\frac{n}{N} k}")+"",O,X,Ne;return{c(){n=o("p"),p=s("The Fourier transform of a function "),m=o("span"),y=s(" is defined as: "),d=o("span"),g=s("."),E=j(),I=o("p"),v=s("Let "),k=o("span"),H=s(" be a sequence of complex numbers."),L=j(),G=o("p"),U=s("The discrete Fourier transform of that sequence is another sequence defined by the following formula: "),A=o("span"),q=s("."),C=j(),P=o("p"),J=s("We obtain original function by applying the inverse Fourier transform: "),S=o("span"),Z=s("."),W=j(),x=o("p"),$=s(`Analogously, we can obtain the original sequence with the help of the inverse discrete Fourier transform: 
`),M=o("span"),O=s(".")},l(K){n=l(K,"P",{});var F=i(n);p=r(F,"The Fourier transform of a function "),m=l(F,"SPAN",{});var we=i(m);we.forEach(t),y=r(F," is defined as: "),d=l(F,"SPAN",{});var c=i(d);c.forEach(t),g=r(F,"."),F.forEach(t),E=D(K),I=l(K,"P",{});var N=i(I);v=r(N,"Let "),k=l(N,"SPAN",{});var de=i(k);de.forEach(t),H=r(N," be a sequence of complex numbers."),N.forEach(t),L=D(K),G=l(K,"P",{});var te=i(G);U=r(te,"The discrete Fourier transform of that sequence is another sequence defined by the following formula: "),A=l(te,"SPAN",{});var ee=i(A);ee.forEach(t),q=r(te,"."),te.forEach(t),C=D(K),P=l(K,"P",{});var ye=i(P);J=r(ye,"We obtain original function by applying the inverse Fourier transform: "),S=l(ye,"SPAN",{});var he=i(S);he.forEach(t),Z=r(ye,"."),ye.forEach(t),W=D(K),x=l(K,"P",{});var re=i(x);$=r(re,`Analogously, we can obtain the original sequence with the help of the inverse discrete Fourier transform: 
`),M=l(re,"SPAN",{});var ne=i(M);ne.forEach(t),O=r(re,"."),re.forEach(t)},m(K,F){w(K,n,F),e(n,p),e(n,m),m.innerHTML=f,e(n,y),e(n,d),d.innerHTML=_,e(n,g),w(K,E,F),w(K,I,F),e(I,v),e(I,k),k.innerHTML=V,e(I,H),w(K,L,F),w(K,G,F),e(G,U),e(G,A),A.innerHTML=B,e(G,q),w(K,C,F),w(K,P,F),e(P,J),e(P,S),S.innerHTML=z,e(P,Z),w(K,W,F),w(K,x,F),e(x,$),e(x,M),M.innerHTML=T,e(x,O),X||(Ne=[u(m,"mouseenter",a[0]),u(d,"mouseenter",a[1]),u(k,"mouseenter",a[2]),u(A,"mouseenter",a[3]),u(S,"mouseenter",a[4]),u(M,"mouseenter",a[5])],X=!0)},p:at,i:at,o:at,d(K){K&&t(n),K&&t(E),K&&t(I),K&&t(L),K&&t(G),K&&t(C),K&&t(P),K&&t(W),K&&t(x),X=!1,Ut(Ne)}}}function nn(a){console.log(a)}function bl(a){return[()=>nn(["f"]),()=>nn(["\\xi","d","x","f"]),()=>nn(["x","N"]),()=>nn(["n","X","x","N","k"]),()=>nn(["x","\\xi","d","f"]),()=>nn(["n","X","x","N","k"])]}class wl extends Ht{constructor(n){super(),qt(this,n,bl,vl,Lt,{})}}function yl(a){let n,p,m,f,y,d,_,g,E,I=h("10")+"",v,k,V=h("0, 1, 2, 3, 4, 5, 6, 7, 8, 9")+"",H,L,G=h("325")+"",U,A,B=h("2")+"",q,C,P=h("2 \\cdot 10")+"",J,S,z=h("2847")+"",Z,W,x=h("2 \\cdot 1000")+"",$,M,T=h("n")+"",O,X,Ne=h("\\displaystyle{\\sum_{k = 1}^{n} d_k \\cdot 10^{n - k}}")+"",K,F,we=h("d_k")+"",c,N,de=h("k")+"",te,ee,ye=h("2847 = 2 \\cdot 10^3 + 8 \\cdot 10^2 + 4 \\cdot 10^1 + 7 \\cdot 10^0 = 2 \\cdot 1000 + 8 \\cdot 100 + 4 \\cdot 10 + 7 \\cdot 1")+"",he,re,ne,$e,ce,mt=h("2")+"",qe,ve,pe=h("0")+"",ke,Q,me=h("1")+"",Le,oe,se=h("\\displaystyle{\\sum_{k = 1}^{n} d_k \\cdot 2^{n - k}}")+"",Ie,Te,gt=h("d_k")+"",Ue,Ve,Et=h("k")+"",Qe,Me,vt=h("1011 = 1 \\cdot 2^3 + 0 \\cdot 2^2 + 1 \\cdot 2^1 + 1 \\cdot 2^0 = 1 \\cdot 8 + 0 \\cdot 4 + 1 \\cdot 2 + 1 \\cdot 1 = 11")+"",Ce,Je,be,nt,Ke,He,st,rt,Ct=h("n")+"",ft,Ze,Gt=h("|0\\rangle")+"",_t,lt,Wt=h("|1\\rangle")+"",Nt,_e,Re=h("\\underbrace{2 \\cdot \\ldots \\cdot 2}_\\text{n times} = 2^n")+"",bt,Oe,jt=h("N := 2^n")+"",Y,Pe,ue,At,it,ma=h("0")+"",pt,wt,xt=h("N - 1")+"",ot,ae,Jt=h("n = 5")+"",Dt,kt,Kt=h("|0\\rangle \\otimes |1\\rangle \\otimes |0\\rangle \\otimes |0\\rangle \\otimes |1\\rangle")+"",le,Xe,dt=h("01001")+"",Zt,Ft,ea=h("0 \\cdot 2^4 + 1 \\cdot 2^3 + 0 \\cdot 2^2 + 0 \\cdot 2^1 + 1 \\cdot 2^0 = 0 + 8 + 0 + 0 + 1 = 9")+"",$t,Rt,ge,Yt,ta,We,aa,na,kn=h("x")+"",rn,sa,Mn=h("x = 9")+"",on,Ee,Hn=h("k")+"",da,ra,qn=h("\\frac{1}{\\sqrt{2}} \\left( |0\\rangle + e^{\\frac{2 \\pi i x}{2^k}} |1\\rangle \\right)")+"",ln,oa,Ln=h("\\alpha_k = \\frac{1}{\\sqrt{2}}")+"",hn,la,In=h("\\beta_k = \\frac{1}{\\sqrt{2}} e^{\\frac{2 \\pi i x}{2^k}}")+"",ca,Mt,Vn=h("k = 1, ..., n")+"",un,pa,It,Fn,va,Ks=h("\\alpha_k \\neq \\beta_k")+"",Bn,ba,Rs=h("\\Vert{\\alpha_k}\\Vert^2 = \\Vert{\\beta_k}\\Vert^2 = \\frac{1}{2}")+"",zn,wa,Os=h("k = 1, ..., n")+"",Qn,ya,Xs=h("e^{\\frac{2 \\pi i x}{2^k}}")+"",Cn,dn,je,Wn,ga,Gs=h("|0\\rangle")+"",jn,Ea,Js=h("|1\\rangle")+"",Dn,Na,Zs=h("n")+"",Un,$a,Ys=h("n")+"",Kn,Ta,xs=h("0")+"",Rn,Pa,er=h("N - 1")+"",On,Sa,tr=h("\\frac{1}{2}")+"",Xn,Aa,ar=h("n")+"",Gn,ka,nr=h("\\underbrace{\\frac{1}{2} \\cdot \\ldots \\cdot \\frac{1}{2}}_\\text{n terms} = \\frac{1}{2^n} = \\frac{1}{N}")+"",Jn,cn,Ma,Zn,vn,Ha,Yn,bn,qa,La,sr=h("\\underbrace{ \\frac{1}{\\sqrt{2}} \\left( |0\\rangle + e^{ \\frac{2 \\pi i x}{2^1} } |1\\rangle \\right) \\otimes \\ldots \\otimes \\frac{1}{\\sqrt{2}} \\left( |0\\rangle + e^{ \\frac{2 \\pi i x}{2^n} } |1\\rangle \\right) }_\\text{n terms}")+"",wn,ia,xn,Ia,rr=h("\\frac{1}{\\sqrt{2}}")+"",es,yn,Va,Fa,or=h("\\frac{1}{\\sqrt{2^n}} \\left(\\left( |0\\rangle + e^{\\frac{2 \\pi i x}{2^1}} |1\\rangle \\right) \\otimes \\ldots \\otimes \\left( |0\\rangle + e^{\\frac{2 \\pi i x}{2^n}} |1\\rangle \\right) \\right) = \\frac{1}{\\sqrt{N}} \\left(\\left( |0\\rangle + e^{\\frac{2 \\pi i x}{2^1}} |1\\rangle \\right) \\otimes \\ldots \\otimes \\left( |0\\rangle + e^{\\frac{2 \\pi i x}{2^n}} |1\\rangle \\right) \\right)")+"",gn,De,ts,Ba,lr=h("y_k")+"",as,za,ir=h("k")+"",ns,Qa,hr=h("n")+"",ss,Ca,ur=h("y_k = 0")+"",rs,Wa,mr=h("k")+"",os,ja,pr=h("|0\\rangle")+"",ls,Da,fr=h("y_k = 1")+"",is,Ua,_r=h("|1\\rangle")+"",hs,Ka,dr=h("k = 1, \\ldots, n")+"",us,En,Ra,Oa,cr=h("{\\displaystyle \\frac{1}{\\sqrt{N}} \\underbrace{ \\sum_{y_1=0}^1 \\ldots \\sum_{y_{n}=0}^1}_\\text{n terms} \\overbrace{e^{2 \\pi i x \\frac{y_1}{2^1}} |y_1\\rangle \\otimes \\ldots \\otimes e^{2 \\pi i x \\frac{y_n}{2^n}}|y_n\\rangle}^\\text{n terms} }")+"",Nn,Bt,ms,mn,ps,fs,pn,_s,ds,fn,cs,vs,$n,Xa,Ga,vr=h("\\displaystyle \\frac{1}{\\sqrt{N}} \\sum_{y_1=0}^1 \\ldots \\sum_{y_{n}=0}^1 \\left( e^{2 \\pi i x \\frac{y_1}{2^1}} \\cdot \\ldots \\cdot e^{2 \\pi i x \\frac{y_n}{2^n}} \\right) \\left( |y_1\\rangle \\otimes \\ldots \\otimes |y_n\\rangle \\right) =")+"",Tn,Ja,Za,br=h("\\displaystyle = \\frac{1}{\\sqrt{N}} \\sum_{y_1=0}^1 \\ldots \\sum_{y_{n}=0}^1 \\prod_{k=1}^n e^{2 \\pi i x \\frac{y_k}{2^k}} \\left( |y_1\\rangle \\otimes \\ldots \\otimes |y_n\\rangle \\right) =")+"",Pn,Ya,xa,wr=h("\\displaystyle = \\frac{1}{\\sqrt{N}} \\sum_{y_1=0}^1 \\ldots \\sum_{y_{n}=0}^1 e^{2 \\pi i x \\sum_{k=1}^n \\frac{y_k}{2^k}} \\left( |y_1\\rangle \\otimes \\ldots \\otimes |y_n\\rangle \\right)")+"",Sn,Ot,bs,en,yr=h("y_k = 0")+"",ws,tn,gr=h("e^{2 \\pi i x \\frac{y_k}{2^k}} = e^{2 \\pi i x \\frac{0}{2^k}} = e^0 = 1")+"",ys,gs,Ts;return{c(){n=o("h1"),p=s("Quantum Fourier transform"),m=j(),f=o("h2"),y=s("Binary number system"),d=j(),_=o("p"),g=s("In the decimal number system, there are "),E=o("span"),v=s(" distinct symbols used to represent numbers: "),k=o("span"),H=s(". The value of these symbols depends on their place in a given number. For example, in the number "),L=o("span"),U=s(", the symbol "),A=o("span"),q=s(" stands for "),C=o("span"),J=s(", whereas in the number "),S=o("span"),Z=s(", it represents "),W=o("span"),$=s(". In general, an integer in decimal notation with "),M=o("span"),O=s(" digits equals "),X=o("span"),K=s(", where "),F=o("span"),c=s(" is the "),N=o("span"),te=s("-th digit (going from left to right). To illustrate this with a concrete example, the number above "),ee=o("span"),he=s("."),re=j(),ne=o("p"),$e=s("Analogously, in the binary number system, there are "),ce=o("span"),qe=s(" distinct symbols used to represent numbers: "),ve=o("span"),ke=s(" and "),Q=o("span"),Le=s(". The value of an integer in binary notation equals to "),oe=o("span"),Ie=s(", where "),Te=o("span"),Ue=s(" is the "),Ve=o("span"),Qe=s("-th (binary) digit. For instance, the binary number "),Me=o("span"),Ce=s("."),Je=j(),be=o("h2"),nt=s("Representing numbers with qubits"),Ke=j(),He=o("p"),st=s("Consider "),rt=o("span"),ft=s(" qubits aranged in a row, each of which are in either of the two basis states "),Ze=o("span"),_t=s(" or "),lt=o("span"),Nt=s(". With a little combinatorics, we can see that there are "),_e=o("span"),bt=s(" such combinations. For ease of notation, let "),Oe=o("span"),Y=s("."),Pe=j(),ue=o("p"),At=s("For our purposes, we'll interpret these combinations as the binary representations of the numbers from "),it=o("span"),pt=s(" to "),wt=o("span"),ot=s(". For example, let "),ae=o("span"),Dt=s(" and the qubits be in the following state: "),kt=o("span"),le=s('. We can "read out" this state as the binary number '),Xe=o("span"),Zt=s(", which - as we saw above - is equal to "),Ft=o("span"),$t=s("."),Rt=j(),ge=o("h2"),Yt=s("QFT on the qubit level"),ta=j(),We=o("p"),aa=s("The quantum Fourier transform is an operation that modifies the states of qubits in a particular way. (How this is done in practice is another topic, for now we'll only look at the mathematics.) Namely, if "),na=o("span"),rn=s(" is the number represented by the qubits (in the example above, "),sa=o("span"),on=s("), the QFT sets the state of the "),Ee=o("span"),da=s("-th qubit to "),ra=o("span"),ln=s(". In other words, it sets "),oa=o("span"),hn=s(" and "),la=o("span"),ca=s(" for all "),Mt=o("span"),un=s("."),pa=j(),It=o("p"),Fn=s("Notice that even though "),va=o("span"),Bn=s(", the associated measurement probabilities "),ba=o("span"),zn=s(" for all "),wa=o("span"),Qn=s(". This is because the "),ya=o("span"),Cn=s(" term - as we saw in section 2.3 - indicates the qubit's phase and does not affect measurement probabilities."),dn=j(),je=o("p"),Wn=s("Just like the state of a single qubit can be the linear combination of "),ga=o("span"),jn=s(" and "),Ea=o("span"),Dn=s(", the joint state of these "),Na=o("span"),Un=s(" qubits is essentially the linear combination of all the possible combinations of the "),$a=o("span"),Kn=s(" basis states - which, as we saw in the previous section, represent the integers from "),Ta=o("span"),Rn=s(" to "),Pa=o("span"),On=s(". Since both basis states are measured with a probability of "),Sa=o("span"),Xn=s(" for each qubit, one particular combination of the "),Aa=o("span"),Gn=s(" basis states is measured with a probability of "),ka=o("span"),Jn=s(". What differs across these combinations are the phase, as we'll see in the next section."),cn=j(),Ma=o("h2"),Zn=s("QFT on the representation level"),vn=j(),Ha=o("p"),Yn=s("Next, let's write out the joint state of the qubits:"),bn=j(),qa=o("p"),La=o("span"),wn=j(),ia=o("p"),xn=s("We can factor out the "),Ia=o("span"),es=s(" term to get:"),yn=j(),Va=o("p"),Fa=o("span"),gn=j(),De=o("p"),ts=s("Let "),Ba=o("span"),as=s(" denote the "),za=o("span"),ns=s("-th digit of the binary number represented by the "),Qa=o("span"),ss=s(" qubits in a given basis state. In other words, "),Ca=o("span"),rs=s(" if the "),Wa=o("span"),os=s("-th qubit is in the "),ja=o("span"),ls=s(" state, and "),Da=o("span"),is=s(" if it's in the "),Ua=o("span"),hs=s(" state for all "),Ka=o("span"),us=s(". Using this notation, we can write the expression above in the form of a sum instead of a product:"),En=j(),Ra=o("p"),Oa=o("span"),Nn=j(),Bt=o("p"),ms=s("The formula above includes all possible combinations of basis states with "),mn=o("em"),ps=s("equal weight"),fs=s(", but "),pn=o("em"),_s=s("different phases"),ds=s(". Let's define the "),fn=o("em"),cs=s("phase of the combination"),vs=s(" as the product of the phases of individual qubits within that combination. We can then factor out this phase as we iterate over the combinations:"),$n=j(),Xa=o("p"),Ga=o("span"),Tn=j(),Ja=o("p"),Za=o("span"),Pn=j(),Ya=o("p"),xa=o("span"),Sn=j(),Ot=o("p"),bs=s("Notice that if "),en=o("span"),ws=s(", the exponential term can be simplified the following way: "),tn=o("span"),ys=s(".")},l(b){n=l(b,"H1",{});var ie=i(n);p=r(ie,"Quantum Fourier transform"),ie.forEach(t),m=D(b),f=l(b,"H2",{});var Ps=i(f);y=r(Ps,"Binary number system"),Ps.forEach(t),d=D(b),_=l(b,"P",{});var Fe=i(_);g=r(Fe,"In the decimal number system, there are "),E=l(Fe,"SPAN",{});var Er=i(E);Er.forEach(t),v=r(Fe," distinct symbols used to represent numbers: "),k=l(Fe,"SPAN",{});var Nr=i(k);Nr.forEach(t),H=r(Fe,". The value of these symbols depends on their place in a given number. For example, in the number "),L=l(Fe,"SPAN",{});var $r=i(L);$r.forEach(t),U=r(Fe,", the symbol "),A=l(Fe,"SPAN",{});var Tr=i(A);Tr.forEach(t),q=r(Fe," stands for "),C=l(Fe,"SPAN",{});var Pr=i(C);Pr.forEach(t),J=r(Fe,", whereas in the number "),S=l(Fe,"SPAN",{});var Sr=i(S);Sr.forEach(t),Z=r(Fe,", it represents "),W=l(Fe,"SPAN",{});var Ar=i(W);Ar.forEach(t),$=r(Fe,". In general, an integer in decimal notation with "),M=l(Fe,"SPAN",{});var kr=i(M);kr.forEach(t),O=r(Fe," digits equals "),X=l(Fe,"SPAN",{});var Mr=i(X);Mr.forEach(t),K=r(Fe,", where "),F=l(Fe,"SPAN",{});var Hr=i(F);Hr.forEach(t),c=r(Fe," is the "),N=l(Fe,"SPAN",{});var qr=i(N);qr.forEach(t),te=r(Fe,"-th digit (going from left to right). To illustrate this with a concrete example, the number above "),ee=l(Fe,"SPAN",{});var Lr=i(ee);Lr.forEach(t),he=r(Fe,"."),Fe.forEach(t),re=D(b),ne=l(b,"P",{});var Tt=i(ne);$e=r(Tt,"Analogously, in the binary number system, there are "),ce=l(Tt,"SPAN",{});var Ir=i(ce);Ir.forEach(t),qe=r(Tt," distinct symbols used to represent numbers: "),ve=l(Tt,"SPAN",{});var Vr=i(ve);Vr.forEach(t),ke=r(Tt," and "),Q=l(Tt,"SPAN",{});var Fr=i(Q);Fr.forEach(t),Le=r(Tt,". The value of an integer in binary notation equals to "),oe=l(Tt,"SPAN",{});var Br=i(oe);Br.forEach(t),Ie=r(Tt,", where "),Te=l(Tt,"SPAN",{});var zr=i(Te);zr.forEach(t),Ue=r(Tt," is the "),Ve=l(Tt,"SPAN",{});var Qr=i(Ve);Qr.forEach(t),Qe=r(Tt,"-th (binary) digit. For instance, the binary number "),Me=l(Tt,"SPAN",{});var Cr=i(Me);Cr.forEach(t),Ce=r(Tt,"."),Tt.forEach(t),Je=D(b),be=l(b,"H2",{});var Ss=i(be);nt=r(Ss,"Representing numbers with qubits"),Ss.forEach(t),Ke=D(b),He=l(b,"P",{});var zt=i(He);st=r(zt,"Consider "),rt=l(zt,"SPAN",{});var Wr=i(rt);Wr.forEach(t),ft=r(zt," qubits aranged in a row, each of which are in either of the two basis states "),Ze=l(zt,"SPAN",{});var jr=i(Ze);jr.forEach(t),_t=r(zt," or "),lt=l(zt,"SPAN",{});var Dr=i(lt);Dr.forEach(t),Nt=r(zt,". With a little combinatorics, we can see that there are "),_e=l(zt,"SPAN",{});var Ur=i(_e);Ur.forEach(t),bt=r(zt," such combinations. For ease of notation, let "),Oe=l(zt,"SPAN",{});var Kr=i(Oe);Kr.forEach(t),Y=r(zt,"."),zt.forEach(t),Pe=D(b),ue=l(b,"P",{});var Vt=i(ue);At=r(Vt,"For our purposes, we'll interpret these combinations as the binary representations of the numbers from "),it=l(Vt,"SPAN",{});var Rr=i(it);Rr.forEach(t),pt=r(Vt," to "),wt=l(Vt,"SPAN",{});var Or=i(wt);Or.forEach(t),ot=r(Vt,". For example, let "),ae=l(Vt,"SPAN",{});var Xr=i(ae);Xr.forEach(t),Dt=r(Vt," and the qubits be in the following state: "),kt=l(Vt,"SPAN",{});var Gr=i(kt);Gr.forEach(t),le=r(Vt,'. We can "read out" this state as the binary number '),Xe=l(Vt,"SPAN",{});var Jr=i(Xe);Jr.forEach(t),Zt=r(Vt,", which - as we saw above - is equal to "),Ft=l(Vt,"SPAN",{});var Zr=i(Ft);Zr.forEach(t),$t=r(Vt,"."),Vt.forEach(t),Rt=D(b),ge=l(b,"H2",{});var As=i(ge);Yt=r(As,"QFT on the qubit level"),As.forEach(t),ta=D(b),We=l(b,"P",{});var Pt=i(We);aa=r(Pt,"The quantum Fourier transform is an operation that modifies the states of qubits in a particular way. (How this is done in practice is another topic, for now we'll only look at the mathematics.) Namely, if "),na=l(Pt,"SPAN",{});var Yr=i(na);Yr.forEach(t),rn=r(Pt," is the number represented by the qubits (in the example above, "),sa=l(Pt,"SPAN",{});var xr=i(sa);xr.forEach(t),on=r(Pt,"), the QFT sets the state of the "),Ee=l(Pt,"SPAN",{});var eo=i(Ee);eo.forEach(t),da=r(Pt,"-th qubit to "),ra=l(Pt,"SPAN",{});var to=i(ra);to.forEach(t),ln=r(Pt,". In other words, it sets "),oa=l(Pt,"SPAN",{});var ao=i(oa);ao.forEach(t),hn=r(Pt," and "),la=l(Pt,"SPAN",{});var no=i(la);no.forEach(t),ca=r(Pt," for all "),Mt=l(Pt,"SPAN",{});var so=i(Mt);so.forEach(t),un=r(Pt,"."),Pt.forEach(t),pa=D(b),It=l(b,"P",{});var Xt=i(It);Fn=r(Xt,"Notice that even though "),va=l(Xt,"SPAN",{});var ro=i(va);ro.forEach(t),Bn=r(Xt,", the associated measurement probabilities "),ba=l(Xt,"SPAN",{});var oo=i(ba);oo.forEach(t),zn=r(Xt," for all "),wa=l(Xt,"SPAN",{});var lo=i(wa);lo.forEach(t),Qn=r(Xt,". This is because the "),ya=l(Xt,"SPAN",{});var io=i(ya);io.forEach(t),Cn=r(Xt," term - as we saw in section 2.3 - indicates the qubit's phase and does not affect measurement probabilities."),Xt.forEach(t),dn=D(b),je=l(b,"P",{});var ht=i(je);Wn=r(ht,"Just like the state of a single qubit can be the linear combination of "),ga=l(ht,"SPAN",{});var ho=i(ga);ho.forEach(t),jn=r(ht," and "),Ea=l(ht,"SPAN",{});var uo=i(Ea);uo.forEach(t),Dn=r(ht,", the joint state of these "),Na=l(ht,"SPAN",{});var mo=i(Na);mo.forEach(t),Un=r(ht," qubits is essentially the linear combination of all the possible combinations of the "),$a=l(ht,"SPAN",{});var po=i($a);po.forEach(t),Kn=r(ht," basis states - which, as we saw in the previous section, represent the integers from "),Ta=l(ht,"SPAN",{});var fo=i(Ta);fo.forEach(t),Rn=r(ht," to "),Pa=l(ht,"SPAN",{});var _o=i(Pa);_o.forEach(t),On=r(ht,". Since both basis states are measured with a probability of "),Sa=l(ht,"SPAN",{});var co=i(Sa);co.forEach(t),Xn=r(ht," for each qubit, one particular combination of the "),Aa=l(ht,"SPAN",{});var vo=i(Aa);vo.forEach(t),Gn=r(ht," basis states is measured with a probability of "),ka=l(ht,"SPAN",{});var bo=i(ka);bo.forEach(t),Jn=r(ht,". What differs across these combinations are the phase, as we'll see in the next section."),ht.forEach(t),cn=D(b),Ma=l(b,"H2",{});var ks=i(Ma);Zn=r(ks,"QFT on the representation level"),ks.forEach(t),vn=D(b),Ha=l(b,"P",{});var Ms=i(Ha);Yn=r(Ms,"Next, let's write out the joint state of the qubits:"),Ms.forEach(t),bn=D(b),qa=l(b,"P",{});var Hs=i(qa);La=l(Hs,"SPAN",{});var wo=i(La);wo.forEach(t),Hs.forEach(t),wn=D(b),ia=l(b,"P",{});var An=i(ia);xn=r(An,"We can factor out the "),Ia=l(An,"SPAN",{});var yo=i(Ia);yo.forEach(t),es=r(An," term to get:"),An.forEach(t),yn=D(b),Va=l(b,"P",{});var qs=i(Va);Fa=l(qs,"SPAN",{});var go=i(Fa);go.forEach(t),qs.forEach(t),gn=D(b),De=l(b,"P",{});var ut=i(De);ts=r(ut,"Let "),Ba=l(ut,"SPAN",{});var Eo=i(Ba);Eo.forEach(t),as=r(ut," denote the "),za=l(ut,"SPAN",{});var No=i(za);No.forEach(t),ns=r(ut,"-th digit of the binary number represented by the "),Qa=l(ut,"SPAN",{});var $o=i(Qa);$o.forEach(t),ss=r(ut," qubits in a given basis state. In other words, "),Ca=l(ut,"SPAN",{});var To=i(Ca);To.forEach(t),rs=r(ut," if the "),Wa=l(ut,"SPAN",{});var Po=i(Wa);Po.forEach(t),os=r(ut,"-th qubit is in the "),ja=l(ut,"SPAN",{});var So=i(ja);So.forEach(t),ls=r(ut," state, and "),Da=l(ut,"SPAN",{});var Ao=i(Da);Ao.forEach(t),is=r(ut," if it's in the "),Ua=l(ut,"SPAN",{});var ko=i(Ua);ko.forEach(t),hs=r(ut," state for all "),Ka=l(ut,"SPAN",{});var Mo=i(Ka);Mo.forEach(t),us=r(ut,". Using this notation, we can write the expression above in the form of a sum instead of a product:"),ut.forEach(t),En=D(b),Ra=l(b,"P",{});var Ls=i(Ra);Oa=l(Ls,"SPAN",{});var Ho=i(Oa);Ho.forEach(t),Ls.forEach(t),Nn=D(b),Bt=l(b,"P",{});var ha=i(Bt);ms=r(ha,"The formula above includes all possible combinations of basis states with "),mn=l(ha,"EM",{});var Is=i(mn);ps=r(Is,"equal weight"),Is.forEach(t),fs=r(ha,", but "),pn=l(ha,"EM",{});var Vs=i(pn);_s=r(Vs,"different phases"),Vs.forEach(t),ds=r(ha,". Let's define the "),fn=l(ha,"EM",{});var Fs=i(fn);cs=r(Fs,"phase of the combination"),Fs.forEach(t),vs=r(ha," as the product of the phases of individual qubits within that combination. We can then factor out this phase as we iterate over the combinations:"),ha.forEach(t),$n=D(b),Xa=l(b,"P",{});var Bs=i(Xa);Ga=l(Bs,"SPAN",{});var qo=i(Ga);qo.forEach(t),Bs.forEach(t),Tn=D(b),Ja=l(b,"P",{});var zs=i(Ja);Za=l(zs,"SPAN",{});var Lo=i(Za);Lo.forEach(t),zs.forEach(t),Pn=D(b),Ya=l(b,"P",{});var Qs=i(Ya);xa=l(Qs,"SPAN",{});var Io=i(xa);Io.forEach(t),Qs.forEach(t),Sn=D(b),Ot=l(b,"P",{});var an=i(Ot);bs=r(an,"Notice that if "),en=l(an,"SPAN",{});var Vo=i(en);Vo.forEach(t),ws=r(an,", the exponential term can be simplified the following way: "),tn=l(an,"SPAN",{});var Fo=i(tn);Fo.forEach(t),ys=r(an,"."),an.forEach(t)},m(b,ie){w(b,n,ie),e(n,p),w(b,m,ie),w(b,f,ie),e(f,y),w(b,d,ie),w(b,_,ie),e(_,g),e(_,E),E.innerHTML=I,e(_,v),e(_,k),k.innerHTML=V,e(_,H),e(_,L),L.innerHTML=G,e(_,U),e(_,A),A.innerHTML=B,e(_,q),e(_,C),C.innerHTML=P,e(_,J),e(_,S),S.innerHTML=z,e(_,Z),e(_,W),W.innerHTML=x,e(_,$),e(_,M),M.innerHTML=T,e(_,O),e(_,X),X.innerHTML=Ne,e(_,K),e(_,F),F.innerHTML=we,e(_,c),e(_,N),N.innerHTML=de,e(_,te),e(_,ee),ee.innerHTML=ye,e(_,he),w(b,re,ie),w(b,ne,ie),e(ne,$e),e(ne,ce),ce.innerHTML=mt,e(ne,qe),e(ne,ve),ve.innerHTML=pe,e(ne,ke),e(ne,Q),Q.innerHTML=me,e(ne,Le),e(ne,oe),oe.innerHTML=se,e(ne,Ie),e(ne,Te),Te.innerHTML=gt,e(ne,Ue),e(ne,Ve),Ve.innerHTML=Et,e(ne,Qe),e(ne,Me),Me.innerHTML=vt,e(ne,Ce),w(b,Je,ie),w(b,be,ie),e(be,nt),w(b,Ke,ie),w(b,He,ie),e(He,st),e(He,rt),rt.innerHTML=Ct,e(He,ft),e(He,Ze),Ze.innerHTML=Gt,e(He,_t),e(He,lt),lt.innerHTML=Wt,e(He,Nt),e(He,_e),_e.innerHTML=Re,e(He,bt),e(He,Oe),Oe.innerHTML=jt,e(He,Y),w(b,Pe,ie),w(b,ue,ie),e(ue,At),e(ue,it),it.innerHTML=ma,e(ue,pt),e(ue,wt),wt.innerHTML=xt,e(ue,ot),e(ue,ae),ae.innerHTML=Jt,e(ue,Dt),e(ue,kt),kt.innerHTML=Kt,e(ue,le),e(ue,Xe),Xe.innerHTML=dt,e(ue,Zt),e(ue,Ft),Ft.innerHTML=ea,e(ue,$t),w(b,Rt,ie),w(b,ge,ie),e(ge,Yt),w(b,ta,ie),w(b,We,ie),e(We,aa),e(We,na),na.innerHTML=kn,e(We,rn),e(We,sa),sa.innerHTML=Mn,e(We,on),e(We,Ee),Ee.innerHTML=Hn,e(We,da),e(We,ra),ra.innerHTML=qn,e(We,ln),e(We,oa),oa.innerHTML=Ln,e(We,hn),e(We,la),la.innerHTML=In,e(We,ca),e(We,Mt),Mt.innerHTML=Vn,e(We,un),w(b,pa,ie),w(b,It,ie),e(It,Fn),e(It,va),va.innerHTML=Ks,e(It,Bn),e(It,ba),ba.innerHTML=Rs,e(It,zn),e(It,wa),wa.innerHTML=Os,e(It,Qn),e(It,ya),ya.innerHTML=Xs,e(It,Cn),w(b,dn,ie),w(b,je,ie),e(je,Wn),e(je,ga),ga.innerHTML=Gs,e(je,jn),e(je,Ea),Ea.innerHTML=Js,e(je,Dn),e(je,Na),Na.innerHTML=Zs,e(je,Un),e(je,$a),$a.innerHTML=Ys,e(je,Kn),e(je,Ta),Ta.innerHTML=xs,e(je,Rn),e(je,Pa),Pa.innerHTML=er,e(je,On),e(je,Sa),Sa.innerHTML=tr,e(je,Xn),e(je,Aa),Aa.innerHTML=ar,e(je,Gn),e(je,ka),ka.innerHTML=nr,e(je,Jn),w(b,cn,ie),w(b,Ma,ie),e(Ma,Zn),w(b,vn,ie),w(b,Ha,ie),e(Ha,Yn),w(b,bn,ie),w(b,qa,ie),e(qa,La),La.innerHTML=sr,w(b,wn,ie),w(b,ia,ie),e(ia,xn),e(ia,Ia),Ia.innerHTML=rr,e(ia,es),w(b,yn,ie),w(b,Va,ie),e(Va,Fa),Fa.innerHTML=or,w(b,gn,ie),w(b,De,ie),e(De,ts),e(De,Ba),Ba.innerHTML=lr,e(De,as),e(De,za),za.innerHTML=ir,e(De,ns),e(De,Qa),Qa.innerHTML=hr,e(De,ss),e(De,Ca),Ca.innerHTML=ur,e(De,rs),e(De,Wa),Wa.innerHTML=mr,e(De,os),e(De,ja),ja.innerHTML=pr,e(De,ls),e(De,Da),Da.innerHTML=fr,e(De,is),e(De,Ua),Ua.innerHTML=_r,e(De,hs),e(De,Ka),Ka.innerHTML=dr,e(De,us),w(b,En,ie),w(b,Ra,ie),e(Ra,Oa),Oa.innerHTML=cr,w(b,Nn,ie),w(b,Bt,ie),e(Bt,ms),e(Bt,mn),e(mn,ps),e(Bt,fs),e(Bt,pn),e(pn,_s),e(Bt,ds),e(Bt,fn),e(fn,cs),e(Bt,vs),w(b,$n,ie),w(b,Xa,ie),e(Xa,Ga),Ga.innerHTML=vr,w(b,Tn,ie),w(b,Ja,ie),e(Ja,Za),Za.innerHTML=br,w(b,Pn,ie),w(b,Ya,ie),e(Ya,xa),xa.innerHTML=wr,w(b,Sn,ie),w(b,Ot,ie),e(Ot,bs),e(Ot,en),en.innerHTML=yr,e(Ot,ws),e(Ot,tn),tn.innerHTML=gr,e(Ot,ys),gs||(Ts=[u(E,"mouseenter",a[0]),u(k,"mouseenter",a[1]),u(L,"mouseenter",a[2]),u(A,"mouseenter",a[3]),u(C,"mouseenter",a[4]),u(S,"mouseenter",a[5]),u(W,"mouseenter",a[6]),u(M,"mouseenter",a[7]),u(X,"mouseenter",a[8]),u(F,"mouseenter",a[9]),u(N,"mouseenter",a[10]),u(ee,"mouseenter",a[11]),u(ce,"mouseenter",a[12]),u(ve,"mouseenter",a[13]),u(Q,"mouseenter",a[14]),u(oe,"mouseenter",a[15]),u(Te,"mouseenter",a[16]),u(Ve,"mouseenter",a[17]),u(Me,"mouseenter",a[18]),u(rt,"mouseenter",a[19]),u(Ze,"mouseenter",a[20]),u(lt,"mouseenter",a[21]),u(_e,"mouseenter",a[22]),u(Oe,"mouseenter",a[23]),u(it,"mouseenter",a[24]),u(wt,"mouseenter",a[25]),u(ae,"mouseenter",a[26]),u(kt,"mouseenter",a[27]),u(Xe,"mouseenter",a[28]),u(Ft,"mouseenter",a[29]),u(na,"mouseenter",a[30]),u(sa,"mouseenter",a[31]),u(Ee,"mouseenter",a[32]),u(ra,"mouseenter",a[33]),u(oa,"mouseenter",a[34]),u(la,"mouseenter",a[35]),u(Mt,"mouseenter",a[36]),u(va,"mouseenter",a[37]),u(ba,"mouseenter",a[38]),u(wa,"mouseenter",a[39]),u(ya,"mouseenter",a[40]),u(ga,"mouseenter",a[41]),u(Ea,"mouseenter",a[42]),u(Na,"mouseenter",a[43]),u($a,"mouseenter",a[44]),u(Ta,"mouseenter",a[45]),u(Pa,"mouseenter",a[46]),u(Sa,"mouseenter",a[47]),u(Aa,"mouseenter",a[48]),u(ka,"mouseenter",a[49]),u(La,"mouseenter",a[50]),u(Ia,"mouseenter",a[51]),u(Fa,"mouseenter",a[52]),u(Ba,"mouseenter",a[53]),u(za,"mouseenter",a[54]),u(Qa,"mouseenter",a[55]),u(Ca,"mouseenter",a[56]),u(Wa,"mouseenter",a[57]),u(ja,"mouseenter",a[58]),u(Da,"mouseenter",a[59]),u(Ua,"mouseenter",a[60]),u(Ka,"mouseenter",a[61]),u(Oa,"mouseenter",a[62]),u(Ga,"mouseenter",a[63]),u(Za,"mouseenter",a[64]),u(xa,"mouseenter",a[65]),u(en,"mouseenter",a[66]),u(tn,"mouseenter",a[67])],gs=!0)},p:at,i:at,o:at,d(b){b&&t(n),b&&t(m),b&&t(f),b&&t(d),b&&t(_),b&&t(re),b&&t(ne),b&&t(Je),b&&t(be),b&&t(Ke),b&&t(He),b&&t(Pe),b&&t(ue),b&&t(Rt),b&&t(ge),b&&t(ta),b&&t(We),b&&t(pa),b&&t(It),b&&t(dn),b&&t(je),b&&t(cn),b&&t(Ma),b&&t(vn),b&&t(Ha),b&&t(bn),b&&t(qa),b&&t(wn),b&&t(ia),b&&t(yn),b&&t(Va),b&&t(gn),b&&t(De),b&&t(En),b&&t(Ra),b&&t(Nn),b&&t(Bt),b&&t($n),b&&t(Xa),b&&t(Tn),b&&t(Ja),b&&t(Pn),b&&t(Ya),b&&t(Sn),b&&t(Ot),gs=!1,Ut(Ts)}}}function R(a){console.log(a)}function gl(a){return[()=>R([]),()=>R([]),()=>R([]),()=>R([]),()=>R([]),()=>R([]),()=>R([]),()=>R(["n"]),()=>R(["n","d","k"]),()=>R(["d","k"]),()=>R(["k"]),()=>R([]),()=>R([]),()=>R([]),()=>R([]),()=>R(["n","d","k"]),()=>R(["d","k"]),()=>R(["k"]),()=>R([]),()=>R(["n"]),()=>R([]),()=>R([]),()=>R(["n","t","m","s"]),()=>R(["n","N"]),()=>R([]),()=>R(["N"]),()=>R(["n"]),()=>R([]),()=>R([]),()=>R([]),()=>R(["x"]),()=>R(["x"]),()=>R(["k"]),()=>R(["x","k"]),()=>R(["\\alpha","k"]),()=>R(["x","\\beta","k"]),()=>R(["n","k"]),()=>R(["\\alpha","\\beta","k"]),()=>R(["\\alpha","\\beta","k"]),()=>R(["n","k"]),()=>R(["x","k"]),()=>R([]),()=>R([]),()=>R(["n"]),()=>R(["n"]),()=>R([]),()=>R(["N"]),()=>R([]),()=>R(["n"]),()=>R(["r","n","t","s","m","N"]),()=>R(["r","n","t","s","x","m"]),()=>R([]),()=>R(["n","x","N"]),()=>R(["y","k"]),()=>R(["k"]),()=>R(["n"]),()=>R(["y","k"]),()=>R(["k"]),()=>R([]),()=>R(["y","k"]),()=>R([]),()=>R(["n","k"]),()=>R(["r","n","t","s","x","m","N","y"]),()=>R(["n","x","y","N"]),()=>R(["n","x","N","y","k"]),()=>R(["n","x","N","y","k"]),()=>R(["y","k"]),()=>R(["x","y","k"])]}class El extends Ht{constructor(n){super(),qt(this,n,gl,yl,Lt,{},null,[-1,-1,-1])}}function Nl(a){let n,p,m,f;return n=new wl({}),m=new El({}),{c(){Ye(n.$$.fragment),p=j(),Ye(m.$$.fragment)},l(y){xe(n.$$.fragment,y),p=D(y),xe(m.$$.fragment,y)},m(y,d){et(n,y,d),w(y,p,d),et(m,y,d),f=!0},p:at,i(y){f||(ze(n.$$.fragment,y),ze(m.$$.fragment,y),f=!0)},o(y){Ge(n.$$.fragment,y),Ge(m.$$.fragment,y),f=!1},d(y){tt(n,y),y&&t(p),tt(m,y)}}}class $l extends Ht{constructor(n){super(),qt(this,n,null,Nl,Lt,{})}}function Tl(a){let n,p,m,f,y,d,_=h("\\alpha")+"",g,E,I=h("\\beta")+"",v,k,V=h("\\alpha = \\Vert{\\alpha}\\Vert \\cdot e^{i \\phi_{\\alpha}}")+"",H,L,G=h("\\beta = \\Vert{\\beta}\\Vert \\cdot e^{i \\phi_{\\beta}}")+"",U,A,B=h("\\Vert{\\alpha}\\Vert \\cdot e^{i \\phi_{\\alpha}} |0\\rangle + \\Vert{\\beta}\\Vert \\cdot e^{i \\phi_{\\beta}} |1\\rangle")+"",q,C,P,J,S,z=h("e^{i \\phi_{\\alpha}}")+"",Z,W,x=h("\\Vert{e^{i \\phi_{\\alpha}}}\\Vert^2")+"",$,M,T=h("1")+"",O,X,Ne=h("\\phi_{\\alpha}")+"",K,F,we=h("\\phi_{\\beta}")+"",c,N,de=h("e^{i \\phi_{\\alpha}}")+"",te,ee,ye=h("\\Vert{\\alpha}\\Vert \\cdot |0\\rangle + \\Vert{\\beta}\\Vert \\cdot \\frac{e^{i \\phi_{\\beta}}}{e^{i \\phi_{\\alpha}}} |1\\rangle")+"",he,re,ne=h("\\frac{e^{i \\phi_{\\beta}}}{e^{i \\phi_{\\alpha}}} = e^{i (\\phi_{\\beta} - \\phi_{\\alpha})}")+"",$e,ce,mt=h("\\phi = \\phi_{\\beta} - \\phi_{\\alpha}")+"",qe,ve,pe=h("\\Vert{\\alpha}\\Vert \\cdot |0\\rangle + \\Vert{\\beta}\\Vert \\cdot e^{i \\phi} |1\\rangle")+"",ke,Q,me,Le,oe,se=h("\\Vert{\\alpha}\\Vert^2 + \\Vert{\\beta}\\Vert^2 = 1")+"",Ie,Te,gt,Ue,Ve,Et=h("\\theta")+"",Qe,Me,vt=h("\\cos{(\\frac{\\theta}{2})} \\cdot |0 \\rangle + \\sin{(\\frac{\\theta}{2})} \\cdot e^{i \\phi} |1 \\rangle")+"",Ce,Je,be=h("\\theta")+"",nt,Ke,He=h("\\phi")+"",st,rt,Ct=h("\\theta")+"",ft,Ze,Gt=h("z")+"",_t,lt,Wt=h("\\phi")+"",Nt,_e,Re=h("x-y")+"",bt,Oe,jt,Y,Pe,ue,At,it,ma=h("\\theta")+"",pt,wt,xt=h("\\phi")+"",ot,ae,Jt,Dt,kt,Kt;return{c(){n=o("h2"),p=s("The Bloch-sphere"),m=j(),f=o("p"),y=s("As the coefficients "),d=o("span"),g=s(" and "),E=o("span"),v=s(" are complex numbers, they can be expressed in the form "),k=o("span"),H=s(" and "),L=o("span"),U=s(". Thus, the state of the qubit can be rewritten as "),A=o("span"),q=s("."),C=j(),P=o("p"),J=s("Remember that "),S=o("span"),Z=s(" is a unit vector rotated around the origin, and therefore the square of its norm "),W=o("span"),$=s(" also equals to "),M=o("span"),O=s(". This means that we can modify the angles "),X=o("span"),K=s(" and "),F=o("span"),c=s(" freely without affecting the measurement probabilities. Therefore, we can do an algebraic trick to simplify the expression above. Namely, let's divide the state by "),N=o("span"),te=s(" to obtain "),ee=o("span"),he=s(". By the rules of exponentiation, "),re=o("span"),$e=s(". Next, let's introduce a new variable "),ce=o("span"),qe=s(", with the help of which the state can be further simplified to "),ve=o("span"),ke=s("."),Q=j(),me=o("p"),Le=s("We know that "),oe=o("span"),Ie=s(". Consequently, these two numbers can also be represented geometrically as vector of unit length rotated around the origin by some angle, the "),Te=o("em"),gt=s("double"),Ue=s(" of which we'll denote as "),Ve=o("span"),Qe=s(". Using trigonometry, we can now rewrite the state as "),Me=o("span"),Ce=s(". Notice, that we now only need two variables to express the state of the qubit: the angles "),Je=o("span"),nt=s(" and "),Ke=o("span"),st=s(". Geometrically, this can be represented as a vector pointing to the surface of 3-dimensional sphere with unit radius, where "),rt=o("span"),ft=s(" is the angle of the vector and the "),Ze=o("span"),_t=s(" axis, and "),lt=o("span"),Nt=s(" is the angle of the vertical projection of the vector on the "),_e=o("span"),bt=s(" plane. This representation of qubit states is called the "),Oe=o("em"),jt=s("Bloch sphere"),Y=s("."),Pe=j(),ue=o("p"),At=s("It's important to note that of the two degrees of freedom on the Bloch sphere, only the angle "),it=o("span"),pt=s(" is related to measurement probabilities. "),wt=o("span"),ot=s(" is an inherently quantum property called the "),ae=o("em"),Jt=s("phase"),Dt=s(" that does not have physical manifestation directly observable to us. Because of this, it's hard to find any intuitive analogy from everyday life that could help us understand what exactly the phase is. The most useful approach in this context is to look at the phase as a matematical property of quantum objects that we can leverage to design clever algorithms.")},l(le){n=l(le,"H2",{});var Xe=i(n);p=r(Xe,"The Bloch-sphere"),Xe.forEach(t),m=D(le),f=l(le,"P",{});var dt=i(f);y=r(dt,"As the coefficients "),d=l(dt,"SPAN",{});var Zt=i(d);Zt.forEach(t),g=r(dt," and "),E=l(dt,"SPAN",{});var Ft=i(E);Ft.forEach(t),v=r(dt," are complex numbers, they can be expressed in the form "),k=l(dt,"SPAN",{});var ea=i(k);ea.forEach(t),H=r(dt," and "),L=l(dt,"SPAN",{});var $t=i(L);$t.forEach(t),U=r(dt,". Thus, the state of the qubit can be rewritten as "),A=l(dt,"SPAN",{});var Rt=i(A);Rt.forEach(t),q=r(dt,"."),dt.forEach(t),C=D(le),P=l(le,"P",{});var ge=i(P);J=r(ge,"Remember that "),S=l(ge,"SPAN",{});var Yt=i(S);Yt.forEach(t),Z=r(ge," is a unit vector rotated around the origin, and therefore the square of its norm "),W=l(ge,"SPAN",{});var ta=i(W);ta.forEach(t),$=r(ge," also equals to "),M=l(ge,"SPAN",{});var We=i(M);We.forEach(t),O=r(ge,". This means that we can modify the angles "),X=l(ge,"SPAN",{});var aa=i(X);aa.forEach(t),K=r(ge," and "),F=l(ge,"SPAN",{});var na=i(F);na.forEach(t),c=r(ge," freely without affecting the measurement probabilities. Therefore, we can do an algebraic trick to simplify the expression above. Namely, let's divide the state by "),N=l(ge,"SPAN",{});var kn=i(N);kn.forEach(t),te=r(ge," to obtain "),ee=l(ge,"SPAN",{});var rn=i(ee);rn.forEach(t),he=r(ge,". By the rules of exponentiation, "),re=l(ge,"SPAN",{});var sa=i(re);sa.forEach(t),$e=r(ge,". Next, let's introduce a new variable "),ce=l(ge,"SPAN",{});var Mn=i(ce);Mn.forEach(t),qe=r(ge,", with the help of which the state can be further simplified to "),ve=l(ge,"SPAN",{});var on=i(ve);on.forEach(t),ke=r(ge,"."),ge.forEach(t),Q=D(le),me=l(le,"P",{});var Ee=i(me);Le=r(Ee,"We know that "),oe=l(Ee,"SPAN",{});var Hn=i(oe);Hn.forEach(t),Ie=r(Ee,". Consequently, these two numbers can also be represented geometrically as vector of unit length rotated around the origin by some angle, the "),Te=l(Ee,"EM",{});var da=i(Te);gt=r(da,"double"),da.forEach(t),Ue=r(Ee," of which we'll denote as "),Ve=l(Ee,"SPAN",{});var ra=i(Ve);ra.forEach(t),Qe=r(Ee,". Using trigonometry, we can now rewrite the state as "),Me=l(Ee,"SPAN",{});var qn=i(Me);qn.forEach(t),Ce=r(Ee,". Notice, that we now only need two variables to express the state of the qubit: the angles "),Je=l(Ee,"SPAN",{});var ln=i(Je);ln.forEach(t),nt=r(Ee," and "),Ke=l(Ee,"SPAN",{});var oa=i(Ke);oa.forEach(t),st=r(Ee,". Geometrically, this can be represented as a vector pointing to the surface of 3-dimensional sphere with unit radius, where "),rt=l(Ee,"SPAN",{});var Ln=i(rt);Ln.forEach(t),ft=r(Ee," is the angle of the vector and the "),Ze=l(Ee,"SPAN",{});var hn=i(Ze);hn.forEach(t),_t=r(Ee," axis, and "),lt=l(Ee,"SPAN",{});var la=i(lt);la.forEach(t),Nt=r(Ee," is the angle of the vertical projection of the vector on the "),_e=l(Ee,"SPAN",{});var In=i(_e);In.forEach(t),bt=r(Ee," plane. This representation of qubit states is called the "),Oe=l(Ee,"EM",{});var ca=i(Oe);jt=r(ca,"Bloch sphere"),ca.forEach(t),Y=r(Ee,"."),Ee.forEach(t),Pe=D(le),ue=l(le,"P",{});var Mt=i(ue);At=r(Mt,"It's important to note that of the two degrees of freedom on the Bloch sphere, only the angle "),it=l(Mt,"SPAN",{});var Vn=i(it);Vn.forEach(t),pt=r(Mt," is related to measurement probabilities. "),wt=l(Mt,"SPAN",{});var un=i(wt);un.forEach(t),ot=r(Mt," is an inherently quantum property called the "),ae=l(Mt,"EM",{});var pa=i(ae);Jt=r(pa,"phase"),pa.forEach(t),Dt=r(Mt," that does not have physical manifestation directly observable to us. Because of this, it's hard to find any intuitive analogy from everyday life that could help us understand what exactly the phase is. The most useful approach in this context is to look at the phase as a matematical property of quantum objects that we can leverage to design clever algorithms."),Mt.forEach(t)},m(le,Xe){w(le,n,Xe),e(n,p),w(le,m,Xe),w(le,f,Xe),e(f,y),e(f,d),d.innerHTML=_,e(f,g),e(f,E),E.innerHTML=I,e(f,v),e(f,k),k.innerHTML=V,e(f,H),e(f,L),L.innerHTML=G,e(f,U),e(f,A),A.innerHTML=B,e(f,q),w(le,C,Xe),w(le,P,Xe),e(P,J),e(P,S),S.innerHTML=z,e(P,Z),e(P,W),W.innerHTML=x,e(P,$),e(P,M),M.innerHTML=T,e(P,O),e(P,X),X.innerHTML=Ne,e(P,K),e(P,F),F.innerHTML=we,e(P,c),e(P,N),N.innerHTML=de,e(P,te),e(P,ee),ee.innerHTML=ye,e(P,he),e(P,re),re.innerHTML=ne,e(P,$e),e(P,ce),ce.innerHTML=mt,e(P,qe),e(P,ve),ve.innerHTML=pe,e(P,ke),w(le,Q,Xe),w(le,me,Xe),e(me,Le),e(me,oe),oe.innerHTML=se,e(me,Ie),e(me,Te),e(Te,gt),e(me,Ue),e(me,Ve),Ve.innerHTML=Et,e(me,Qe),e(me,Me),Me.innerHTML=vt,e(me,Ce),e(me,Je),Je.innerHTML=be,e(me,nt),e(me,Ke),Ke.innerHTML=He,e(me,st),e(me,rt),rt.innerHTML=Ct,e(me,ft),e(me,Ze),Ze.innerHTML=Gt,e(me,_t),e(me,lt),lt.innerHTML=Wt,e(me,Nt),e(me,_e),_e.innerHTML=Re,e(me,bt),e(me,Oe),e(Oe,jt),e(me,Y),w(le,Pe,Xe),w(le,ue,Xe),e(ue,At),e(ue,it),it.innerHTML=ma,e(ue,pt),e(ue,wt),wt.innerHTML=xt,e(ue,ot),e(ue,ae),e(ae,Jt),e(ue,Dt),kt||(Kt=[u(d,"mouseenter",a[0]),u(E,"mouseenter",a[1]),u(k,"mouseenter",a[2]),u(L,"mouseenter",a[3]),u(A,"mouseenter",a[4]),u(S,"mouseenter",a[5]),u(W,"mouseenter",a[6]),u(M,"mouseenter",a[7]),u(X,"mouseenter",a[8]),u(F,"mouseenter",a[9]),u(N,"mouseenter",a[10]),u(ee,"mouseenter",a[11]),u(re,"mouseenter",a[12]),u(ce,"mouseenter",a[13]),u(ve,"mouseenter",a[14]),u(oe,"mouseenter",a[15]),u(Ve,"mouseenter",a[16]),u(Me,"mouseenter",a[17]),u(Je,"mouseenter",a[18]),u(Ke,"mouseenter",a[19]),u(rt,"mouseenter",a[20]),u(Ze,"mouseenter",a[21]),u(lt,"mouseenter",a[22]),u(_e,"mouseenter",a[23]),u(it,"mouseenter",a[24]),u(wt,"mouseenter",a[25])],kt=!0)},p:at,i:at,o:at,d(le){le&&t(n),le&&t(m),le&&t(f),le&&t(C),le&&t(P),le&&t(Q),le&&t(me),le&&t(Pe),le&&t(ue),kt=!1,Ut(Kt)}}}function Be(a){console.log(a)}function Pl(a){return[()=>Be(["\\alpha"]),()=>Be(["\\beta"]),()=>Be(["\\phi","\\alpha"]),()=>Be(["\\phi","\\beta"]),()=>Be(["\\phi","\\alpha","\\beta"]),()=>Be(["\\phi","\\alpha"]),()=>Be(["\\phi","\\alpha"]),()=>Be([]),()=>Be(["\\phi","\\alpha"]),()=>Be(["\\phi","\\beta"]),()=>Be(["\\phi","\\alpha"]),()=>Be(["\\phi","\\alpha","\\beta"]),()=>Be(["\\phi","\\beta","\\alpha"]),()=>Be(["\\phi","\\beta","\\alpha"]),()=>Be(["\\phi","\\alpha","\\beta"]),()=>Be(["\\alpha","\\beta"]),()=>Be(["\\theta"]),()=>Be(["\\phi","\\theta"]),()=>Be(["\\theta"]),()=>Be(["\\phi"]),()=>Be(["\\theta"]),()=>Be(["z"]),()=>Be(["\\phi"]),()=>Be(["x","y"]),()=>Be(["\\theta"]),()=>Be(["\\phi"])]}class Sl extends Ht{constructor(n){super(),qt(this,n,Pl,Tl,Lt,{})}}const Al='<a href="https://en.wikipedia.org/wiki/Bit"><h3 class="text-lg font-semibold">Bit</h3></a><p>The <b>bit</b> is the most basic unit of information in computing and digital communications. The name is a portmanteau of <b>binary digit</b>. The bit represents a logical state with one of two possible values. These values are most commonly represented as either <span class="nowrap">"<span class="monospaced">1</span>" or "<span class="monospaced">0</span>"</span>, but other representations such as <i>true</i>/<i>false</i>, <i>yes</i>/<i>no</i>, <i>on</i>/<i>off</i>, or <i>+</i>/<i>\u2212</i> are also commonly used.</p>',kl='<a href="https://en.wikipedia.org/wiki/Qubit"><h3 class="text-lg font-semibold">Qubit</h3></a><p>In quantum computing, a <b>qubit</b> or <b>quantum bit</b> is a basic unit of quantum information\u2014the quantum version of the classic binary bit physically realized with a two-state device. A qubit is a two-state quantum-mechanical system, one of the simplest quantum systems displaying the peculiarity of quantum mechanics. Examples include the spin of the electron in which the two levels can be taken as spin up and spin down; or the polarization of a single photon in which the two states can be taken to be the vertical polarization and the horizontal polarization. In a classical system, a bit would have to be in one state or the other. However, quantum mechanics allows the qubit to be in a coherent superposition of both states simultaneously, a property that is fundamental to quantum mechanics and quantum computing.</p>',Ml='<a href="https://en.wikipedia.org/wiki/Complex_number"><h3 class="text-lg font-semibold">Complex number</h3></a><p>In mathematics, a <b>complex number</b> is an element of a number system that extends the real numbers with a specific element denoted <span class="texhtml mvar" style="font-style:italic">i</span>, called the imaginary unit and satisfying the equation <span class="texhtml "><i>i</i><sup>2</sup> = \u22121</span>; every complex number can be expressed in the form <span class="texhtml "><i>a</i> + <i>bi</i></span>, where <span class="texhtml mvar" style="font-style:italic">a</span> and <span class="texhtml mvar" style="font-style:italic">b</span> are real numbers. Because no real number satisfies the above equation, <span class="texhtml mvar" style="font-style:italic">i</span> was called an imaginary number by Ren\xE9 Descartes. For the complex number <span class="texhtml "><i>a</i> + <i>bi</i></span>, <span class="texhtml mvar" style="font-style:italic">a</span> is called the <b><span class="vanchor"><span class="vanchor-text">real part</span></span></b> and <span class="texhtml mvar" style="font-style:italic">b</span> is called the <b><span class="vanchor"><span class="vanchor-text">imaginary part</span></span></b>. The set of complex numbers is denoted by either of the symbols <span class="mwe-math-element"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f9add4085095b9b6d28d045fd9c92c2c09f549a7" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align:-0.338ex;width:1.678ex;height:2.176ex" /></span> or <span class="texhtml "><b>C</b></span>. Despite the historical nomenclature "imaginary", complex numbers are regarded in the mathematical sciences as just as "real" as the real numbers and are fundamental in many aspects of the scientific description of the natural world.</p>';function Hl(a){let n;return{c(){n=s("bits")},l(p){n=r(p,"bits")},m(p,m){w(p,n,m)},d(p){p&&t(n)}}}function ql(a){let n;return{c(){n=s("Qubits")},l(p){n=r(p,"Qubits")},m(p,m){w(p,n,m)},d(p){p&&t(n)}}}function Ll(a){let n;return{c(){n=s("complex numbers")},l(p){n=r(p,"complex numbers")},m(p,m){w(p,n,m)},d(p){p&&t(n)}}}function Il(a){let n,p,m,f,y,d,_,g,E,I,v,k=h("0")+"",V,H,L=h("1")+"",G,U,A,B,q,C,P=h("0")+"",J,S,z=h("1")+"",Z,W,x,$,M,T,O,X,Ne=h("|0\\rangle")+"",K,F,we=h("|1\\rangle")+"",c,N,de,te,ee,ye,he,re,ne=h("\\alpha |0\\rangle + \\beta |1\\rangle")+"",$e,ce,mt=h("\\alpha")+"",qe,ve,pe=h("\\beta")+"",ke,Q,me,Le,oe=h("|0\\rangle")+"",se,Ie,Te=h("\\Vert{\\alpha}\\Vert^2")+"",gt,Ue,Ve=h("|1\\rangle")+"",Et,Qe,Me=h("\\Vert{\\beta}\\Vert^2")+"",vt,Ce,Je=h("|0\\rangle")+"",be,nt,Ke=h("|1\\rangle")+"",He,st,rt=h("\\Vert{\\alpha}\\Vert^2 + \\Vert{\\beta}\\Vert^2 = 1")+"",Ct,ft,Ze=h("\\Vert{\\alpha}\\Vert^2")+"",Gt,_t,lt=h("\\Vert{\\beta}\\Vert^2")+"",Wt,Nt,_e,Re,bt,Oe,jt;return d=new sn({props:{hovertext:Al,$$slots:{default:[Hl]},$$scope:{ctx:a}}}),B=new sn({props:{hovertext:kl,$$slots:{default:[ql]},$$scope:{ctx:a}}}),Q=new sn({props:{hovertext:Ml,$$slots:{default:[Ll]},$$scope:{ctx:a}}}),{c(){n=o("h2"),p=s("Qubit states"),m=j(),f=o("p"),y=s("The elementary units of information in classical computing are "),Ye(d.$$.fragment),_=s(". As their name suggests, bits represent one single "),g=o("em"),E=s("bit"),I=s(" of information, which means they can take on either of two values "),v=o("span"),V=s(" and "),H=o("span"),G=s(" at a time."),U=j(),A=o("p"),Ye(B.$$.fragment),q=s(" are the quantum computing equivalent of bits. They differ from classical bits - among other things - in that they can take on a multitude of values instead of just "),C=o("span"),J=s(" and "),S=o("span"),Z=s(", until that value is "),W=o("em"),x=s("measured"),$=s(", at which point they behave just like classical bits. To explain what this means exactly, we'll need to introduce some further concepts."),M=j(),T=o("p"),O=s("Let "),X=o("span"),K=s(" and "),F=o("span"),c=s(" denote the so called "),N=o("em"),de=s("basis states"),te=s(" of a qubit that are the quantum-equivalent of classical bit states. If you look at a qubit directly to learn it's value, you'll see one of these basis states. But while you're not looking - due to it's quantum nature - the state of a qubit may be something more intricate. Generally, it can be expressed as the "),ee=o("em"),ye=s("linear combination"),he=s(" of the two basis states: "),re=o("span"),$e=s(". Here, "),ce=o("span"),qe=s(" and "),ve=o("span"),ke=s(" are "),Ye(Q.$$.fragment),me=s(" that indicate the relative weight, with which the two basis states are present in this combination. More precisely, if we now look at the qubit, we'll see the basis state "),Le=o("span"),se=s(" with a probability of "),Ie=o("span"),gt=s(", and the basis state "),Ue=o("span"),Et=s(" with a probability of "),Qe=o("span"),vt=s(". Because these probabilities must add up to one - as "),Ce=o("span"),be=s(" and "),nt=o("span"),He=s(" are the only possible outcomes - the equation "),st=o("span"),Ct=s(" must hold for all possible qubit states. Let's call "),ft=o("span"),Gt=s(" and "),_t=o("span"),Wt=s(" the "),Nt=o("em"),_e=s("measurement probabilities"),Re=s(" of the basis states.")},l(Y){n=l(Y,"H2",{});var Pe=i(n);p=r(Pe,"Qubit states"),Pe.forEach(t),m=D(Y),f=l(Y,"P",{});var ue=i(f);y=r(ue,"The elementary units of information in classical computing are "),xe(d.$$.fragment,ue),_=r(ue,". As their name suggests, bits represent one single "),g=l(ue,"EM",{});var At=i(g);E=r(At,"bit"),At.forEach(t),I=r(ue," of information, which means they can take on either of two values "),v=l(ue,"SPAN",{});var it=i(v);it.forEach(t),V=r(ue," and "),H=l(ue,"SPAN",{});var ma=i(H);ma.forEach(t),G=r(ue," at a time."),ue.forEach(t),U=D(Y),A=l(Y,"P",{});var pt=i(A);xe(B.$$.fragment,pt),q=r(pt," are the quantum computing equivalent of bits. They differ from classical bits - among other things - in that they can take on a multitude of values instead of just "),C=l(pt,"SPAN",{});var wt=i(C);wt.forEach(t),J=r(pt," and "),S=l(pt,"SPAN",{});var xt=i(S);xt.forEach(t),Z=r(pt,", until that value is "),W=l(pt,"EM",{});var ot=i(W);x=r(ot,"measured"),ot.forEach(t),$=r(pt,", at which point they behave just like classical bits. To explain what this means exactly, we'll need to introduce some further concepts."),pt.forEach(t),M=D(Y),T=l(Y,"P",{});var ae=i(T);O=r(ae,"Let "),X=l(ae,"SPAN",{});var Jt=i(X);Jt.forEach(t),K=r(ae," and "),F=l(ae,"SPAN",{});var Dt=i(F);Dt.forEach(t),c=r(ae," denote the so called "),N=l(ae,"EM",{});var kt=i(N);de=r(kt,"basis states"),kt.forEach(t),te=r(ae," of a qubit that are the quantum-equivalent of classical bit states. If you look at a qubit directly to learn it's value, you'll see one of these basis states. But while you're not looking - due to it's quantum nature - the state of a qubit may be something more intricate. Generally, it can be expressed as the "),ee=l(ae,"EM",{});var Kt=i(ee);ye=r(Kt,"linear combination"),Kt.forEach(t),he=r(ae," of the two basis states: "),re=l(ae,"SPAN",{});var le=i(re);le.forEach(t),$e=r(ae,". Here, "),ce=l(ae,"SPAN",{});var Xe=i(ce);Xe.forEach(t),qe=r(ae," and "),ve=l(ae,"SPAN",{});var dt=i(ve);dt.forEach(t),ke=r(ae," are "),xe(Q.$$.fragment,ae),me=r(ae," that indicate the relative weight, with which the two basis states are present in this combination. More precisely, if we now look at the qubit, we'll see the basis state "),Le=l(ae,"SPAN",{});var Zt=i(Le);Zt.forEach(t),se=r(ae," with a probability of "),Ie=l(ae,"SPAN",{});var Ft=i(Ie);Ft.forEach(t),gt=r(ae,", and the basis state "),Ue=l(ae,"SPAN",{});var ea=i(Ue);ea.forEach(t),Et=r(ae," with a probability of "),Qe=l(ae,"SPAN",{});var $t=i(Qe);$t.forEach(t),vt=r(ae,". Because these probabilities must add up to one - as "),Ce=l(ae,"SPAN",{});var Rt=i(Ce);Rt.forEach(t),be=r(ae," and "),nt=l(ae,"SPAN",{});var ge=i(nt);ge.forEach(t),He=r(ae," are the only possible outcomes - the equation "),st=l(ae,"SPAN",{});var Yt=i(st);Yt.forEach(t),Ct=r(ae," must hold for all possible qubit states. Let's call "),ft=l(ae,"SPAN",{});var ta=i(ft);ta.forEach(t),Gt=r(ae," and "),_t=l(ae,"SPAN",{});var We=i(_t);We.forEach(t),Wt=r(ae," the "),Nt=l(ae,"EM",{});var aa=i(Nt);_e=r(aa,"measurement probabilities"),aa.forEach(t),Re=r(ae," of the basis states."),ae.forEach(t)},m(Y,Pe){w(Y,n,Pe),e(n,p),w(Y,m,Pe),w(Y,f,Pe),e(f,y),et(d,f,null),e(f,_),e(f,g),e(g,E),e(f,I),e(f,v),v.innerHTML=k,e(f,V),e(f,H),H.innerHTML=L,e(f,G),w(Y,U,Pe),w(Y,A,Pe),et(B,A,null),e(A,q),e(A,C),C.innerHTML=P,e(A,J),e(A,S),S.innerHTML=z,e(A,Z),e(A,W),e(W,x),e(A,$),w(Y,M,Pe),w(Y,T,Pe),e(T,O),e(T,X),X.innerHTML=Ne,e(T,K),e(T,F),F.innerHTML=we,e(T,c),e(T,N),e(N,de),e(T,te),e(T,ee),e(ee,ye),e(T,he),e(T,re),re.innerHTML=ne,e(T,$e),e(T,ce),ce.innerHTML=mt,e(T,qe),e(T,ve),ve.innerHTML=pe,e(T,ke),et(Q,T,null),e(T,me),e(T,Le),Le.innerHTML=oe,e(T,se),e(T,Ie),Ie.innerHTML=Te,e(T,gt),e(T,Ue),Ue.innerHTML=Ve,e(T,Et),e(T,Qe),Qe.innerHTML=Me,e(T,vt),e(T,Ce),Ce.innerHTML=Je,e(T,be),e(T,nt),nt.innerHTML=Ke,e(T,He),e(T,st),st.innerHTML=rt,e(T,Ct),e(T,ft),ft.innerHTML=Ze,e(T,Gt),e(T,_t),_t.innerHTML=lt,e(T,Wt),e(T,Nt),e(Nt,_e),e(T,Re),bt=!0,Oe||(jt=[u(v,"mouseenter",a[0]),u(H,"mouseenter",a[1]),u(C,"mouseenter",a[2]),u(S,"mouseenter",a[3]),u(X,"mouseenter",a[4]),u(F,"mouseenter",a[5]),u(re,"mouseenter",a[6]),u(ce,"mouseenter",a[7]),u(ve,"mouseenter",a[8]),u(Le,"mouseenter",a[9]),u(Ie,"mouseenter",a[10]),u(Ue,"mouseenter",a[11]),u(Qe,"mouseenter",a[12]),u(Ce,"mouseenter",a[13]),u(nt,"mouseenter",a[14]),u(st,"mouseenter",a[15]),u(ft,"mouseenter",a[16]),u(_t,"mouseenter",a[17])],Oe=!0)},p(Y,[Pe]){const ue={};Pe&262144&&(ue.$$scope={dirty:Pe,ctx:Y}),d.$set(ue);const At={};Pe&262144&&(At.$$scope={dirty:Pe,ctx:Y}),B.$set(At);const it={};Pe&262144&&(it.$$scope={dirty:Pe,ctx:Y}),Q.$set(it)},i(Y){bt||(ze(d.$$.fragment,Y),ze(B.$$.fragment,Y),ze(Q.$$.fragment,Y),bt=!0)},o(Y){Ge(d.$$.fragment,Y),Ge(B.$$.fragment,Y),Ge(Q.$$.fragment,Y),bt=!1},d(Y){Y&&t(n),Y&&t(m),Y&&t(f),tt(d),Y&&t(U),Y&&t(A),tt(B),Y&&t(M),Y&&t(T),tt(Q),Oe=!1,Ut(jt)}}}function ct(a){console.log(a)}function Vl(a){return[()=>ct([]),()=>ct([]),()=>ct([]),()=>ct([]),()=>ct([]),()=>ct([]),()=>ct(["\\alpha","\\beta"]),()=>ct(["\\alpha"]),()=>ct(["\\beta"]),()=>ct([]),()=>ct(["\\alpha"]),()=>ct([]),()=>ct(["\\beta"]),()=>ct([]),()=>ct([]),()=>ct(["\\alpha","\\beta"]),()=>ct(["\\alpha"]),()=>ct(["\\beta"])]}class Fl extends Ht{constructor(n){super(),qt(this,n,Vl,Il,Lt,{})}}function Bl(a){let n,p,m,f,y,d,_,g,E,I,v,k,V,H,L,G=h("|0\\rangle")+"",U,A,B=h("|1\\rangle")+"",q,C,P,J,S,z=h("n")+"",Z,W,x,$,M,T=h("\\left( \\alpha_1 |0\\rangle + \\beta_1 |1\\rangle \\right) \\otimes ... \\otimes \\left( \\alpha_n |0\\rangle + \\beta_n |1\\rangle \\right)")+"",O,X,Ne=h("\\alpha_k, \\beta_k")+"",K,F,we=h("k")+"",c,N,de=h("\\otimes")+"",te,ee,ye;return{c(){n=o("h2"),p=s("Multiple qubits"),m=j(),f=o("p"),y=s("As you might have guessed, quantum algorithms require not only one, but several qubits. These qubits may be "),d=o("em"),_=s("independent"),g=s(" from each other, meaning their states can be expressed individually. However, it is possible for multiple qubits to "),E=o("em"),I=s("share"),v=s(" some information with each other, in which case they no longer have states of their own, but represent a unit of information together. This is called "),k=o("em"),V=s("entaglement"),H=s(", and it is another fundamental difference between classical and quantum computing. As an example, two qubits can be entangled in a way that, if we look at one of them and find it's in the basis state "),L=o("span"),U=s(", we learn immediately that the other one must be in the basis state "),A=o("span"),q=s(", and vice versa."),C=j(),P=o("p"),J=s("The joint state of a sequence of "),S=o("span"),Z=j(),W=o("em"),x=s("independent"),$=s(" qubits can be written as "),M=o("span"),O=s(", where "),X=o("span"),K=s(" are the coefficients associated with the state of the "),F=o("span"),c=s("-th qubit as described above, and the operator "),N=o("span"),te=s(" indicates that none of the qubits are entagled with each other.")},l(he){n=l(he,"H2",{});var re=i(n);p=r(re,"Multiple qubits"),re.forEach(t),m=D(he),f=l(he,"P",{});var ne=i(f);y=r(ne,"As you might have guessed, quantum algorithms require not only one, but several qubits. These qubits may be "),d=l(ne,"EM",{});var $e=i(d);_=r($e,"independent"),$e.forEach(t),g=r(ne," from each other, meaning their states can be expressed individually. However, it is possible for multiple qubits to "),E=l(ne,"EM",{});var ce=i(E);I=r(ce,"share"),ce.forEach(t),v=r(ne," some information with each other, in which case they no longer have states of their own, but represent a unit of information together. This is called "),k=l(ne,"EM",{});var mt=i(k);V=r(mt,"entaglement"),mt.forEach(t),H=r(ne,", and it is another fundamental difference between classical and quantum computing. As an example, two qubits can be entangled in a way that, if we look at one of them and find it's in the basis state "),L=l(ne,"SPAN",{});var qe=i(L);qe.forEach(t),U=r(ne,", we learn immediately that the other one must be in the basis state "),A=l(ne,"SPAN",{});var ve=i(A);ve.forEach(t),q=r(ne,", and vice versa."),ne.forEach(t),C=D(he),P=l(he,"P",{});var pe=i(P);J=r(pe,"The joint state of a sequence of "),S=l(pe,"SPAN",{});var ke=i(S);ke.forEach(t),Z=D(pe),W=l(pe,"EM",{});var Q=i(W);x=r(Q,"independent"),Q.forEach(t),$=r(pe," qubits can be written as "),M=l(pe,"SPAN",{});var me=i(M);me.forEach(t),O=r(pe,", where "),X=l(pe,"SPAN",{});var Le=i(X);Le.forEach(t),K=r(pe," are the coefficients associated with the state of the "),F=l(pe,"SPAN",{});var oe=i(F);oe.forEach(t),c=r(pe,"-th qubit as described above, and the operator "),N=l(pe,"SPAN",{});var se=i(N);se.forEach(t),te=r(pe," indicates that none of the qubits are entagled with each other."),pe.forEach(t)},m(he,re){w(he,n,re),e(n,p),w(he,m,re),w(he,f,re),e(f,y),e(f,d),e(d,_),e(f,g),e(f,E),e(E,I),e(f,v),e(f,k),e(k,V),e(f,H),e(f,L),L.innerHTML=G,e(f,U),e(f,A),A.innerHTML=B,e(f,q),w(he,C,re),w(he,P,re),e(P,J),e(P,S),S.innerHTML=z,e(P,Z),e(P,W),e(W,x),e(P,$),e(P,M),M.innerHTML=T,e(P,O),e(P,X),X.innerHTML=Ne,e(P,K),e(P,F),F.innerHTML=we,e(P,c),e(P,N),N.innerHTML=de,e(P,te),ee||(ye=[u(L,"mouseenter",a[0]),u(A,"mouseenter",a[1]),u(S,"mouseenter",a[2]),u(M,"mouseenter",a[3]),u(X,"mouseenter",a[4]),u(F,"mouseenter",a[5]),u(N,"mouseenter",a[6])],ee=!0)},p:at,i:at,o:at,d(he){he&&t(n),he&&t(m),he&&t(f),he&&t(C),he&&t(P),ee=!1,Ut(ye)}}}function _a(a){console.log(a)}function zl(a){return[()=>_a([]),()=>_a([]),()=>_a(["n"]),()=>_a(["n","\\alpha","\\beta"]),()=>_a(["\\alpha","\\beta","k"]),()=>_a(["k"]),()=>_a([])]}class Ql extends Ht{constructor(n){super(),qt(this,n,zl,Bl,Lt,{})}}function Cl(a){let n,p,m,f,y,d,_,g,E=h("\\phi \\alpha")+"",I,v,k,V=h("\\phi \\beta")+"",H,L,G,U=h("\\r \\alpha")+"",A,B,q,C,P,J,S,z,Z,W,x,$,M,T,O,X,Ne;f=new Fl({}),q=new js({props:{displayBloch:!1,phiAlpha:a[4],phiBeta:a[3],rAlpha:a[5]}}),P=new Sl({});function K(c){a[10](c)}function F(c){a[11](c)}let we={minX:1.5,polar:!0};return a[0]!==void 0&&(we.disabledScroll=a[0]),a[6]!==void 0&&(we.cameraPosition=a[6]),z=new Ko({props:we}),Es.push(()=>Ns(z,"disabledScroll",K)),Es.push(()=>Ns(z,"cameraPosition",F)),$=new js({props:{displayVectors:!1,phiAlpha:a[4],phiBeta:a[3],rAlpha:a[5],cameraPosition:a[6]}}),T=new Ql({}),{c(){n=o("h2"),p=s("Quantum Basics"),m=j(),Ye(f.$$.fragment),y=j(),d=o("div"),_=o("div"),g=new Se(!1),I=o("input"),v=j(),k=new Se(!1),H=o("input"),L=j(),G=new Se(!1),A=o("input"),B=j(),Ye(q.$$.fragment),C=j(),Ye(P.$$.fragment),J=j(),S=o("div"),Ye(z.$$.fragment),x=j(),Ye($.$$.fragment),M=j(),Ye(T.$$.fragment),this.h()},l(c){n=l(c,"H2",{});var N=i(n);p=r(N,"Quantum Basics"),N.forEach(t),m=D(c),xe(f.$$.fragment,c),y=D(c),d=l(c,"DIV",{class:!0});var de=i(d);_=l(de,"DIV",{class:!0});var te=i(_);g=Ae(te,!1),I=l(te,"INPUT",{class:!0,type:!0,min:!0,max:!0,step:!0}),v=D(te),k=Ae(te,!1),H=l(te,"INPUT",{class:!0,type:!0,min:!0,max:!0,step:!0}),L=D(te),G=Ae(te,!1),A=l(te,"INPUT",{class:!0,type:!0,min:!0,max:!0,step:!0}),te.forEach(t),B=D(de),xe(q.$$.fragment,de),de.forEach(t),C=D(c),xe(P.$$.fragment,c),J=D(c),S=l(c,"DIV",{class:!0});var ee=i(S);xe(z.$$.fragment,ee),x=D(ee),xe($.$$.fragment,ee),ee.forEach(t),M=D(c),xe(T.$$.fragment,c),this.h()},h(){g.a=I,fe(I,"class","slider"),fe(I,"type","range"),fe(I,"min",0),fe(I,"max",360),fe(I,"step",1),k.a=H,fe(H,"class","slider"),fe(H,"type","range"),fe(H,"min",0),fe(H,"max",360),fe(H,"step",1),G.a=A,fe(A,"class","slider"),fe(A,"type","range"),fe(A,"min",0),fe(A,"max",1),fe(A,"step",.01),fe(_,"class","cpanel svelte-vlthtg"),fe(d,"class","interaction"),fe(S,"class","interaction")},m(c,N){w(c,n,N),e(n,p),w(c,m,N),et(f,c,N),w(c,y,N),w(c,d,N),e(d,_),g.m(E,_),e(_,I),Qt(I,a[2]),e(_,v),k.m(V,_),e(_,H),Qt(H,a[1]),e(_,L),G.m(U,_),e(_,A),Qt(A,a[5]),e(d,B),et(q,d,null),w(c,C,N),et(P,c,N),w(c,J,N),w(c,S,N),et(z,S,null),e(S,x),et($,S,null),w(c,M,N),et(T,c,N),O=!0,X||(Ne=[u(I,"change",a[7]),u(I,"input",a[7]),u(H,"change",a[8]),u(H,"input",a[8]),u(A,"change",a[9]),u(A,"input",a[9])],X=!0)},p(c,[N]){N&4&&Qt(I,c[2]),N&2&&Qt(H,c[1]),N&32&&Qt(A,c[5]);const de={};N&16&&(de.phiAlpha=c[4]),N&8&&(de.phiBeta=c[3]),N&32&&(de.rAlpha=c[5]),q.$set(de);const te={};!Z&&N&1&&(Z=!0,te.disabledScroll=c[0],$s(()=>Z=!1)),!W&&N&64&&(W=!0,te.cameraPosition=c[6],$s(()=>W=!1)),z.$set(te);const ee={};N&16&&(ee.phiAlpha=c[4]),N&8&&(ee.phiBeta=c[3]),N&32&&(ee.rAlpha=c[5]),N&64&&(ee.cameraPosition=c[6]),$.$set(ee)},i(c){O||(ze(f.$$.fragment,c),ze(q.$$.fragment,c),ze(P.$$.fragment,c),ze(z.$$.fragment,c),ze($.$$.fragment,c),ze(T.$$.fragment,c),O=!0)},o(c){Ge(f.$$.fragment,c),Ge(q.$$.fragment,c),Ge(P.$$.fragment,c),Ge(z.$$.fragment,c),Ge($.$$.fragment,c),Ge(T.$$.fragment,c),O=!1},d(c){c&&t(n),c&&t(m),tt(f,c),c&&t(y),c&&t(d),tt(q),c&&t(C),tt(P,c),c&&t(J),c&&t(S),tt(z),tt($),c&&t(M),tt(T,c),X=!1,Ut(Ne)}}}function Wl(a,n,p){let m,f,y,d,_,g,{disabledScroll:E=!1}=n;function I(){f=ua(this.value),p(2,f)}function v(){y=ua(this.value),p(1,y)}function k(){d=ua(this.value),p(5,d)}function V(L){E=L,p(0,E)}function H(L){m=L,p(6,m)}return a.$$set=L=>{"disabledScroll"in L&&p(0,E=L.disabledScroll)},a.$$.update=()=>{a.$$.dirty&4&&p(4,_=f/180*Ds),a.$$.dirty&2&&p(3,g=y/180*Ds)},p(6,m={x:3,y:2,z:1.5}),p(2,f=15),p(1,y=310),p(5,d=.9),[E,y,f,g,_,d,m,I,v,k,V,H]}class jl extends Ht{constructor(n){super(),qt(this,n,Wl,Cl,Lt,{disabledScroll:0})}}const Dl='<a href="https://en.wikipedia.org/wiki/Periodic_function"><h3 class="text-lg font-semibold">Periodic function</h3></a><p>A <b>periodic function</b> is a function that repeats its values at regular intervals. For example, the trigonometric functions, which repeat at intervals of <span class="mwe-math-element"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/73efd1f6493490b058097060a572606d2c550a06" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align:-0.338ex;width:2.494ex;height:2.176ex" /></span> radians, are periodic functions. Periodic functions are used throughout science to describe oscillations, waves, and other phenomena that exhibit periodicity. Any function that is not periodic is called <b>aperiodic</b>.</p>';function Ul(a){let n;return{c(){n=s("periodic")},l(p){n=r(p,"periodic")},m(p,m){w(p,n,m)},d(p){p&&t(n)}}}function Kl(a){let n,p,m,f,y,d=h("f(r) = a^r \\mod N")+"",_,g,E,I,v,k,V,H=h("\\large a \\in \\mathbb{N}, 1 < a < N")+"",L,G,U=h("\\large a")+"",A,B,q=h("\\large N")+"",C,P,J=h("\\large 1")+"",S,z,Z=h("a")+"",W,x,$=h("\\large N")+"",M,T,O=h("\\large N")+"",X,Ne,K,F,we,c,N=h("\\large a^n \\mod{N}")+"",de,te,ee=h("\\large r \\in \\mathbb{N}, 1 < r < N")+"",ye,he,re=h("\\large a^r \\mod{N} = 1")+"",ne,$e,ce=h("\\large a")+"",mt,qe,ve,pe,ke,Q,me=h("\\large \\gcd({a^{\\frac{r}{2} - 1}}, N)")+"",Le,oe,se=h("\\large \\gcd({a^{\\frac{r}{2} + 1}}, N)")+"",Ie,Te,gt=h("\\gcd")+"",Ue,Ve,Et,Qe,Me,vt,Ce,Je,be,nt,Ke,He=h("r")+"",st,rt,Ct,ft,Ze,Gt=h("r")+"",_t,lt,Wt,Nt;return m=new sn({props:{hovertext:Dl,$$slots:{default:[Ul]},$$scope:{ctx:a}}}),{c(){n=o("p"),p=s("So, how does the algorithm work? Below you find a step-by-step description, for now without the quantum part. relies on the "),Ye(m.$$.fragment),f=s(" nature of "),y=o("span"),_=s("."),g=j(),E=o("ol"),I=o("li"),v=o("p"),k=s("Pick a random number "),V=o("span"),L=s(" and make sure that "),G=o("span"),A=s(" and "),B=o("span"),C=s(" are relative primes, meaning their greatest common divisor is "),P=o("span"),S=s(". (In case "),z=o("span"),W=s(" happens to be a factor of "),x=o("span"),M=s(", the entire problem is solved and no further steps are required, but that is highly unlikely for large "),T=o("span"),X=s(".)"),Ne=j(),K=o("li"),F=o("p"),we=s("Find the period of the function "),c=o("span"),de=s(". The period is the smallest "),te=o("span"),ye=s(" such that "),he=o("span"),ne=s(". If the period turns out to be odd, the entire procedure has to be repeated with a different "),$e=o("span"),mt=s(" parameter."),qe=j(),ve=o("li"),pe=o("p"),ke=s("If we're lucky and the period is even, the sought factors are "),Q=o("span"),Le=s(" and "),oe=o("span"),Ie=s(" (where "),Te=o("span"),Ue=s(" stands for "),Ve=o("em"),Et=s("greatest common divisor"),Qe=s("). For a detailed explanation of why this is true, see the video "),Me=o("a"),vt=s("Hacking at Quantum Speed with Shor's Algorithm"),Ce=s(" by PBS Infinite Series."),Je=j(),be=o("p"),nt=s("The problematic part of this procedure that is responsible for the above mentioned exponential scaling is finding the period "),Ke=o("span"),st=s(". Shor's algorithm utilizes a special quantum operation, the so called "),rt=o("em"),Ct=s("quantum Fourier transform"),ft=s(", to find "),Ze=o("span"),_t=s(" more quickly than any classical algorithm could. This is what we'll elaborate on in the next section."),this.h()},l(_e){n=l(_e,"P",{});var Re=i(n);p=r(Re,"So, how does the algorithm work? Below you find a step-by-step description, for now without the quantum part. relies on the "),xe(m.$$.fragment,Re),f=r(Re," nature of "),y=l(Re,"SPAN",{});var bt=i(y);bt.forEach(t),_=r(Re,"."),Re.forEach(t),g=D(_e),E=l(_e,"OL",{});var Oe=i(E);I=l(Oe,"LI",{});var jt=i(I);v=l(jt,"P",{});var Y=i(v);k=r(Y,"Pick a random number "),V=l(Y,"SPAN",{});var Pe=i(V);Pe.forEach(t),L=r(Y," and make sure that "),G=l(Y,"SPAN",{});var ue=i(G);ue.forEach(t),A=r(Y," and "),B=l(Y,"SPAN",{});var At=i(B);At.forEach(t),C=r(Y," are relative primes, meaning their greatest common divisor is "),P=l(Y,"SPAN",{});var it=i(P);it.forEach(t),S=r(Y,". (In case "),z=l(Y,"SPAN",{});var ma=i(z);ma.forEach(t),W=r(Y," happens to be a factor of "),x=l(Y,"SPAN",{});var pt=i(x);pt.forEach(t),M=r(Y,", the entire problem is solved and no further steps are required, but that is highly unlikely for large "),T=l(Y,"SPAN",{});var wt=i(T);wt.forEach(t),X=r(Y,".)"),Y.forEach(t),jt.forEach(t),Ne=D(Oe),K=l(Oe,"LI",{});var xt=i(K);F=l(xt,"P",{});var ot=i(F);we=r(ot,"Find the period of the function "),c=l(ot,"SPAN",{});var ae=i(c);ae.forEach(t),de=r(ot,". The period is the smallest "),te=l(ot,"SPAN",{});var Jt=i(te);Jt.forEach(t),ye=r(ot," such that "),he=l(ot,"SPAN",{});var Dt=i(he);Dt.forEach(t),ne=r(ot,". If the period turns out to be odd, the entire procedure has to be repeated with a different "),$e=l(ot,"SPAN",{});var kt=i($e);kt.forEach(t),mt=r(ot," parameter."),ot.forEach(t),xt.forEach(t),qe=D(Oe),ve=l(Oe,"LI",{});var Kt=i(ve);pe=l(Kt,"P",{});var le=i(pe);ke=r(le,"If we're lucky and the period is even, the sought factors are "),Q=l(le,"SPAN",{});var Xe=i(Q);Xe.forEach(t),Le=r(le," and "),oe=l(le,"SPAN",{});var dt=i(oe);dt.forEach(t),Ie=r(le," (where "),Te=l(le,"SPAN",{});var Zt=i(Te);Zt.forEach(t),Ue=r(le," stands for "),Ve=l(le,"EM",{});var Ft=i(Ve);Et=r(Ft,"greatest common divisor"),Ft.forEach(t),Qe=r(le,"). For a detailed explanation of why this is true, see the video "),Me=l(le,"A",{href:!0});var ea=i(Me);vt=r(ea,"Hacking at Quantum Speed with Shor's Algorithm"),ea.forEach(t),Ce=r(le," by PBS Infinite Series."),le.forEach(t),Kt.forEach(t),Oe.forEach(t),Je=D(_e),be=l(_e,"P",{});var $t=i(be);nt=r($t,"The problematic part of this procedure that is responsible for the above mentioned exponential scaling is finding the period "),Ke=l($t,"SPAN",{});var Rt=i(Ke);Rt.forEach(t),st=r($t,". Shor's algorithm utilizes a special quantum operation, the so called "),rt=l($t,"EM",{});var ge=i(rt);Ct=r(ge,"quantum Fourier transform"),ge.forEach(t),ft=r($t,", to find "),Ze=l($t,"SPAN",{});var Yt=i(Ze);Yt.forEach(t),_t=r($t," more quickly than any classical algorithm could. This is what we'll elaborate on in the next section."),$t.forEach(t),this.h()},h(){fe(Me,"href","https://www.youtube.com/watch?v=wUwZZaI5u0c&t=731s")},m(_e,Re){w(_e,n,Re),e(n,p),et(m,n,null),e(n,f),e(n,y),y.innerHTML=d,e(n,_),w(_e,g,Re),w(_e,E,Re),e(E,I),e(I,v),e(v,k),e(v,V),V.innerHTML=H,e(v,L),e(v,G),G.innerHTML=U,e(v,A),e(v,B),B.innerHTML=q,e(v,C),e(v,P),P.innerHTML=J,e(v,S),e(v,z),z.innerHTML=Z,e(v,W),e(v,x),x.innerHTML=$,e(v,M),e(v,T),T.innerHTML=O,e(v,X),e(E,Ne),e(E,K),e(K,F),e(F,we),e(F,c),c.innerHTML=N,e(F,de),e(F,te),te.innerHTML=ee,e(F,ye),e(F,he),he.innerHTML=re,e(F,ne),e(F,$e),$e.innerHTML=ce,e(F,mt),e(E,qe),e(E,ve),e(ve,pe),e(pe,ke),e(pe,Q),Q.innerHTML=me,e(pe,Le),e(pe,oe),oe.innerHTML=se,e(pe,Ie),e(pe,Te),Te.innerHTML=gt,e(pe,Ue),e(pe,Ve),e(Ve,Et),e(pe,Qe),e(pe,Me),e(Me,vt),e(pe,Ce),w(_e,Je,Re),w(_e,be,Re),e(be,nt),e(be,Ke),Ke.innerHTML=He,e(be,st),e(be,rt),e(rt,Ct),e(be,ft),e(be,Ze),Ze.innerHTML=Gt,e(be,_t),lt=!0,Wt||(Nt=[u(y,"mouseenter",a[0]),u(V,"mouseenter",a[1]),u(G,"mouseenter",a[2]),u(B,"mouseenter",a[3]),u(P,"mouseenter",a[4]),u(z,"mouseenter",a[5]),u(x,"mouseenter",a[6]),u(T,"mouseenter",a[7]),u(c,"mouseenter",a[8]),u(te,"mouseenter",a[9]),u(he,"mouseenter",a[10]),u($e,"mouseenter",a[11]),u(Q,"mouseenter",a[12]),u(oe,"mouseenter",a[13]),u(Te,"mouseenter",a[14]),u(Ke,"mouseenter",a[15]),u(Ze,"mouseenter",a[16])],Wt=!0)},p(_e,[Re]){const bt={};Re&131072&&(bt.$$scope={dirty:Re,ctx:_e}),m.$set(bt)},i(_e){lt||(ze(m.$$.fragment,_e),lt=!0)},o(_e){Ge(m.$$.fragment,_e),lt=!1},d(_e){_e&&t(n),tt(m),_e&&t(g),_e&&t(E),_e&&t(Je),_e&&t(be),Wt=!1,Ut(Nt)}}}function yt(a){console.log(a)}function Rl(a){return[()=>yt(["r","a","N","f"]),()=>yt(["a","N"]),()=>yt(["a"]),()=>yt(["N"]),()=>yt([]),()=>yt(["a"]),()=>yt(["N"]),()=>yt(["N"]),()=>yt(["n","a","N"]),()=>yt(["r","N"]),()=>yt(["r","a","N"]),()=>yt(["a"]),()=>yt(["r","a","N"]),()=>yt(["r","a","N"]),()=>yt([]),()=>yt(["r"]),()=>yt(["r"])]}class Ol extends Ht{constructor(n){super(),qt(this,n,Rl,Kl,Lt,{})}}function Xl(a){let n,p,m,f,y;return f=new Ol({}),{c(){n=o("h2"),p=s("Shor's Algorithm"),m=j(),Ye(f.$$.fragment)},l(d){n=l(d,"H2",{});var _=i(n);p=r(_,"Shor's Algorithm"),_.forEach(t),m=D(d),xe(f.$$.fragment,d)},m(d,_){w(d,n,_),e(n,p),w(d,m,_),et(f,d,_),y=!0},p:at,i(d){y||(ze(f.$$.fragment,d),y=!0)},o(d){Ge(f.$$.fragment,d),y=!1},d(d){d&&t(n),d&&t(m),tt(f,d)}}}class Gl extends Ht{constructor(n){super(),qt(this,n,null,Xl,Lt,{})}}function Jl(a){let n,p,m,f,y,d,_,g,E,I,v,k,V,H,L,G,U,A,B,q,C;V=new cl({});function P(S){a[1](S)}let J={};return a[0]!==void 0&&(J.disabledScroll=a[0]),L=new jl({props:J}),Es.push(()=>Ns(L,"disabledScroll",P)),A=new $l({}),q=new Gl({}),{c(){n=o("div"),p=j(),m=o("main"),f=o("h1"),y=s("Interactive Quantum Computing"),d=j(),_=o("p"),g=s("This page intends to introduce concepts, connect them and derive a practical use case"),E=j(),I=o("h2"),v=s("Clickable Table of Contents"),k=j(),Ye(V.$$.fragment),H=j(),Ye(L.$$.fragment),U=j(),Ye(A.$$.fragment),B=j(),Ye(q.$$.fragment),this.h()},l(S){n=l(S,"DIV",{class:!0}),i(n).forEach(t),p=D(S),m=l(S,"MAIN",{class:!0});var z=i(m);f=l(z,"H1",{});var Z=i(f);y=r(Z,"Interactive Quantum Computing"),Z.forEach(t),d=D(z),_=l(z,"P",{});var W=i(_);g=r(W,"This page intends to introduce concepts, connect them and derive a practical use case"),W.forEach(t),E=D(z),I=l(z,"H2",{});var x=i(I);v=r(x,"Clickable Table of Contents"),x.forEach(t),k=D(z),xe(V.$$.fragment,z),H=D(z),xe(L.$$.fragment,z),U=D(z),xe(A.$$.fragment,z),B=D(z),xe(q.$$.fragment,z),z.forEach(t),this.h()},h(){fe(n,"class","sidebar"),fe(m,"class","svelte-1tkfm11"),Ws(m,"scroll-lock",a[0])},m(S,z){w(S,n,z),w(S,p,z),w(S,m,z),e(m,f),e(f,y),e(m,d),e(m,_),e(_,g),e(m,E),e(m,I),e(I,v),e(m,k),et(V,m,null),e(m,H),et(L,m,null),e(m,U),et(A,m,null),e(m,B),et(q,m,null),C=!0},p(S,[z]){const Z={};!G&&z&1&&(G=!0,Z.disabledScroll=S[0],$s(()=>G=!1)),L.$set(Z),z&1&&Ws(m,"scroll-lock",S[0])},i(S){C||(ze(V.$$.fragment,S),ze(L.$$.fragment,S),ze(A.$$.fragment,S),ze(q.$$.fragment,S),C=!0)},o(S){Ge(V.$$.fragment,S),Ge(L.$$.fragment,S),Ge(A.$$.fragment,S),Ge(q.$$.fragment,S),C=!1},d(S){S&&t(n),S&&t(p),S&&t(m),tt(V),tt(L),tt(A),tt(q)}}}const ei=!0;function Zl(a,n,p){let m=!1;function f(y){m=y,p(0,m)}return[m,f]}class ti extends Ht{constructor(n){super(),qt(this,n,Zl,Jl,Lt,{})}}export{ti as default,ei as prerender};
