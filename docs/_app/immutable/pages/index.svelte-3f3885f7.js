import{S as wa,i as ga,s as ya,l,u as s,a as M,L as wt,e as to,m as h,p as u,v as o,h as a,c as S,M as gt,q as B,b as g,H as t,N as oa,O as p,P as Th,Q as Dr,R as Ph,n as js,T as kr,F as Mh,I as Sh,J as qh,K as Ah,f as be,t as Ne,U as eh,V as Hh,x as Pe,y as Me,z as Se,C as qe,W as ds,X as bs,g as Lh,d as xh,Y as Pl,w as wl,Z as Ml,r as Ih}from"../chunks/index-760eefc7.js";import{m as f,g as $o,a as Wo,p as Sl,e as Fh,b as Qh,c as ll,i as zh,Q as Vh}from"../chunks/Qbit-e7529a99.js";function Bh(e){let n,r,i,m=f(`K = ${e[6]}`)+"",d,_,c=f("r")+"",v,b,E=f("a^r \\mod N = 1")+"",w,N,$,I,Y,U=f("r")+"",L,C,V=f(`${e[1]}^{${e[2]}} \\mod ${e[0]} = 1`)+"",H,q,D=f("m")+"",X,A,se=f(`${e[1]}^{${e[2]}} = m \\cdot ${e[0]} + 1`)+"",ee,j;function T(R,Q){return R[2]%2==0?jh:Rh}let x=T(e),ie=x(e);return{c(){n=l("p"),r=s("As "),i=new wt(!1),d=s(", the value of "),_=new wt(!1),v=s(" in "),b=new wt(!1),w=s(` will
		be informative.`),N=M(),$=l("p"),I=s(`As these are all relatively small numbers, we can try all relevant possible values for
		`),Y=new wt(!1),L=s(" rather quickly and find that "),C=new wt(!1),H=s(` which means
		that there is an `),q=new wt(!1),X=s(" for which "),A=new wt(!1),ee=M(),j=l("p"),ie.c(),this.h()},l(R){n=h(R,"P",{});var Q=u(n);r=o(Q,"As "),i=gt(Q,!1),d=o(Q,", the value of "),_=gt(Q,!1),v=o(Q," in "),b=gt(Q,!1),w=o(Q,` will
		be informative.`),Q.forEach(a),N=S(R),$=h(R,"P",{});var G=u($);I=o(G,`As these are all relatively small numbers, we can try all relevant possible values for
		`),Y=gt(G,!1),L=o(G," rather quickly and find that "),C=gt(G,!1),H=o(G,` which means
		that there is an `),q=gt(G,!1),X=o(G," for which "),A=gt(G,!1),G.forEach(a),ee=S(R),j=h(R,"P",{});var me=u(j);ie.l(me),me.forEach(a),this.h()},h(){i.a=d,_.a=v,b.a=w,Y.a=L,C.a=H,q.a=X,A.a=null},m(R,Q){g(R,n,Q),t(n,r),i.m(m,n),t(n,d),_.m(c,n),t(n,v),b.m(E,n),t(n,w),g(R,N,Q),g(R,$,Q),t($,I),Y.m(U,$),t($,L),C.m(V,$),t($,H),q.m(D,$),t($,X),A.m(se,$),g(R,ee,Q),g(R,j,Q),ie.m(j,null)},p(R,Q){Q&64&&m!==(m=f(`K = ${R[6]}`)+"")&&i.p(m),Q&7&&V!==(V=f(`${R[1]}^{${R[2]}} \\mod ${R[0]} = 1`)+"")&&C.p(V),Q&7&&se!==(se=f(`${R[1]}^{${R[2]}} = m \\cdot ${R[0]} + 1`)+"")&&A.p(se),x===(x=T(R))&&ie?ie.p(R,Q):(ie.d(1),ie=x(R),ie&&(ie.c(),ie.m(j,null)))},d(R){R&&a(n),R&&a(N),R&&a($),R&&a(ee),R&&a(j),ie.d()}}}function Ch(e){let n,r,i,m=f("K \\neq 1")+"",d,_,c=f("a")+"",v,b,E=f("N")+"",w,N,$=f(`K=${e[6]}`)+"",I,Y,U=f("a")+"",L;return{c(){n=l("p"),r=s("As in this case "),i=new wt(!1),d=s(", a new "),_=new wt(!1),v=s(` is needed. Or to put a more positive
		spin on it, we instantly can found a prime factor for `),b=new wt(!1),w=s(`, which in fact
		`),N=new wt(!1),I=s(` is. However, in order to see the whole algorithm in action, we should choose
		a new `),Y=new wt(!1),L=s("."),this.h()},l(C){n=h(C,"P",{});var V=u(n);r=o(V,"As in this case "),i=gt(V,!1),d=o(V,", a new "),_=gt(V,!1),v=o(V,` is needed. Or to put a more positive
		spin on it, we instantly can found a prime factor for `),b=gt(V,!1),w=o(V,`, which in fact
		`),N=gt(V,!1),I=o(V,` is. However, in order to see the whole algorithm in action, we should choose
		a new `),Y=gt(V,!1),L=o(V,"."),V.forEach(a),this.h()},h(){i.a=d,_.a=v,b.a=w,N.a=I,Y.a=L},m(C,V){g(C,n,V),t(n,r),i.m(m,n),t(n,d),_.m(c,n),t(n,v),b.m(E,n),t(n,w),N.m($,n),t(n,I),Y.m(U,n),t(n,L)},p(C,V){V&64&&$!==($=f(`K=${C[6]}`)+"")&&N.p($)},d(C){C&&a(n)}}}function Rh(e){let n,r=f("r")+"",i,m,d=f("a")+"",_;return{c(){n=new wt(!1),i=s(" is odd, we need a new "),m=new wt(!1),_=s("."),this.h()},l(c){n=gt(c,!1),i=o(c," is odd, we need a new "),m=gt(c,!1),_=o(c,"."),this.h()},h(){n.a=i,m.a=_},m(c,v){n.m(r,c,v),g(c,i,v),m.m(d,c,v),g(c,_,v)},p:js,d(c){c&&n.d(),c&&a(i),c&&m.d(),c&&a(_)}}}function jh(e){let n,r=f("r")+"",i,m,d=f("b = a^{\\frac{r}{2}}")+"",_,c,v=f("a^r = m \\cdot N + 1 \\Rightarrow b^2-1 = (b + 1)(b - 1) = m \\cdot N")+"",b,E,w=f(`b = ${e[5]}`)+"",N,$,I=f("N")+"",Y,U,L=f("b-1")+"",C,V,H=f("b+1")+"",q,D,X=f(`${$o(e[0],e[5]-1)}`)+"",A,se,ee=f(`${$o(e[0],e[5]+1)}`)+"",j;return{c(){n=new wt(!1),i=s(" is even, so we can create "),m=new wt(!1),_=s(`, and expand
			the above so that
			`),c=new wt(!1),b=s(`. In this
			case, as `),E=new wt(!1),N=s(`, we can calculate the greatest common divisor for
			`),$=new wt(!1),Y=s(" with "),U=new wt(!1),C=s(" and "),V=new wt(!1),q=s(` very quickly, which are
			`),D=new wt(!1),A=s(" and "),se=new wt(!1),j=s(" respectively"),this.h()},l(T){n=gt(T,!1),i=o(T," is even, so we can create "),m=gt(T,!1),_=o(T,`, and expand
			the above so that
			`),c=gt(T,!1),b=o(T,`. In this
			case, as `),E=gt(T,!1),N=o(T,`, we can calculate the greatest common divisor for
			`),$=gt(T,!1),Y=o(T," with "),U=gt(T,!1),C=o(T," and "),V=gt(T,!1),q=o(T,` very quickly, which are
			`),D=gt(T,!1),A=o(T," and "),se=gt(T,!1),j=o(T," respectively"),this.h()},h(){n.a=i,m.a=_,c.a=b,E.a=N,$.a=Y,U.a=C,V.a=q,D.a=A,se.a=j},m(T,x){n.m(r,T,x),g(T,i,x),m.m(d,T,x),g(T,_,x),c.m(v,T,x),g(T,b,x),E.m(w,T,x),g(T,N,x),$.m(I,T,x),g(T,Y,x),U.m(L,T,x),g(T,C,x),V.m(H,T,x),g(T,q,x),D.m(X,T,x),g(T,A,x),se.m(ee,T,x),g(T,j,x)},p(T,x){x&32&&w!==(w=f(`b = ${T[5]}`)+"")&&E.p(w),x&33&&X!==(X=f(`${$o(T[0],T[5]-1)}`)+"")&&D.p(X),x&33&&ee!==(ee=f(`${$o(T[0],T[5]+1)}`)+"")&&se.p(ee)},d(T){T&&n.d(),T&&a(i),T&&m.d(),T&&a(_),T&&c.d(),T&&a(b),T&&E.d(),T&&a(N),T&&$.d(),T&&a(Y),T&&U.d(),T&&a(C),T&&V.d(),T&&a(q),T&&D.d(),T&&a(A),T&&se.d(),T&&a(j)}}}function Dh(e){let n,r,i,m,d,_,c,v,b,E,w,N,$,I,Y,U,L,C=f(` = ${e[3]} \\cdot ${e[4]}`)+"",V,H,q,D,X=f(`a = ${e[1]}`)+"",A,se,ee=f(`N = ${e[0]}`)+"",j,T,x=f(`K = ${e[6]}`)+"",ie,R,Q,G,me;function ae(K,P){return K[6]!=1?Ch:Bh}let ze=ae(e),le=ze(e);return{c(){n=l("div"),r=l("div"),i=s("a:"),m=M(),d=l("input"),c=M(),v=l("input"),E=M(),w=l("div"),N=s("N:"),$=M(),I=l("input"),U=M(),L=l("div"),V=M(),H=l("p"),q=s("The greatest common divisor of "),D=new wt(!1),A=s(" and "),se=new wt(!1),j=s(` is
	`),T=new wt(!1),ie=s(". This is very quick to calculate."),R=M(),le.c(),Q=to(),this.h()},l(K){n=h(K,"DIV",{class:!0});var P=u(n);r=h(P,"DIV",{class:!0});var re=u(r);i=o(re,"a:"),re.forEach(a),m=S(P),d=h(P,"INPUT",{class:!0,type:!0,min:!0,max:!0}),c=S(P),v=h(P,"INPUT",{class:!0,type:!0,min:!0,max:!0}),E=S(P),w=h(P,"DIV",{class:!0});var ce=u(w);N=o(ce,"N:"),ce.forEach(a),$=S(P),I=h(P,"INPUT",{class:!0,type:!0,min:!0,max:!0}),U=S(P),L=h(P,"DIV",{id:!0,class:!0});var ct=u(L);ct.forEach(a),P.forEach(a),V=S(K),H=h(K,"P",{});var ke=u(H);q=o(ke,"The greatest common divisor of "),D=gt(ke,!1),A=o(ke," and "),se=gt(ke,!1),j=o(ke,` is
	`),T=gt(ke,!1),ie=o(ke,". This is very quick to calculate."),ke.forEach(a),R=S(K),le.l(K),Q=to(),this.h()},h(){B(r,"class","varlabel svelte-1lqus27"),B(d,"class","numsel svelte-1lqus27"),B(d,"type","number"),B(d,"min",2),B(d,"max",_=e[0]-1),B(v,"class","slider svelte-1lqus27"),B(v,"type","range"),B(v,"min",2),B(v,"max",b=e[0]-1),B(w,"class","varlabel svelte-1lqus27"),B(I,"class","numsel svelte-1lqus27"),B(I,"type","number"),B(I,"min","1"),B(I,"max",e[7]),B(L,"id","decomp"),B(L,"class","svelte-1lqus27"),B(n,"class","cpanel svelte-1lqus27"),D.a=A,se.a=j,T.a=ie},m(K,P){g(K,n,P),t(n,r),t(r,i),t(n,m),t(n,d),oa(d,e[1]),t(n,c),t(n,v),oa(v,e[1]),t(n,E),t(n,w),t(w,N),t(n,$),t(n,I),oa(I,e[0]),t(n,U),t(n,L),L.innerHTML=C,g(K,V,P),g(K,H,P),t(H,q),D.m(X,H),t(H,A),se.m(ee,H),t(H,j),T.m(x,H),t(H,ie),g(K,R,P),le.m(K,P),g(K,Q,P),G||(me=[p(d,"input",e[10]),p(v,"change",e[11]),p(v,"input",e[11]),Th(Y=e[8].call(null,I,e[0])),p(I,"input",e[12])],G=!0)},p(K,[P]){P&1&&_!==(_=K[0]-1)&&B(d,"max",_),P&2&&Dr(d.value)!==K[1]&&oa(d,K[1]),P&1&&b!==(b=K[0]-1)&&B(v,"max",b),P&2&&oa(v,K[1]),Y&&Ph(Y.update)&&P&1&&Y.update.call(null,K[0]),P&1&&Dr(I.value)!==K[0]&&oa(I,K[0]),P&24&&C!==(C=f(` = ${K[3]} \\cdot ${K[4]}`)+"")&&(L.innerHTML=C),P&2&&X!==(X=f(`a = ${K[1]}`)+"")&&D.p(X),P&1&&ee!==(ee=f(`N = ${K[0]}`)+"")&&se.p(ee),P&64&&x!==(x=f(`K = ${K[6]}`)+"")&&T.p(x),ze===(ze=ae(K))&&le?le.p(K,P):(le.d(1),le=ze(K),le&&(le.c(),le.m(Q.parentNode,Q)))},i:js,o:js,d(K){K&&a(n),K&&a(V),K&&a(H),K&&a(R),le.d(K),K&&a(Q),G=!1,kr(me)}}}function Wh(e,n){for(let r=1;r<n;r++){let i=e%n;for(let m=1;m<r;m++)i=i*e%n;if(i==1)return r}return 0}function Uh(e,n,r){let i,m,d,{bits:_=7}=n,c=Math.pow(2,_)-1;const v=new Set;for(let H=2;H<=c/2;H++){let q=!0;v.forEach(function(D){H%D==0&&(q=!1)}),q&&v.add(H)}let b=39,E=b,w=7,N,$;function I(H){for(const q of v)if(v.has(H/q))return r(3,N=q),r(4,$=H/q),!0;return!1}I(b);function Y(H,q){return{update(D){let X=D-E;if(X!=0){for(;!I(D);)if(D+=X,D<=2||D>=c)return;U(D)}}}}function U(H){r(0,b=H),E=b,r(1,w=w>=b?b-1:w)}function L(){w=Dr(this.value),r(1,w)}function C(){w=Dr(this.value),r(1,w)}function V(){b=Dr(this.value),r(0,b)}return e.$$set=H=>{"bits"in H&&r(9,_=H.bits)},e.$$.update=()=>{e.$$.dirty&3&&r(2,i=Wh(w,b)),e.$$.dirty&3&&r(6,m=$o(b,w)),e.$$.dirty&6&&r(5,d=Math.pow(w,i/2))},[b,w,i,N,$,d,m,c,Y,_,L,C,V]}class Oh extends wa{constructor(n){super(),ga(this,n,Uh,Dh,ya,{bits:9})}}function Gh(e){return e<.5?4*e*e*e:.5*Math.pow(2*e-2,3)+1}function Kh(e){const n=e-1;return n*n*n+1}function Yh(e){return--e*e*e*e*e+1}function Zh(e,{delay:n=0,duration:r=400,easing:i=Kh,start:m=0,opacity:d=0}={}){const _=getComputedStyle(e),c=+_.opacity,v=_.transform==="none"?"":_.transform,b=1-m,E=c*(1-d);return{delay:n,duration:r,easing:i,css:(w,N)=>`
			transform: ${v} scale(${1-b*N});
			opacity: ${c-E*N}
		`}}function ql(e,{delay:n=0,speed:r,duration:i,easing:m=Gh}={}){let d=e.getTotalLength();const _=getComputedStyle(e);return _.strokeLinecap!=="butt"&&(d+=parseInt(_.strokeWidth)),i===void 0?r===void 0?i=800:i=d/r:typeof i=="function"&&(i=i(d)),{delay:n,duration:i,easing:m,css:(c,v)=>`stroke-dasharray: ${c*d} ${v*d}`}}function Al(e){let n,r;return{c(){n=l("div"),this.h()},l(i){n=h(i,"DIV",{class:!0});var m=u(n);m.forEach(a),this.h()},h(){B(n,"class","hover-inner svelte-5qv8za")},m(i,m){g(i,n,m),n.innerHTML=e[0]},p(i,m){e=i,m&1&&(n.innerHTML=e[0])},i(i){r||eh(()=>{r=Hh(n,Zh,{duration:150,easing:Yh,opacity:0}),r.start()})},o:js,d(i){i&&a(n)}}}function Jh(e){let n,r,i,m;const d=e[5].default,_=Mh(d,e,e[4],null);let c=e[1]&&Al(e);return{c(){n=l("span"),_&&_.c(),c&&c.c(),this.h()},l(v){n=h(v,"SPAN",{class:!0});var b=u(n);_&&_.l(b),c&&c.l(b),b.forEach(a),this.h()},h(){B(n,"class","hover-outer svelte-5qv8za")},m(v,b){g(v,n,b),_&&_.m(n,null),c&&c.m(n,null),r=!0,i||(m=[p(n,"mouseenter",e[2]),p(n,"mouseleave",e[3])],i=!0)},p(v,[b]){_&&_.p&&(!r||b&16)&&Sh(_,d,v,v[4],r?Ah(d,v[4],b,null):qh(v[4]),null),v[1]?c?(c.p(v,b),b&2&&be(c,1)):(c=Al(v),c.c(),be(c,1),c.m(n,null)):c&&(c.d(1),c=null)},i(v){r||(be(_,v),be(c),r=!0)},o(v){Ne(_,v),r=!1},d(v){v&&a(n),_&&_.d(v),c&&c.d(),i=!1,kr(m)}}}function Xh(e,n,r){let{$$slots:i={},$$scope:m}=n,{hovertext:d}=n,_=!1;const c=()=>r(1,_=!0),v=()=>r(1,_=!1);return e.$$set=b=>{"hovertext"in b&&r(0,d=b.hovertext),"$$scope"in b&&r(4,m=b.$$scope)},[d,_,c,v,m,i]}class it extends wa{constructor(n){super(),ga(this,n,Xh,Jh,ya,{hovertext:0})}}const eu=`<a href="https://en.wikipedia.org/wiki/Semiprime"><h3 class="text-lg font-semibold">Semiprime</h3></a><p>In mathematics, a <b>semiprime</b> is a natural number that is the product of exactly two prime numbers. The two primes in the product may equal each other, so the semiprimes include the squares of prime numbers.
Because there are infinitely many prime numbers, there are also infinitely many semiprimes. Semiprimes are also called <b>biprimes</b>.</p>`,tu='<a href="https://en.wikipedia.org/wiki/General_number_field_sieve"><h3>General number field sieve</h3></a><p>In number theory, the <b>general number field sieve</b> (<b>GNFS</b>) is the most efficient classical algorithm known for factoring integers larger than <span class="texhtml ">10<sup>100</sup></span>. Heuristically, its complexity for factoring an integer <span class="texhtml mvar" style="font-style:italic">n</span> (consisting of <span class="texhtml ">\u230Alog<sub>2</sub> <span class="texhtml mvar" style="font-style:italic">n</span>\u230B + 1</span> bits) is of the form</p><dl><dd><span class="mwe-math-element"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/fcc5450b9f039008c0a728e15b6c66f24dafbb30" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align:-2.505ex;width:57.324ex;height:6.343ex" /></span></dd></dl>',nu='<a href="https://en.wikipedia.org/wiki/Exponential_function"><h3>Exponential function</h3></a><p>The <b>exponential function</b> is a mathematical function denoted by <span class="mwe-math-element"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/9dd9b17af32bc3cffe927507c7bccf4e2a96f585" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align:-0.838ex;width:14.207ex;height:2.843ex" /></span> or <span class="mwe-math-element"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/841c0d168e64191c45a45e54c7e447defd17ec6a" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align:-0.338ex;width:2.256ex;height:2.343ex" /></span>. Unless otherwise specified, the term generally refers to the positive-valued function of a real variable, although it can be extended to the complex numbers or generalized to other mathematical objects like matrices or Lie algebras. The exponential function originated from the notion of exponentiation, but modern definitions allow it to be rigorously extended to all real arguments, including irrational numbers. Its ubiquitous occurrence in pure and applied mathematics led mathematician Walter Rudin to opine that the exponential function is "the most important function in mathematics".</p>',au='<a href="https://en.wikipedia.org/wiki/Quantum_computing"><h3>Quantum computing</h3></a><p><b>Quantum computing</b> is a type of computation whose operations can harness the phenomena of quantum mechanics, such as superposition, interference, and entanglement. Devices that perform quantum computations are known as <b>quantum computers</b>. Though current quantum computers are too small to outperform usual (classical) computers for practical applications, larger realizations are believed to be capable of solving certain computational problems, such as integer factorization, substantially faster than classical computers. The study of quantum computing is a subfield of quantum information science.</p>',ru=`<a href="https://en.wikipedia.org/wiki/Cubic_function"><h3>Cubic function</h3></a><p>In mathematics, a <b>cubic function</b> is a function of the form <span class="mwe-math-element"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/9cc573924b3e958061c7436c149efc76e4098668" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align:-0.838ex;width:26.585ex;height:3.176ex" /></span>
where the coefficients <span class="texhtml mvar" style="font-style:italic">a</span>, <span class="texhtml mvar" style="font-style:italic">b</span>, <span class="texhtml mvar" style="font-style:italic">c</span>, and <span class="texhtml mvar" style="font-style:italic">d</span> are complex numbers, and the variable <span class="texhtml mvar" style="font-style:italic">x</span> takes real values, and <span class="mwe-math-element"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f455a7f96d74aa94573d8e32da3b240ab0aa294f" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align:-0.838ex;width:5.491ex;height:2.676ex" /></span>. In other words, it is both a polynomial function of degree three, and a real function. In particular, the domain and the codomain are the set of the real numbers.</p>`,su='<a href="https://en.wikipedia.org/wiki/Computational_complexity"><h3 class="text-lg font-semibold">Computational complexity</h3></a><p>In computer science, the <b>computational complexity</b> or simply <b>complexity</b> of an algorithm is the amount of resources required to run it. Particular focus is given to time and memory requirements. The complexity of a problem is the complexity of the best algorithms that allow solving the problem.</p>',ou=`<a href="https://en.wikipedia.org/wiki/Linear_function"><h3>Linear function</h3></a><p>In mathematics, the term <b>linear function</b> refers to two distinct but related notions:</p><ul><li>In calculus and related areas, a linear function is a function whose graph is a straight line, that is, a polynomial function of degree zero or one. For distinguishing such a linear function from the other concept, the term affine function is often used.</li>
<li>In linear algebra, mathematical analysis, and functional analysis, a linear function is a linear map.</li></ul>`;function iu(e){let n;return{c(){n=s("semiprime")},l(r){n=o(r,"semiprime")},m(r,i){g(r,n,i)},d(r){r&&a(n)}}}function lu(e){let n;return{c(){n=s("number field sieve")},l(r){n=o(r,"number field sieve")},m(r,i){g(r,n,i)},d(r){r&&a(n)}}}function hu(e){let n;return{c(){n=s("exponentially")},l(r){n=o(r,"exponentially")},m(r,i){g(r,n,i)},d(r){r&&a(n)}}}function uu(e){let n;return{c(){n=s("quantum computer")},l(r){n=o(r,"quantum computer")},m(r,i){g(r,n,i)},d(r){r&&a(n)}}}function mu(e){let n;return{c(){n=s("cubically")},l(r){n=o(r,"cubically")},m(r,i){g(r,n,i)},d(r){r&&a(n)}}}function fu(e){let n;return{c(){n=s("Computational complexity")},l(r){n=o(r,"Computational complexity")},m(r,i){g(r,n,i)},d(r){r&&a(n)}}}function pu(e){let n;return{c(){n=s("linearly")},l(r){n=o(r,"linearly")},m(r,i){g(r,n,i)},d(r){r&&a(n)}}}function cu(e){let n,r,i,m,d,_,c=f("p, q \\in \\mathbb{P}")+"",v,b,E,w,N=f("N \\in \\mathbb{N}")+"",$,I,Y=f("N = p \\cdot q")+"",U,L,C=f("15,")+"",V,H,q=f("3")+"",D,X,A=f("5.")+"",se,ee,j=f("62615533")+"",T,x,ie,R,Q,G,me,ae,ze,le,K=f("100")+"",P,re,ce=f("3")+"",ct,ke,Ve=f("200")+"",yt,fe,Le=f("5")+"",rt,ve,Ae,Ke,_t,ne,_e,st,je,sn;return b=new it({props:{hovertext:eu,$$slots:{default:[iu]},$$scope:{ctx:e}}}),x=new it({props:{hovertext:tu,$$slots:{default:[lu]},$$scope:{ctx:e}}}),R=new it({props:{hovertext:nu,$$slots:{default:[hu]},$$scope:{ctx:e}}}),G=new it({props:{hovertext:au,$$slots:{default:[uu]},$$scope:{ctx:e}}}),ae=new it({props:{hovertext:ru,$$slots:{default:[mu]},$$scope:{ctx:e}}}),Ke=new it({props:{hovertext:su,$$slots:{default:[fu]},$$scope:{ctx:e}}}),ne=new it({props:{hovertext:ou,$$slots:{default:[pu]},$$scope:{ctx:e}}}),{c(){n=l("h2"),r=s("Description of the problem"),i=M(),m=l("p"),d=s("We would like to find the prime factors "),_=l("span"),v=s(" of a large "),Pe(b.$$.fragment),E=M(),w=l("span"),$=s(" (so that "),I=l("span"),U=s("). Finding these factors for a small number, such as "),L=l("span"),V=s(" is quite easy. In fact, you may figure it out just by looking at it and recalling your grade school studies: the factors are "),H=l("span"),D=s(" and "),X=l("span"),se=s(" But what are the prime factors of, say, "),ee=l("span"),T=s("? It turns out that, using the best known classical (meaning non-quantum) algorithm (the so called "),Pe(x.$$.fragment),ie=s("), solving the factoring problem scales "),Pe(R.$$.fragment),Q=s(" with the number of digits of the semiprime that we want to factor. With the help of Shor's algorithm and a sufficiently large "),Pe(G.$$.fragment),me=s(", the same problem scales roughly "),Pe(ae.$$.fragment),ze=s(" with the number of digits. (In fact, the algorithm does slighly better than that, but the precise formula is a bit complicated and is beside the point.) To illustrate what this means in practical terms, imagine the following. If factoring a "),le=l("span"),P=s("-digit number with Shor's algorithm on a quantum computer takes one second, factoring the same number with the number field sieve on a classical computer takes more than "),re=l("span"),ct=s(" hours. If we now try with a "),ke=l("span"),yt=s("-digit number, Shor's algorithm finishes in roughly "),fe=l("span"),rt=s(" seconds, while the classical solution would take more than a year!"),ve=M(),Ae=l("p"),Pe(Ke.$$.fragment),_t=s(` refers to how the time - or number of elementary operations - required to solve a given problem algorithmically grows with the size of the input. Let's say you have to find the longest book you have ever read. One way to approach this problem is to list the books you have read one by one, label the first one as the longest, and whenever you encounter an even longer book, it takes the place of the former. This way, you only have to keep track of the largest page number so far, and the book associated with it. The "elementary operation" in this case is checking the number of pages of the next book and comparing that with the previous maximum. If you have twice or three times as many books, this procedure requires twice or three times as many elementary operations. In other words, it grows `),Pe(ne.$$.fragment),_e=s(" in the number of books. So, while the solution can be found using the same algorithm, the number of elementary operations required to carry out that algorithm depends on the size of the input. This is true for almost all algorithms that are designed to solve mathematical problems. However, how fast that growth is, makes all the difference between them.")},l(W){n=h(W,"H2",{});var pe=u(n);r=o(pe,"Description of the problem"),pe.forEach(a),i=S(W),m=h(W,"P",{});var Z=u(m);d=o(Z,"We would like to find the prime factors "),_=h(Z,"SPAN",{});var ut=u(_);ut.forEach(a),v=o(Z," of a large "),Me(b.$$.fragment,Z),E=S(Z),w=h(Z,"SPAN",{});var Be=u(w);Be.forEach(a),$=o(Z," (so that "),I=h(Z,"SPAN",{});var Ct=u(I);Ct.forEach(a),U=o(Z,"). Finding these factors for a small number, such as "),L=h(Z,"SPAN",{});var mt=u(L);mt.forEach(a),V=o(Z," is quite easy. In fact, you may figure it out just by looking at it and recalling your grade school studies: the factors are "),H=h(Z,"SPAN",{});var De=u(H);De.forEach(a),D=o(Z," and "),X=h(Z,"SPAN",{});var St=u(X);St.forEach(a),se=o(Z," But what are the prime factors of, say, "),ee=h(Z,"SPAN",{});var $t=u(ee);$t.forEach(a),T=o(Z,"? It turns out that, using the best known classical (meaning non-quantum) algorithm (the so called "),Me(x.$$.fragment,Z),ie=o(Z,"), solving the factoring problem scales "),Me(R.$$.fragment,Z),Q=o(Z," with the number of digits of the semiprime that we want to factor. With the help of Shor's algorithm and a sufficiently large "),Me(G.$$.fragment,Z),me=o(Z,", the same problem scales roughly "),Me(ae.$$.fragment,Z),ze=o(Z," with the number of digits. (In fact, the algorithm does slighly better than that, but the precise formula is a bit complicated and is beside the point.) To illustrate what this means in practical terms, imagine the following. If factoring a "),le=h(Z,"SPAN",{});var Ye=u(le);Ye.forEach(a),P=o(Z,"-digit number with Shor's algorithm on a quantum computer takes one second, factoring the same number with the number field sieve on a classical computer takes more than "),re=h(Z,"SPAN",{});var Kt=u(re);Kt.forEach(a),ct=o(Z," hours. If we now try with a "),ke=h(Z,"SPAN",{});var Nt=u(ke);Nt.forEach(a),yt=o(Z,"-digit number, Shor's algorithm finishes in roughly "),fe=h(Z,"SPAN",{});var et=u(fe);et.forEach(a),rt=o(Z," seconds, while the classical solution would take more than a year!"),Z.forEach(a),ve=S(W),Ae=h(W,"P",{});var kt=u(Ae);Me(Ke.$$.fragment,kt),_t=o(kt,` refers to how the time - or number of elementary operations - required to solve a given problem algorithmically grows with the size of the input. Let's say you have to find the longest book you have ever read. One way to approach this problem is to list the books you have read one by one, label the first one as the longest, and whenever you encounter an even longer book, it takes the place of the former. This way, you only have to keep track of the largest page number so far, and the book associated with it. The "elementary operation" in this case is checking the number of pages of the next book and comparing that with the previous maximum. If you have twice or three times as many books, this procedure requires twice or three times as many elementary operations. In other words, it grows `),Me(ne.$$.fragment,kt),_e=o(kt," in the number of books. So, while the solution can be found using the same algorithm, the number of elementary operations required to carry out that algorithm depends on the size of the input. This is true for almost all algorithms that are designed to solve mathematical problems. However, how fast that growth is, makes all the difference between them."),kt.forEach(a)},m(W,pe){g(W,n,pe),t(n,r),g(W,i,pe),g(W,m,pe),t(m,d),t(m,_),_.innerHTML=c,t(m,v),Se(b,m,null),t(m,E),t(m,w),w.innerHTML=N,t(m,$),t(m,I),I.innerHTML=Y,t(m,U),t(m,L),L.innerHTML=C,t(m,V),t(m,H),H.innerHTML=q,t(m,D),t(m,X),X.innerHTML=A,t(m,se),t(m,ee),ee.innerHTML=j,t(m,T),Se(x,m,null),t(m,ie),Se(R,m,null),t(m,Q),Se(G,m,null),t(m,me),Se(ae,m,null),t(m,ze),t(m,le),le.innerHTML=K,t(m,P),t(m,re),re.innerHTML=ce,t(m,ct),t(m,ke),ke.innerHTML=Ve,t(m,yt),t(m,fe),fe.innerHTML=Le,t(m,rt),g(W,ve,pe),g(W,Ae,pe),Se(Ke,Ae,null),t(Ae,_t),Se(ne,Ae,null),t(Ae,_e),st=!0,je||(sn=[p(_,"mouseenter",e[0]),p(w,"mouseenter",e[1]),p(I,"mouseenter",e[2]),p(L,"mouseenter",e[3]),p(H,"mouseenter",e[4]),p(X,"mouseenter",e[5]),p(ee,"mouseenter",e[6]),p(le,"mouseenter",e[7]),p(re,"mouseenter",e[8]),p(ke,"mouseenter",e[9]),p(fe,"mouseenter",e[10])],je=!0)},p(W,[pe]){const Z={};pe&2048&&(Z.$$scope={dirty:pe,ctx:W}),b.$set(Z);const ut={};pe&2048&&(ut.$$scope={dirty:pe,ctx:W}),x.$set(ut);const Be={};pe&2048&&(Be.$$scope={dirty:pe,ctx:W}),R.$set(Be);const Ct={};pe&2048&&(Ct.$$scope={dirty:pe,ctx:W}),G.$set(Ct);const mt={};pe&2048&&(mt.$$scope={dirty:pe,ctx:W}),ae.$set(mt);const De={};pe&2048&&(De.$$scope={dirty:pe,ctx:W}),Ke.$set(De);const St={};pe&2048&&(St.$$scope={dirty:pe,ctx:W}),ne.$set(St)},i(W){st||(be(b.$$.fragment,W),be(x.$$.fragment,W),be(R.$$.fragment,W),be(G.$$.fragment,W),be(ae.$$.fragment,W),be(Ke.$$.fragment,W),be(ne.$$.fragment,W),st=!0)},o(W){Ne(b.$$.fragment,W),Ne(x.$$.fragment,W),Ne(R.$$.fragment,W),Ne(G.$$.fragment,W),Ne(ae.$$.fragment,W),Ne(Ke.$$.fragment,W),Ne(ne.$$.fragment,W),st=!1},d(W){W&&a(n),W&&a(i),W&&a(m),qe(b),qe(x),qe(R),qe(G),qe(ae),W&&a(ve),W&&a(Ae),qe(Ke),qe(ne),je=!1,kr(sn)}}}function yr(e){console.log(e)}function _u(e){return[()=>yr(["q","P","p"]),()=>yr(["N"]),()=>yr(["p","q","N"]),()=>yr([]),()=>yr([]),()=>yr([]),()=>yr([]),()=>yr([]),()=>yr([]),()=>yr([]),()=>yr([])]}class du extends wa{constructor(n){super(),ga(this,n,_u,cu,ya,{})}}const bu='<a href="https://en.wikipedia.org/wiki/Greatest_common_divisor"><h3>Greatest common divisor</h3></a><p>In mathematics, the <b>greatest common divisor</b> (<b>GCD</b>) of two or more integers, which are not all zero, is the largest positive integer that divides each of the integers. For two integers <i>x</i>, <i>y</i>, the greatest common divisor of <i>x</i> and <i>y</i> is denoted <span class="mwe-math-element"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/24c083a217bb5e2d3468e683c957f220a683e4d8" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align:-0.838ex;width:8.816ex;height:2.843ex" /></span>. For example, the GCD of 8 and 12 is 4, that is, <span class="mwe-math-element"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/cabed257e6ea789ef3febd9add3a7f3ef2237361" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align:-0.838ex;width:14.079ex;height:2.843ex" /></span>.</p>',vu=`<a href="https://en.wikipedia.org/wiki/Euclidean_algorithm"><h3>Euclidean algorithm</h3></a><p>In mathematics, the <b>Euclidean algorithm</b>, or <b>Euclid's algorithm</b>, is an efficient method for computing the greatest common divisor (GCD) of two integers (numbers), the largest number that divides them both without a remainder. It is named after the ancient Greek mathematician Euclid, who first described it in <span>his <i>Elements</i></span> .
It is an example of an <i>algorithm</i>, a step-by-step procedure for performing a calculation according to well-defined rules,
and is one of the oldest algorithms in common use. It can be used to reduce fractions to their simplest form, and is a part of many other number-theoretic and cryptographic calculations.</p>`;function wu(e){let n;return{c(){n=s("greatest common divisor")},l(r){n=o(r,"greatest common divisor")},m(r,i){g(r,n,i)},d(r){r&&a(n)}}}function gu(e){let n;return{c(){n=s("Euclid's algorithm")},l(r){n=o(r,"Euclid's algorithm")},m(r,i){g(r,n,i)},d(r){r&&a(n)}}}function yu(e){let n,r,i,m,d,_,c,v,b,E,w,N=f("a \\in \\mathbb{N}, 1 < a < N")+"",$,I,Y=f("a")+"",U,L,C=f("N")+"",V,H,q=f("\\gcd(a, N) = 1,")+"",D,X,A=f("\\gcd")+"",se,ee,j,T,x=f("a")+"",ie,R,Q=f("N,")+"",G,me,ae=f("N")+"",ze,le,K,P,re,ce,ct=f("f_{a, N}(r): \\mathbb{N} \\rightarrow \\mathbb{N} = a^r \\mod N")+"",ke,Ve,yt=f("0 < \\hat{r} < N")+"",fe,Le,rt=f("f_{a, N}(\\hat{r}) = 1.")+"",ve,Ae,Ke=f("\\hat{r}")+"",_t,ne,_e=f("a")+"",st,je,sn,W,pe,Z,ut=f("\\hat{r}")+"",Be,Ct,mt=f("\\hat{r}")+"",De,St,$t=f("m \\in \\mathbb{N}")+"",Ye,Kt,Nt=f("a^{\\hat{r}} = m \\cdot N + 1.")+"",et,kt,Lt=f("b = a^{\\frac{\\hat{r}}{2}},")+"",F,Ee,We=f("b^2 = (a^{\\frac{\\hat{r}}{2}})^2 = a^{\\hat{r}}.")+"",Et,Rt,He=f("b^2 - 1 = (b + 1)(b - 1).")+"",bt,qt,on=f("(b + 1)(b - 1) = m \\cdot N.")+"",Tt,At,ue,wn,Ue,Ht=f("N")+"",oe,tt,xt=f("(b - 1) \\mod N \\neq 0,")+"",jt,Dt,lt=f("b = a^{\\frac{\\hat{r}}{2}} \\mod N = 1,")+"",Yt,Wt,It=f("\\hat{r}")+"",ia,Ft,un=f("\\frac{\\hat{r}}{2} < \\hat{r}")+"",$a,he,ye=f("(b + 1) \\mod N = 0,")+"",ft,tn,Ut=f("a")+"",Qt,gn,Zt=f("(b + 1) \\mod N \\neq 0,")+"",pt,yn,zt=f("\\gcd(b - 1, N)")+"",Qa,mn,de=f("\\gcd(b + 1, N),")+"",za,Ot,fn,Xn,Pn=f("(b - 1)")+"",Fe,In,pn=f("(b + 1)")+"",Pt,Mt,Fn=f("N,")+"",Mn,nn,Qn=f("m \\cdot N")+"",cn,Gt,zn=f("N,")+"",Sn,Dn,Vt,Na,Vn,Ze,Bn,$n,ln,Cn,Nn,ka=f("\\hat{r},")+"",_n,Wn,Ka=f("1")+"",we,qn,Ea=f("N")+"",ea,An,Ta=f("N")+"",ta,Un,na,la;return ee=new it({props:{hovertext:bu,$$slots:{default:[wu]},$$scope:{ctx:e}}}),Ot=new it({props:{hovertext:vu,$$slots:{default:[gu]},$$scope:{ctx:e}}}),{c(){n=l("h2"),r=s("Solution"),i=M(),m=l("p"),d=s("The factoring problem can be solved with the following simple, but very time-consuming algorithm:"),_=M(),c=l("ol"),v=l("li"),b=l("p"),E=s("We pick a random number "),w=l("span"),$=s(" and make sure that "),I=l("span"),U=s(" and "),L=l("span"),V=s(" are relative primes, meaning "),H=l("span"),D=s(" where "),X=l("span"),se=s(" stands for "),Pe(ee.$$.fragment),j=s(". (In case "),T=l("span"),ie=s(" happens to be a factor of "),R=l("span"),G=s(" the entire problem is solved and no further steps are required, but that is highly unlikely if "),me=l("span"),ze=s(" is large.)"),le=M(),K=l("li"),P=l("p"),re=s("Next, we construct the function "),ce=l("span"),ke=s(" and find the smallest integer "),Ve=l("span"),fe=s(" such that "),Le=l("span"),ve=s(" If "),Ae=l("span"),_t=s(" turns out to be odd, we unfortunately have to repeat the entire procedure with a different "),ne=l("span"),st=s(" parameter."),je=M(),sn=l("li"),W=l("p"),pe=s("If we're lucky and "),Z=l("span"),Be=s(" is even, we can proceed. From the definition of "),Ct=l("span"),De=s(" follows that there's "),St=l("span"),Ye=s(" such that "),Kt=l("span"),et=s(" We can then define the integer "),kt=l("span"),F=s(" which means "),Ee=l("span"),Et=s(" Next, we make use of a well-known algebraic identity to write "),Rt=l("span"),bt=s(" Putting together these three equations, we find that "),qt=l("span"),Tt=M(),At=l("li"),ue=l("p"),wn=s("For this step, we need to make sure that neither terms on the left of the expression above are divisible by "),Ue=l("span"),oe=s(". Note that we know for sure "),tt=l("span"),jt=s(" because that would imply "),Dt=l("span"),Yt=s(" and we defined "),Wt=l("span"),ia=s(" as the smallest positive integer, for which that equality holds, so it cannot hold for "),Ft=l("span"),$a=s(". Unfortunately, we cannot guarantee the same for the other term, so if "),he=l("span"),ft=s(" we have to choose a new "),tn=l("span"),Qt=s(" and start from the beginning. If "),gn=l("span"),pt=s(" however, we have solved the problem, because the prime factors we're looking for are "),yn=l("span"),Qa=s(" and "),mn=l("span"),za=s(" and these are very easy to compute with the help of "),Pe(Ot.$$.fragment),fn=s(". To see why this is true, consider the following. We have established that neither "),Xn=l("span"),Fe=s(" nor "),In=l("span"),Pt=s(" are divisible by "),Mt=l("span"),Mn=s(" but their product is, as it equals "),nn=l("span"),cn=s(". This is only possible, if both of them share a factor with "),Gt=l("span"),Sn=s(" and the factors they share are different."),Dn=M(),Vt=l("p"),Na=s("If you're not entirely satisfied with the explanation above, check out the video "),Vn=l("a"),Ze=s("Hacking at Quantum Speed with Shor's Algorithm"),Bn=s(" by PBS Infinite Series."),$n=M(),ln=l("p"),Cn=s("The problem with this solution is that in order to find "),Nn=l("span"),_n=s(" we might have to check all possible values between "),Wn=l("span"),we=s(" and "),qn=l("span"),ea=s(" one after the other, which is an insane amount of computation if "),An=l("span"),ta=s(" is number with several hundreds of digits. But that's only the case if we're trying with a classical computer."),this.h()},l($e){n=h($e,"H2",{});var dt=u(n);r=o(dt,"Solution"),dt.forEach(a),i=S($e),m=h($e,"P",{});var Hn=u(m);d=o(Hn,"The factoring problem can be solved with the following simple, but very time-consuming algorithm:"),Hn.forEach(a),_=S($e),c=h($e,"OL",{});var Jt=u(c);v=h(Jt,"LI",{});var On=u(v);b=h(On,"P",{});var ht=u(b);E=o(ht,"We pick a random number "),w=h(ht,"SPAN",{});var ot=u(w);ot.forEach(a),$=o(ht," and make sure that "),I=h(ht,"SPAN",{});var ha=u(I);ha.forEach(a),U=o(ht," and "),L=h(ht,"SPAN",{});var z=u(L);z.forEach(a),V=o(ht," are relative primes, meaning "),H=h(ht,"SPAN",{});var Te=u(H);Te.forEach(a),D=o(ht," where "),X=h(ht,"SPAN",{});var Ce=u(X);Ce.forEach(a),se=o(ht," stands for "),Me(ee.$$.fragment,ht),j=o(ht,". (In case "),T=h(ht,"SPAN",{});var ua=u(T);ua.forEach(a),ie=o(ht," happens to be a factor of "),R=h(ht,"SPAN",{});var Ya=u(R);Ya.forEach(a),G=o(ht," the entire problem is solved and no further steps are required, but that is highly unlikely if "),me=h(ht,"SPAN",{});var Gn=u(me);Gn.forEach(a),ze=o(ht," is large.)"),ht.forEach(a),On.forEach(a),le=S(Jt),K=h(Jt,"LI",{});var aa=u(K);P=h(aa,"P",{});var an=u(P);re=o(an,"Next, we construct the function "),ce=h(an,"SPAN",{});var Kn=u(ce);Kn.forEach(a),ke=o(an," and find the smallest integer "),Ve=h(an,"SPAN",{});var ma=u(Ve);ma.forEach(a),fe=o(an," such that "),Le=h(an,"SPAN",{});var Za=u(Le);Za.forEach(a),ve=o(an," If "),Ae=h(an,"SPAN",{});var Xt=u(Ae);Xt.forEach(a),_t=o(an," turns out to be odd, we unfortunately have to repeat the entire procedure with a different "),ne=h(an,"SPAN",{});var Ja=u(ne);Ja.forEach(a),st=o(an," parameter."),an.forEach(a),aa.forEach(a),je=S(Jt),sn=h(Jt,"LI",{});var Er=u(sn);W=h(Er,"P",{});var Ge=u(W);pe=o(Ge,"If we're lucky and "),Z=h(Ge,"SPAN",{});var Xa=u(Z);Xa.forEach(a),Be=o(Ge," is even, we can proceed. From the definition of "),Ct=h(Ge,"SPAN",{});var Ur=u(Ct);Ur.forEach(a),De=o(Ge," follows that there's "),St=h(Ge,"SPAN",{});var Pa=u(St);Pa.forEach(a),Ye=o(Ge," such that "),Kt=h(Ge,"SPAN",{});var vt=u(Kt);vt.forEach(a),et=o(Ge," We can then define the integer "),kt=h(Ge,"SPAN",{});var Or=u(kt);Or.forEach(a),F=o(Ge," which means "),Ee=h(Ge,"SPAN",{});var Ma=u(Ee);Ma.forEach(a),Et=o(Ge," Next, we make use of a well-known algebraic identity to write "),Rt=h(Ge,"SPAN",{});var er=u(Rt);er.forEach(a),bt=o(Ge," Putting together these three equations, we find that "),qt=h(Ge,"SPAN",{});var Gr=u(qt);Gr.forEach(a),Ge.forEach(a),Er.forEach(a),Tt=S(Jt),At=h(Jt,"LI",{});var fa=u(At);ue=h(fa,"P",{});var xe=u(ue);wn=o(xe,"For this step, we need to make sure that neither terms on the left of the expression above are divisible by "),Ue=h(xe,"SPAN",{});var Kr=u(Ue);Kr.forEach(a),oe=o(xe,". Note that we know for sure "),tt=h(xe,"SPAN",{});var pa=u(tt);pa.forEach(a),jt=o(xe," because that would imply "),Dt=h(xe,"SPAN",{});var kn=u(Dt);kn.forEach(a),Yt=o(xe," and we defined "),Wt=h(xe,"SPAN",{});var En=u(Wt);En.forEach(a),ia=o(xe," as the smallest positive integer, for which that equality holds, so it cannot hold for "),Ft=h(xe,"SPAN",{});var Yn=u(Ft);Yn.forEach(a),$a=o(xe,". Unfortunately, we cannot guarantee the same for the other term, so if "),he=h(xe,"SPAN",{});var vs=u(he);vs.forEach(a),ft=o(xe," we have to choose a new "),tn=h(xe,"SPAN",{});var Ln=u(tn);Ln.forEach(a),Qt=o(xe," and start from the beginning. If "),gn=h(xe,"SPAN",{});var ca=u(gn);ca.forEach(a),pt=o(xe," however, we have solved the problem, because the prime factors we're looking for are "),yn=h(xe,"SPAN",{});var tr=u(yn);tr.forEach(a),Qa=o(xe," and "),mn=h(xe,"SPAN",{});var Qe=u(mn);Qe.forEach(a),za=o(xe," and these are very easy to compute with the help of "),Me(Ot.$$.fragment,xe),fn=o(xe,". To see why this is true, consider the following. We have established that neither "),Xn=h(xe,"SPAN",{});var _a=u(Xn);_a.forEach(a),Fe=o(xe," nor "),In=h(xe,"SPAN",{});var nr=u(In);nr.forEach(a),Pt=o(xe," are divisible by "),Mt=h(xe,"SPAN",{});var Sa=u(Mt);Sa.forEach(a),Mn=o(xe," but their product is, as it equals "),nn=h(xe,"SPAN",{});var ar=u(nn);ar.forEach(a),cn=o(xe,". This is only possible, if both of them share a factor with "),Gt=h(xe,"SPAN",{});var Tr=u(Gt);Tr.forEach(a),Sn=o(xe," and the factors they share are different."),xe.forEach(a),fa.forEach(a),Jt.forEach(a),Dn=S($e),Vt=h($e,"P",{});var hn=u(Vt);Na=o(hn,"If you're not entirely satisfied with the explanation above, check out the video "),Vn=h(hn,"A",{href:!0});var da=u(Vn);Ze=o(da,"Hacking at Quantum Speed with Shor's Algorithm"),da.forEach(a),Bn=o(hn," by PBS Infinite Series."),hn.forEach(a),$n=S($e),ln=h($e,"P",{});var rn=u(ln);Cn=o(rn,"The problem with this solution is that in order to find "),Nn=h(rn,"SPAN",{});var Pr=u(Nn);Pr.forEach(a),_n=o(rn," we might have to check all possible values between "),Wn=h(rn,"SPAN",{});var Ie=u(Wn);Ie.forEach(a),we=o(rn," and "),qn=h(rn,"SPAN",{});var qa=u(qn);qa.forEach(a),ea=o(rn," one after the other, which is an insane amount of computation if "),An=h(rn,"SPAN",{});var rr=u(An);rr.forEach(a),ta=o(rn," is number with several hundreds of digits. But that's only the case if we're trying with a classical computer."),rn.forEach(a),this.h()},h(){B(Vn,"href","https://www.youtube.com/watch?v=wUwZZaI5u0c&t=731s")},m($e,dt){g($e,n,dt),t(n,r),g($e,i,dt),g($e,m,dt),t(m,d),g($e,_,dt),g($e,c,dt),t(c,v),t(v,b),t(b,E),t(b,w),w.innerHTML=N,t(b,$),t(b,I),I.innerHTML=Y,t(b,U),t(b,L),L.innerHTML=C,t(b,V),t(b,H),H.innerHTML=q,t(b,D),t(b,X),X.innerHTML=A,t(b,se),Se(ee,b,null),t(b,j),t(b,T),T.innerHTML=x,t(b,ie),t(b,R),R.innerHTML=Q,t(b,G),t(b,me),me.innerHTML=ae,t(b,ze),t(c,le),t(c,K),t(K,P),t(P,re),t(P,ce),ce.innerHTML=ct,t(P,ke),t(P,Ve),Ve.innerHTML=yt,t(P,fe),t(P,Le),Le.innerHTML=rt,t(P,ve),t(P,Ae),Ae.innerHTML=Ke,t(P,_t),t(P,ne),ne.innerHTML=_e,t(P,st),t(c,je),t(c,sn),t(sn,W),t(W,pe),t(W,Z),Z.innerHTML=ut,t(W,Be),t(W,Ct),Ct.innerHTML=mt,t(W,De),t(W,St),St.innerHTML=$t,t(W,Ye),t(W,Kt),Kt.innerHTML=Nt,t(W,et),t(W,kt),kt.innerHTML=Lt,t(W,F),t(W,Ee),Ee.innerHTML=We,t(W,Et),t(W,Rt),Rt.innerHTML=He,t(W,bt),t(W,qt),qt.innerHTML=on,t(c,Tt),t(c,At),t(At,ue),t(ue,wn),t(ue,Ue),Ue.innerHTML=Ht,t(ue,oe),t(ue,tt),tt.innerHTML=xt,t(ue,jt),t(ue,Dt),Dt.innerHTML=lt,t(ue,Yt),t(ue,Wt),Wt.innerHTML=It,t(ue,ia),t(ue,Ft),Ft.innerHTML=un,t(ue,$a),t(ue,he),he.innerHTML=ye,t(ue,ft),t(ue,tn),tn.innerHTML=Ut,t(ue,Qt),t(ue,gn),gn.innerHTML=Zt,t(ue,pt),t(ue,yn),yn.innerHTML=zt,t(ue,Qa),t(ue,mn),mn.innerHTML=de,t(ue,za),Se(Ot,ue,null),t(ue,fn),t(ue,Xn),Xn.innerHTML=Pn,t(ue,Fe),t(ue,In),In.innerHTML=pn,t(ue,Pt),t(ue,Mt),Mt.innerHTML=Fn,t(ue,Mn),t(ue,nn),nn.innerHTML=Qn,t(ue,cn),t(ue,Gt),Gt.innerHTML=zn,t(ue,Sn),g($e,Dn,dt),g($e,Vt,dt),t(Vt,Na),t(Vt,Vn),t(Vn,Ze),t(Vt,Bn),g($e,$n,dt),g($e,ln,dt),t(ln,Cn),t(ln,Nn),Nn.innerHTML=ka,t(ln,_n),t(ln,Wn),Wn.innerHTML=Ka,t(ln,we),t(ln,qn),qn.innerHTML=Ea,t(ln,ea),t(ln,An),An.innerHTML=Ta,t(ln,ta),Un=!0,na||(la=[p(w,"mouseenter",e[0]),p(I,"mouseenter",e[1]),p(L,"mouseenter",e[2]),p(H,"mouseenter",e[3]),p(X,"mouseenter",e[4]),p(T,"mouseenter",e[5]),p(R,"mouseenter",e[6]),p(me,"mouseenter",e[7]),p(ce,"mouseenter",e[8]),p(Ve,"mouseenter",e[9]),p(Le,"mouseenter",e[10]),p(Ae,"mouseenter",e[11]),p(ne,"mouseenter",e[12]),p(Z,"mouseenter",e[13]),p(Ct,"mouseenter",e[14]),p(St,"mouseenter",e[15]),p(Kt,"mouseenter",e[16]),p(kt,"mouseenter",e[17]),p(Ee,"mouseenter",e[18]),p(Rt,"mouseenter",e[19]),p(qt,"mouseenter",e[20]),p(Ue,"mouseenter",e[21]),p(tt,"mouseenter",e[22]),p(Dt,"mouseenter",e[23]),p(Wt,"mouseenter",e[24]),p(Ft,"mouseenter",e[25]),p(he,"mouseenter",e[26]),p(tn,"mouseenter",e[27]),p(gn,"mouseenter",e[28]),p(yn,"mouseenter",e[29]),p(mn,"mouseenter",e[30]),p(Xn,"mouseenter",e[31]),p(In,"mouseenter",e[32]),p(Mt,"mouseenter",e[33]),p(nn,"mouseenter",e[34]),p(Gt,"mouseenter",e[35]),p(Nn,"mouseenter",e[36]),p(Wn,"mouseenter",e[37]),p(qn,"mouseenter",e[38]),p(An,"mouseenter",e[39])],na=!0)},p($e,dt){const Hn={};dt[1]&512&&(Hn.$$scope={dirty:dt,ctx:$e}),ee.$set(Hn);const Jt={};dt[1]&512&&(Jt.$$scope={dirty:dt,ctx:$e}),Ot.$set(Jt)},i($e){Un||(be(ee.$$.fragment,$e),be(Ot.$$.fragment,$e),Un=!0)},o($e){Ne(ee.$$.fragment,$e),Ne(Ot.$$.fragment,$e),Un=!1},d($e){$e&&a(n),$e&&a(i),$e&&a(m),$e&&a(_),$e&&a(c),qe(ee),qe(Ot),$e&&a(Dn),$e&&a(Vt),$e&&a($n),$e&&a(ln),na=!1,kr(la)}}}function Re(e){console.log(e)}function $u(e){return[()=>Re(["a","N"]),()=>Re(["a"]),()=>Re(["N"]),()=>Re(["a","N"]),()=>Re([]),()=>Re(["a"]),()=>Re(["N"]),()=>Re(["N"]),()=>Re(["N","a","f","r"]),()=>Re(["N","r"]),()=>Re(["N","a","f","r"]),()=>Re(["r"]),()=>Re(["a"]),()=>Re(["r"]),()=>Re(["r"]),()=>Re(["m","N"]),()=>Re(["m","a","N","r"]),()=>Re(["a","r","b"]),()=>Re(["a","r","b"]),()=>Re(["b"]),()=>Re(["m","N","b"]),()=>Re(["N"]),()=>Re(["N","b"]),()=>Re(["a","N","r","b"]),()=>Re(["r"]),()=>Re(["r"]),()=>Re(["N","b"]),()=>Re(["a"]),()=>Re(["N","b"]),()=>Re(["N","b"]),()=>Re(["N","b"]),()=>Re(["b"]),()=>Re(["b"]),()=>Re(["N"]),()=>Re(["m","N"]),()=>Re(["N"]),()=>Re(["r"]),()=>Re([]),()=>Re(["N"]),()=>Re(["N"])]}class Nu extends wa{constructor(n){super(),ga(this,n,$u,yu,ya,{},null,[-1,-1])}}function ku(e){let n,r,i,m,d,_,c,v,b,E;return m=new du({}),_=new Nu({}),b=new Oh({}),{c(){n=l("h2"),r=s("Factoring"),i=M(),Pe(m.$$.fragment),d=M(),Pe(_.$$.fragment),c=M(),v=l("div"),Pe(b.$$.fragment),this.h()},l(w){n=h(w,"H2",{});var N=u(n);r=o(N,"Factoring"),N.forEach(a),i=S(w),Me(m.$$.fragment,w),d=S(w),Me(_.$$.fragment,w),c=S(w),v=h(w,"DIV",{class:!0});var $=u(v);Me(b.$$.fragment,$),$.forEach(a),this.h()},h(){B(v,"class","interaction")},m(w,N){g(w,n,N),t(n,r),g(w,i,N),Se(m,w,N),g(w,d,N),Se(_,w,N),g(w,c,N),g(w,v,N),Se(b,v,null),E=!0},p:js,i(w){E||(be(m.$$.fragment,w),be(_.$$.fragment,w),be(b.$$.fragment,w),E=!0)},o(w){Ne(m.$$.fragment,w),Ne(_.$$.fragment,w),Ne(b.$$.fragment,w),E=!1},d(w){w&&a(n),w&&a(i),qe(m,w),w&&a(d),qe(_,w),w&&a(c),w&&a(v),qe(b)}}}class Eu extends wa{constructor(n){super(),ga(this,n,null,ku,ya,{})}}const Tu='<a href="https://en.wikipedia.org/wiki/Binary_number"><h3>Binary number</h3></a><p>A <b>binary number</b> is a number expressed in the <b>base-2 numeral system</b> or <b>binary numeral system</b>, a method of mathematical expression which uses only two symbols: typically "0" (zero) and "1" (one).</p>',Pu=`<a href="https://en.wikipedia.org/wiki/Quantum_Fourier_transform"><h3>Quantum Fourier transform</h3></a><p>In quantum computing, the <b>quantum Fourier transform (QFT)</b> is a linear transformation on quantum bits, and is the quantum analogue of the discrete Fourier transform. The quantum Fourier transform is a part of many quantum algorithms, notably Shor's algorithm for factoring and computing the discrete logarithm, the quantum phase estimation algorithm for estimating the eigenvalues of a unitary operator, and algorithms for the hidden subgroup problem. The quantum Fourier transform was discovered by Don Coppersmith.</p>`;function Mu(e){let n;return{c(){n=s("binary representations")},l(r){n=o(r,"binary representations")},m(r,i){g(r,n,i)},d(r){r&&a(n)}}}function Su(e){let n;return{c(){n=s("quantum Fourier transform")},l(r){n=o(r,"quantum Fourier transform")},m(r,i){g(r,n,i)},d(r){r&&a(n)}}}function qu(e){let n,r,i,m,d,_,c,v,b,E=f("n")+"",w,N,$=f("|0\\rangle")+"",I,Y,U=f("|1\\rangle.")+"",L,C,V=f("\\underbrace{2 \\cdot \\ldots \\cdot 2}_\\text{n times} = 2^n")+"",H,q,D=f("N := 2^n.")+"",X,A,se,ee,j,T,x=f("0")+"",ie,R,Q=f("N - 1.")+"",G,me,ae=f("n = 5")+"",ze,le,K=f("|0\\rangle \\otimes |1\\rangle \\otimes |0\\rangle \\otimes |0\\rangle \\otimes |1\\rangle.")+"",P,re,ce=f("01001,")+"",ct,ke,Ve=f("\\small 0 \\cdot 2^4 + 1 \\cdot 2^3 + 0 \\cdot 2^2 + 0 \\cdot 2^1 + 1 \\cdot 2^0 = 0 + 8 + 0 + 0 + 1 = 9.")+"",yt,fe,Le,rt,ve,Ae,Ke,_t,ne,_e=f("x")+"",st,je,sn=f("x = 9")+"",W,pe,Z=f("k")+"",ut,Be,Ct=f("\\frac{1}{\\sqrt{2}} \\left( |0\\rangle + e^{\\frac{2 \\pi i x}{2^k}} |1\\rangle \\right).")+"",mt,De,St=f("\\alpha_k = \\frac{1}{\\sqrt{2}}")+"",$t,Ye,Kt=f("\\beta_k = \\frac{1}{\\sqrt{2}} e^{\\frac{2 \\pi i x}{2^k}}")+"",Nt,et,kt=f("k = 1, ..., n.")+"",Lt,F,Ee,We,Et=f("\\alpha_k \\neq \\beta_k,")+"",Rt,He,bt=f("\\Vert{\\alpha_k}\\Vert^2 = \\Vert{\\beta_k}\\Vert^2 = \\frac{1}{2}")+"",qt,on,Tt=f("k = 1, ..., n.")+"",At,ue,wn=f("e^{\\frac{2 \\pi i x}{2^k}}")+"",Ue,Ht,oe,tt,xt,jt=f("|0\\rangle")+"",Dt,lt,Yt=f("|1\\rangle,")+"",Wt,It,ia=f("n")+"",Ft,un,$a=f("n")+"",he,ye,ft=f("0")+"",tn,Ut,Qt=f("N - 1.")+"",gn,Zt,pt=f("n")+"",yn,zt,Qa=f("2^n")+"",mn,de,za=f("\\frac{1}{2}")+"",Ot,fn,Xn=f("n")+"",Pn,Fe,In=f("\\underbrace{\\frac{1}{2} \\cdot \\ldots \\cdot \\frac{1}{2}}_\\text{n terms} = \\frac{1}{2^n} = \\frac{1}{N}.")+"",pn,Pt,Mt,Fn,Mn,nn,Qn,cn,Gt=f("|\\psi\\rangle")+"",zn,Sn,Dn,Vt,Na=f("|\\psi\\rangle = \\underbrace{ \\frac{1}{\\sqrt{2}} \\left( |0\\rangle + e^{ \\frac{2 \\pi i x}{2^1} } |1\\rangle \\right) \\otimes \\ldots \\otimes \\frac{1}{\\sqrt{2}} \\left( |0\\rangle + e^{ \\frac{2 \\pi i x}{2^n} } |1\\rangle \\right) }_\\text{n terms}")+"",Vn,Ze,Bn,$n,ln=f("\\frac{1}{\\sqrt{2}}")+"",Cn,Nn,ka,_n,Wn=f("|\\psi\\rangle = \\frac{1}{\\sqrt{2^n}} \\left(\\left( |0\\rangle + e^{\\frac{2 \\pi i x}{2^1}} |1\\rangle \\right) \\otimes \\ldots \\otimes \\left( |0\\rangle + e^{\\frac{2 \\pi i x}{2^n}} |1\\rangle \\right) \\right) = \\frac{1}{\\sqrt{N}} \\left(\\left( |0\\rangle + e^{\\frac{2 \\pi i x}{2^1}} |1\\rangle \\right) \\otimes \\ldots \\otimes \\left( |0\\rangle + e^{\\frac{2 \\pi i x}{2^n}} |1\\rangle \\right) \\right)")+"",Ka,we,qn,Ea,ea=f("y")+"",An,Ta,ta=f("n")+"",Un,na,la=f("y_k")+"",$e,dt,Hn=f("k")+"",Jt,On,ht=f("y.")+"",ot,ha,z=f("y_k = 0")+"",Te,Ce,ua=f("k")+"",Ya,Gn,aa=f("|0\\rangle")+"",an,Kn,ma=f("y_k = 1")+"",Za,Xt,Ja=f("|1\\rangle")+"",Er,Ge,Xa=f("k = 1, \\ldots, n.")+"",Ur,Pa,vt=f("y")+"",Or,Ma,er=f("\\displaystyle{ y = \\sum_{k=1}^n y_k \\cdot 2^{n - k}}.")+"",Gr,fa,xe=f("2^n")+"",Kr,pa,kn=f("k")+"",En,Yn,vs=f("\\displaystyle{ y = 2^n \\cdot \\sum_{k=1}^n y_k \\cdot 2^{-k} = N \\cdot \\sum_{k=1}^n \\frac{y_k}{2^k}}.")+"",Ln,ca,tr,Qe,_a,nr,Sa,ar=f("|\\psi\\rangle = \\displaystyle{ \\frac{1}{\\sqrt{N}} \\underbrace{ \\sum_{y_1=0}^1 \\ldots \\sum_{y_{n}=0}^1}_\\text{n terms} \\overbrace{e^{\\frac{2 \\pi i x y_1}{2^1}} |y_1\\rangle \\otimes \\ldots \\otimes e^{\\frac{2 \\pi i x y_n}{2^n}}|y_n\\rangle}^\\text{n terms} }")+"",Tr,hn,da,rn,Pr=f("k,")+"",Ie,qa,rr=f("e^{\\frac{2 \\pi i x y_k}{2^k}}|y_k\\rangle")+"",ws,Mr,ba,Sr,qr,Xr=f("e^{\\frac{2 \\pi i x \\cdot 0}{2^k}}|0\\rangle = 1 \\cdot |0\\rangle = |0\\rangle")+"",so,Ar,es=f("y_k = 0,")+"",oo,gs,Aa,ts,io=f("e^{\\frac{2 \\pi i x \\cdot 1}{2^k}}|1\\rangle = e^{\\frac{2 \\pi i x }{2^k}}|1\\rangle")+"",Hr,ns,lo=f("y_k = 1,")+"",ur,as,ys,mr,Ha,$s,Va,ti=f("n")+"",Ns,sr,ho,ks,or,uo,Es,fr,Lr,Ts,ir,mo,Ps,pr,rs,xr,ss=f("|\\psi\\rangle = \\displaystyle{ \\frac{1}{\\sqrt{N}} \\sum_{y_1=0}^1 \\ldots \\sum_{y_{n}=0}^1 \\left( e^{\\frac{2 \\pi i x y_1}{2^1}} \\cdot \\ldots \\cdot e^{\\frac{2 \\pi i x y_n}{2^n}} \\right) \\left( |y_1\\rangle \\otimes \\ldots \\otimes |y_n\\rangle \\right)}")+"",Ds,Ir,Ba,ni=f("|\\psi\\rangle = \\displaystyle{ = \\frac{1}{\\sqrt{N}} \\sum_{y_1=0}^1 \\ldots \\sum_{y_{n}=0}^1 \\prod_{k=1}^n e^{\\frac{2 \\pi i x y_k}{2^k}} \\left( |y_1\\rangle \\otimes \\ldots \\otimes |y_n\\rangle \\right)}")+"",Yr,Ca,Ms,Zr,Tn,Fr,os=f("|\\psi\\rangle = \\displaystyle{ = \\frac{1}{\\sqrt{N}} \\sum_{y_1=0}^1 \\ldots \\sum_{y_{n}=0}^1 e^{\\sum_{k=1}^n \\frac{2 \\pi i x y_k}{2^k}} \\left( |y_1\\rangle \\otimes \\ldots \\otimes |y_n\\rangle \\right)}")+"",Ws,La,Qr,is,fo=f("2 \\pi i x")+"",zr,ls,po=f("k,")+"",Vr,Us,cr,Ra,co=f("|\\psi\\rangle = \\displaystyle{ = \\frac{1}{\\sqrt{N}} \\sum_{y_1=0}^1 \\ldots \\sum_{y_{n}=0}^1 e^{2 \\pi i x \\sum_{k=1}^n \\frac{y_k}{2^k}} \\left( |y_1\\rangle \\otimes \\ldots \\otimes |y_n\\rangle \\right)}")+"",Jr,Je,Ss,ja,ai=f("\\displaystyle{ \\sum_{k=1}^n \\frac{y_k}{2^k}}")+"",qs,Da,ri=f("\\frac{y}{N}.")+"",As,Wa,si=f("y_k")+"",Hs,va,_o=f("y")+"",Br,hs,bo=f("y.")+"",Cr,us,Os=f("|y\\rangle = |y_1\\rangle \\otimes \\ldots \\otimes |y_n\\rangle,")+"",Rn,ms,Ua,fs,vo=f("|\\psi\\rangle = \\displaystyle{ \\frac{1}{\\sqrt{N}} \\sum_{y=0}^{N - 1} e^{\\frac{2 \\pi i x y}{N}} |y\\rangle}")+"",_r,ps,Ls,dr,jn,xs,Oa,oi=f("x,")+"",Is,br,wo=f("e^{\\frac{2 \\pi i x y}{N}}")+"",Gs,k,ge=f("y")+"",dn,vr,ii=f("x,")+"",go,cs,li=f("x")+"",en,Ks,yo,Po;return ee=new it({props:{hovertext:Tu,$$slots:{default:[Mu]},$$scope:{ctx:e}}}),Ke=new it({props:{hovertext:Pu,$$slots:{default:[Su]},$$scope:{ctx:e}}}),{c(){n=l("h2"),r=s("Quantum Fourier transform (QFT)"),i=M(),m=l("h2"),d=s("Representing numbers with qubits"),_=M(),c=l("p"),v=s("Consider "),b=l("span"),w=s(" qubits aranged in a row, each of which are in either of the two basis states "),N=l("span"),I=s(" or "),Y=l("span"),L=s(" With a little combinatorics, we can see that there are "),C=l("span"),H=s(" such combinations. For ease of notation, let "),q=l("span"),X=M(),A=l("p"),se=s("For our purposes, we'll interpret these combinations as the "),Pe(ee.$$.fragment),j=s(" of the numbers from "),T=l("span"),ie=s(" to "),R=l("span"),G=s(" For example, let "),me=l("span"),ze=s(" and the qubits be in the following state: "),le=l("span"),P=s(' We can "read out" this state as the binary number '),re=l("span"),ct=s(" which is equal to "),ke=l("span"),yt=M(),fe=l("h2"),Le=s("QFT on the qubit level"),rt=M(),ve=l("p"),Ae=s("The "),Pe(Ke.$$.fragment),_t=s(" is an operation that modifies the states of qubits in a particular way. (How this is done in practice is another topic, for now we'll only look at the mathematics.) Namely, if "),ne=l("span"),st=s(" is the number represented by the qubits (in the example above, "),je=l("span"),W=s("), the QFT sets the state of the "),pe=l("span"),ut=s("-th qubit to "),Be=l("span"),mt=s(" In other words, it sets "),De=l("span"),$t=s(" and "),Ye=l("span"),Nt=s(" for all "),et=l("span"),Lt=M(),F=l("p"),Ee=s("Notice that even though "),We=l("span"),Rt=s(" the associated measurement probabilities "),He=l("span"),qt=s(" for all "),on=l("span"),At=s(" This is because the "),ue=l("span"),Ue=s(" term - as we saw in the section about the Bloch-sphere - indicates the qubit's phase and does not affect measurement probabilities."),Ht=M(),oe=l("p"),tt=s("Just like the state of a single qubit can be the linear combination of "),xt=l("span"),Dt=s(" and "),lt=l("span"),Wt=s(" the state of these "),It=l("span"),Ft=s(" qubits is essentially the linear combination of all the possible combinations of the "),un=l("span"),he=s(" basis states - which, as we saw in the previous section, represent the integers from "),ye=l("span"),tn=s(" to "),Ut=l("span"),gn=s(" Take a moment to appreciate this fact. We applied an operator to "),Zt=l("span"),yn=s(" qubits to obtain a quantum system that represents "),zt=l("span"),mn=s(" numbers at the same time and is capable of performing computations on all of those numbers in parallel! This parallelism is one of the main properties that make quantum computers so powerful compared to classical ones. Since both basis states are measured with a probability of "),de=l("span"),Ot=s(" for each qubit, any particular combination of the "),fn=l("span"),Pn=s(" basis states is measured with a probability of "),Fe=l("span"),pn=s(" What differs across these combinations - and is an essential component of the QFT - is the phase, as we'll see in the next section."),Pt=M(),Mt=l("h2"),Fn=s("QFT on the representation level"),Mn=M(),nn=l("p"),Qn=s("Let's denote the state of the entire sequence of qubits with "),cn=l("span"),zn=s(" and write it out as shown below:"),Sn=M(),Dn=l("p"),Vt=l("span"),Vn=M(),Ze=l("p"),Bn=s("We can factor out the "),$n=l("span"),Cn=s(" term to get:"),Nn=M(),ka=l("p"),_n=l("span"),Ka=M(),we=l("p"),qn=s("Let "),Ea=l("span"),An=s(" denote the binary number represented by the "),Ta=l("span"),Un=s(" qubits in a given basis state, and "),na=l("span"),$e=s(" the "),dt=l("span"),Jt=s("-th digit of "),On=l("span"),ot=s(" In other words, "),ha=l("span"),Te=s("\xA0if the "),Ce=l("span"),Ya=s("-th qubit is in the "),Gn=l("span"),an=s(" state, and "),Kn=l("span"),Za=s("\xA0if it's in the "),Xt=l("span"),Er=s(" state for all "),Ge=l("span"),Ur=s(" Recalling our knowledge of binary numbers, we can write "),Pa=l("span"),Or=s(" as the weighted sum of its digits: "),Ma=l("span"),Gr=s(" Notice that the "),fa=l("span"),Kr=s(" term within the sum does not depend on "),pa=l("span"),En=s(" and so we can factor it out: "),Yn=l("span"),Ln=s(" Remember this step, as it is going to be important shortly!"),ca=M(),tr=l("p"),Qe=s("Using this new notation, we can write the state of the qubits in the form of a sum instead of a product:"),_a=M(),nr=l("p"),Sa=l("span"),Tr=M(),hn=l("p"),da=s("In case you're wondering how the formula above can be derived from the definition we started with, note that for all "),rn=l("span"),Ie=s(" the term "),qa=l("span"),ws=s(" equals"),Mr=M(),ba=l("ul"),Sr=l("li"),qr=l("span"),so=s(" if "),Ar=l("span"),oo=s(" and"),gs=M(),Aa=l("li"),ts=l("span"),Hr=s(" if "),ns=l("span"),ur=M(),as=l("p"),ys=s("which is exactly how we defined the QFT."),mr=M(),Ha=l("p"),$s=s("The "),Va=l("span"),Ns=s(" embedded summations might seem confusing at first, but what they actually do is iterate over all possible combinations of basis states. In the final sum, these are included with "),sr=l("em"),ho=s("equal weight"),ks=s(" (meaning they are measured with equal probability), but the composing basis states will have "),or=l("em"),uo=s("different phases"),Es=s(" in each combination, as already mentioned at the end of the previous section."),fr=M(),Lr=l("p"),Ts=s("Let's now define the "),ir=l("em"),mo=s("phase of the combination"),Ps=s(" as the product of the phases of individual qubits within that combination, and factor it out as shown below:"),pr=M(),rs=l("p"),xr=l("span"),Ds=M(),Ir=l("p"),Ba=l("span"),Yr=M(),Ca=l("p"),Ms=s("After making use of the product rule for exponents..."),Zr=M(),Tn=l("p"),Fr=l("span"),Ws=M(),La=l("p"),Qr=s("and factoring out the "),is=l("span"),zr=s(" term that does not depend on "),ls=l("span"),Vr=s(" we arrive at the formula below:"),Us=M(),cr=l("p"),Ra=l("span"),Jr=M(),Je=l("p"),Ss=s("Recall what I asked you to keep in mind a few paragraphs ago, and notice that the sum in the exponential "),ja=l("span"),qs=s(" is actually equal to "),Da=l("span"),As=s(" Thus, we can now replace the individual "),Wa=l("span"),Hs=s(" digits with the number "),va=l("span"),Br=s(" itself and the multiple, embedded summations with a single one that iterates over all possible values of "),hs=l("span"),Cr=s(" In addition, let's abbreviate the notation we used for the product of the basis states with "),us=l("span"),Rn=s(" to finally obtain this way more elegant formula for the QFT:"),ms=M(),Ua=l("p"),fs=l("span"),_r=M(),ps=l("p"),Ls=s("The elegance comes from the fact that it shows what the qubits represent on a symbolic level, as opposed to the expression we started with that is a direct insight into the bit-level implementation."),dr=M(),jn=l("p"),xs=s("Now let's illustrate visually what the formula above actually means. To give a proper intuition, we'll look at multiple systems with increasing number of qubits. For a chosen value of "),Oa=l("span"),Is=s(" the plot below shows the "),br=l("span"),Gs=s(" terms for all possible values of "),k=l("span"),dn=s(" that these systems can represent. Because this term is a complex number, the geometric representation of which would require two dimensions, the real and imaginary components are shown separately. Notice that as the number of qubits increases, the plots gradually turn into sinusoidal wave patterns. Furthermore, the number of peaks of these waves - their frequency - equals "),vr=l("span"),go=s(" which you can verify by modifying "),cs=l("span"),en=s(" with the help of the slider.")},l(y){n=h(y,"H2",{});var te=u(n);r=o(te,"Quantum Fourier transform (QFT)"),te.forEach(a),i=S(y),m=h(y,"H2",{});var Fs=u(m);d=o(Fs,"Representing numbers with qubits"),Fs.forEach(a),_=S(y),c=h(y,"P",{});var ra=u(c);v=o(ra,"Consider "),b=h(ra,"SPAN",{});var hi=u(b);hi.forEach(a),w=o(ra," qubits aranged in a row, each of which are in either of the two basis states "),N=h(ra,"SPAN",{});var ui=u(N);ui.forEach(a),I=o(ra," or "),Y=h(ra,"SPAN",{});var bn=u(Y);bn.forEach(a),L=o(ra," With a little combinatorics, we can see that there are "),C=h(ra,"SPAN",{});var mi=u(C);mi.forEach(a),H=o(ra," such combinations. For ease of notation, let "),q=h(ra,"SPAN",{});var fi=u(q);fi.forEach(a),ra.forEach(a),X=S(y),A=h(y,"P",{});var Zn=u(A);se=o(Zn,"For our purposes, we'll interpret these combinations as the "),Me(ee.$$.fragment,Zn),j=o(Zn," of the numbers from "),T=h(Zn,"SPAN",{});var pi=u(T);pi.forEach(a),ie=o(Zn," to "),R=h(Zn,"SPAN",{});var ci=u(R);ci.forEach(a),G=o(Zn," For example, let "),me=h(Zn,"SPAN",{});var _i=u(me);_i.forEach(a),ze=o(Zn," and the qubits be in the following state: "),le=h(Zn,"SPAN",{});var di=u(le);di.forEach(a),P=o(Zn,' We can "read out" this state as the binary number '),re=h(Zn,"SPAN",{});var bi=u(re);bi.forEach(a),ct=o(Zn," which is equal to "),ke=h(Zn,"SPAN",{});var vi=u(ke);vi.forEach(a),Zn.forEach(a),yt=S(y),fe=h(y,"H2",{});var Qs=u(fe);Le=o(Qs,"QFT on the qubit level"),Qs.forEach(a),rt=S(y),ve=h(y,"P",{});var xn=u(ve);Ae=o(xn,"The "),Me(Ke.$$.fragment,xn),_t=o(xn," is an operation that modifies the states of qubits in a particular way. (How this is done in practice is another topic, for now we'll only look at the mathematics.) Namely, if "),ne=h(xn,"SPAN",{});var Mo=u(ne);Mo.forEach(a),st=o(xn," is the number represented by the qubits (in the example above, "),je=h(xn,"SPAN",{});var So=u(je);So.forEach(a),W=o(xn,"), the QFT sets the state of the "),pe=h(xn,"SPAN",{});var Rr=u(pe);Rr.forEach(a),ut=o(xn,"-th qubit to "),Be=h(xn,"SPAN",{});var wi=u(Be);wi.forEach(a),mt=o(xn," In other words, it sets "),De=h(xn,"SPAN",{});var gi=u(De);gi.forEach(a),$t=o(xn," and "),Ye=h(xn,"SPAN",{});var yi=u(Ye);yi.forEach(a),Nt=o(xn," for all "),et=h(xn,"SPAN",{});var wr=u(et);wr.forEach(a),xn.forEach(a),Lt=S(y),F=h(y,"P",{});var lr=u(F);Ee=o(lr,"Notice that even though "),We=h(lr,"SPAN",{});var $i=u(We);$i.forEach(a),Rt=o(lr," the associated measurement probabilities "),He=h(lr,"SPAN",{});var Ni=u(He);Ni.forEach(a),qt=o(lr," for all "),on=h(lr,"SPAN",{});var ki=u(on);ki.forEach(a),At=o(lr," This is because the "),ue=h(lr,"SPAN",{});var qo=u(ue);qo.forEach(a),Ue=o(lr," term - as we saw in the section about the Bloch-sphere - indicates the qubit's phase and does not affect measurement probabilities."),lr.forEach(a),Ht=S(y),oe=h(y,"P",{});var at=u(oe);tt=o(at,"Just like the state of a single qubit can be the linear combination of "),xt=h(at,"SPAN",{});var Ei=u(xt);Ei.forEach(a),Dt=o(at," and "),lt=h(at,"SPAN",{});var Ti=u(lt);Ti.forEach(a),Wt=o(at," the state of these "),It=h(at,"SPAN",{});var Pi=u(It);Pi.forEach(a),Ft=o(at," qubits is essentially the linear combination of all the possible combinations of the "),un=h(at,"SPAN",{});var Mi=u(un);Mi.forEach(a),he=o(at," basis states - which, as we saw in the previous section, represent the integers from "),ye=h(at,"SPAN",{});var Jn=u(ye);Jn.forEach(a),tn=o(at," to "),Ut=h(at,"SPAN",{});var Si=u(Ut);Si.forEach(a),gn=o(at," Take a moment to appreciate this fact. We applied an operator to "),Zt=h(at,"SPAN",{});var qi=u(Zt);qi.forEach(a),yn=o(at," qubits to obtain a quantum system that represents "),zt=h(at,"SPAN",{});var Ai=u(zt);Ai.forEach(a),mn=o(at," numbers at the same time and is capable of performing computations on all of those numbers in parallel! This parallelism is one of the main properties that make quantum computers so powerful compared to classical ones. Since both basis states are measured with a probability of "),de=h(at,"SPAN",{});var Hi=u(de);Hi.forEach(a),Ot=o(at," for each qubit, any particular combination of the "),fn=h(at,"SPAN",{});var Li=u(fn);Li.forEach(a),Pn=o(at," basis states is measured with a probability of "),Fe=h(at,"SPAN",{});var xi=u(Fe);xi.forEach(a),pn=o(at," What differs across these combinations - and is an essential component of the QFT - is the phase, as we'll see in the next section."),at.forEach(a),Pt=S(y),Mt=h(y,"H2",{});var Ao=u(Mt);Fn=o(Ao,"QFT on the representation level"),Ao.forEach(a),Mn=S(y),nn=h(y,"P",{});var zs=u(nn);Qn=o(zs,"Let's denote the state of the entire sequence of qubits with "),cn=h(zs,"SPAN",{});var vn=u(cn);vn.forEach(a),zn=o(zs," and write it out as shown below:"),zs.forEach(a),Sn=S(y),Dn=h(y,"P",{});var Ho=u(Dn);Vt=h(Ho,"SPAN",{});var Ii=u(Vt);Ii.forEach(a),Ho.forEach(a),Vn=S(y),Ze=h(y,"P",{});var Ys=u(Ze);Bn=o(Ys,"We can factor out the "),$n=h(Ys,"SPAN",{});var Fi=u($n);Fi.forEach(a),Cn=o(Ys," term to get:"),Ys.forEach(a),Nn=S(y),ka=h(y,"P",{});var Lo=u(ka);_n=h(Lo,"SPAN",{});var Qi=u(_n);Qi.forEach(a),Lo.forEach(a),Ka=S(y),we=h(y,"P",{});var Xe=u(we);qn=o(Xe,"Let "),Ea=h(Xe,"SPAN",{});var zi=u(Ea);zi.forEach(a),An=o(Xe," denote the binary number represented by the "),Ta=h(Xe,"SPAN",{});var Vi=u(Ta);Vi.forEach(a),Un=o(Xe," qubits in a given basis state, and "),na=h(Xe,"SPAN",{});var gr=u(na);gr.forEach(a),$e=o(Xe," the "),dt=h(Xe,"SPAN",{});var Bi=u(dt);Bi.forEach(a),Jt=o(Xe,"-th digit of "),On=h(Xe,"SPAN",{});var Ci=u(On);Ci.forEach(a),ot=o(Xe," In other words, "),ha=h(Xe,"SPAN",{});var Ri=u(ha);Ri.forEach(a),Te=o(Xe,"\xA0if the "),Ce=h(Xe,"SPAN",{});var ji=u(Ce);ji.forEach(a),Ya=o(Xe,"-th qubit is in the "),Gn=h(Xe,"SPAN",{});var xo=u(Gn);xo.forEach(a),an=o(Xe," state, and "),Kn=h(Xe,"SPAN",{});var nt=u(Kn);nt.forEach(a),Za=o(Xe,"\xA0if it's in the "),Xt=h(Xe,"SPAN",{});var Di=u(Xt);Di.forEach(a),Er=o(Xe," state for all "),Ge=h(Xe,"SPAN",{});var Wi=u(Ge);Wi.forEach(a),Ur=o(Xe," Recalling our knowledge of binary numbers, we can write "),Pa=h(Xe,"SPAN",{});var Ui=u(Pa);Ui.forEach(a),Or=o(Xe," as the weighted sum of its digits: "),Ma=h(Xe,"SPAN",{});var Oi=u(Ma);Oi.forEach(a),Gr=o(Xe," Notice that the "),fa=h(Xe,"SPAN",{});var Gi=u(fa);Gi.forEach(a),Kr=o(Xe," term within the sum does not depend on "),pa=h(Xe,"SPAN",{});var Ki=u(pa);Ki.forEach(a),En=o(Xe," and so we can factor it out: "),Yn=h(Xe,"SPAN",{});var Yi=u(Yn);Yi.forEach(a),Ln=o(Xe," Remember this step, as it is going to be important shortly!"),Xe.forEach(a),ca=S(y),tr=h(y,"P",{});var Io=u(tr);Qe=o(Io,"Using this new notation, we can write the state of the qubits in the form of a sum instead of a product:"),Io.forEach(a),_a=S(y),nr=h(y,"P",{});var Fo=u(nr);Sa=h(Fo,"SPAN",{});var Zi=u(Sa);Zi.forEach(a),Fo.forEach(a),Tr=S(y),hn=h(y,"P",{});var _s=u(hn);da=o(_s,"In case you're wondering how the formula above can be derived from the definition we started with, note that for all "),rn=h(_s,"SPAN",{});var Ji=u(rn);Ji.forEach(a),Ie=o(_s," the term "),qa=h(_s,"SPAN",{});var Xi=u(qa);Xi.forEach(a),ws=o(_s," equals"),_s.forEach(a),Mr=S(y),ba=h(y,"UL",{});var Zs=u(ba);Sr=h(Zs,"LI",{});var Vs=u(Sr);qr=h(Vs,"SPAN",{});var el=u(qr);el.forEach(a),so=o(Vs," if "),Ar=h(Vs,"SPAN",{});var Qo=u(Ar);Qo.forEach(a),oo=o(Vs," and"),Vs.forEach(a),gs=S(Zs),Aa=h(Zs,"LI",{});var xa=u(Aa);ts=h(xa,"SPAN",{});var tl=u(ts);tl.forEach(a),Hr=o(xa," if "),ns=h(xa,"SPAN",{});var nl=u(ns);nl.forEach(a),xa.forEach(a),Zs.forEach(a),ur=S(y),as=h(y,"P",{});var zo=u(as);ys=o(zo,"which is exactly how we defined the QFT."),zo.forEach(a),mr=S(y),Ha=h(y,"P",{});var jr=u(Ha);$s=o(jr,"The "),Va=h(jr,"SPAN",{});var Vo=u(Va);Vo.forEach(a),Ns=o(jr," embedded summations might seem confusing at first, but what they actually do is iterate over all possible combinations of basis states. In the final sum, these are included with "),sr=h(jr,"EM",{});var sa=u(sr);ho=o(sa,"equal weight"),sa.forEach(a),ks=o(jr," (meaning they are measured with equal probability), but the composing basis states will have "),or=h(jr,"EM",{});var Bo=u(or);uo=o(Bo,"different phases"),Bo.forEach(a),Es=o(jr," in each combination, as already mentioned at the end of the previous section."),jr.forEach(a),fr=S(y),Lr=h(y,"P",{});var Js=u(Lr);Ts=o(Js,"Let's now define the "),ir=h(Js,"EM",{});var Co=u(ir);mo=o(Co,"phase of the combination"),Co.forEach(a),Ps=o(Js," as the product of the phases of individual qubits within that combination, and factor it out as shown below:"),Js.forEach(a),pr=S(y),rs=h(y,"P",{});var Ro=u(rs);xr=h(Ro,"SPAN",{});var al=u(xr);al.forEach(a),Ro.forEach(a),Ds=S(y),Ir=h(y,"P",{});var Ga=u(Ir);Ba=h(Ga,"SPAN",{});var rl=u(Ba);rl.forEach(a),Ga.forEach(a),Yr=S(y),Ca=h(y,"P",{});var jo=u(Ca);Ms=o(jo,"After making use of the product rule for exponents..."),jo.forEach(a),Zr=S(y),Tn=h(y,"P",{});var Do=u(Tn);Fr=h(Do,"SPAN",{});var sl=u(Fr);sl.forEach(a),Do.forEach(a),Ws=S(y),La=h(y,"P",{});var Xs=u(La);Qr=o(Xs,"and factoring out the "),is=h(Xs,"SPAN",{});var mh=u(is);mh.forEach(a),zr=o(Xs," term that does not depend on "),ls=h(Xs,"SPAN",{});var fh=u(ls);fh.forEach(a),Vr=o(Xs," we arrive at the formula below:"),Xs.forEach(a),Us=S(y),cr=h(y,"P",{});var kl=u(cr);Ra=h(kl,"SPAN",{});var ph=u(Ra);ph.forEach(a),kl.forEach(a),Jr=S(y),Je=h(y,"P",{});var Ia=u(Je);Ss=o(Ia,"Recall what I asked you to keep in mind a few paragraphs ago, and notice that the sum in the exponential "),ja=h(Ia,"SPAN",{});var ch=u(ja);ch.forEach(a),qs=o(Ia," is actually equal to "),Da=h(Ia,"SPAN",{});var _h=u(Da);_h.forEach(a),As=o(Ia," Thus, we can now replace the individual "),Wa=h(Ia,"SPAN",{});var dh=u(Wa);dh.forEach(a),Hs=o(Ia," digits with the number "),va=h(Ia,"SPAN",{});var bh=u(va);bh.forEach(a),Br=o(Ia," itself and the multiple, embedded summations with a single one that iterates over all possible values of "),hs=h(Ia,"SPAN",{});var vh=u(hs);vh.forEach(a),Cr=o(Ia," In addition, let's abbreviate the notation we used for the product of the basis states with "),us=h(Ia,"SPAN",{});var wh=u(us);wh.forEach(a),Rn=o(Ia," to finally obtain this way more elegant formula for the QFT:"),Ia.forEach(a),ms=S(y),Ua=h(y,"P",{});var El=u(Ua);fs=h(El,"SPAN",{});var gh=u(fs);gh.forEach(a),El.forEach(a),_r=S(y),ps=h(y,"P",{});var Tl=u(ps);Ls=o(Tl,"The elegance comes from the fact that it shows what the qubits represent on a symbolic level, as opposed to the expression we started with that is a direct insight into the bit-level implementation."),Tl.forEach(a),dr=S(y),jn=h(y,"P",{});var hr=u(jn);xs=o(hr,"Now let's illustrate visually what the formula above actually means. To give a proper intuition, we'll look at multiple systems with increasing number of qubits. For a chosen value of "),Oa=h(hr,"SPAN",{});var yh=u(Oa);yh.forEach(a),Is=o(hr," the plot below shows the "),br=h(hr,"SPAN",{});var $h=u(br);$h.forEach(a),Gs=o(hr," terms for all possible values of "),k=h(hr,"SPAN",{});var Nh=u(k);Nh.forEach(a),dn=o(hr," that these systems can represent. Because this term is a complex number, the geometric representation of which would require two dimensions, the real and imaginary components are shown separately. Notice that as the number of qubits increases, the plots gradually turn into sinusoidal wave patterns. Furthermore, the number of peaks of these waves - their frequency - equals "),vr=h(hr,"SPAN",{});var kh=u(vr);kh.forEach(a),go=o(hr," which you can verify by modifying "),cs=h(hr,"SPAN",{});var Eh=u(cs);Eh.forEach(a),en=o(hr," with the help of the slider."),hr.forEach(a)},m(y,te){g(y,n,te),t(n,r),g(y,i,te),g(y,m,te),t(m,d),g(y,_,te),g(y,c,te),t(c,v),t(c,b),b.innerHTML=E,t(c,w),t(c,N),N.innerHTML=$,t(c,I),t(c,Y),Y.innerHTML=U,t(c,L),t(c,C),C.innerHTML=V,t(c,H),t(c,q),q.innerHTML=D,g(y,X,te),g(y,A,te),t(A,se),Se(ee,A,null),t(A,j),t(A,T),T.innerHTML=x,t(A,ie),t(A,R),R.innerHTML=Q,t(A,G),t(A,me),me.innerHTML=ae,t(A,ze),t(A,le),le.innerHTML=K,t(A,P),t(A,re),re.innerHTML=ce,t(A,ct),t(A,ke),ke.innerHTML=Ve,g(y,yt,te),g(y,fe,te),t(fe,Le),g(y,rt,te),g(y,ve,te),t(ve,Ae),Se(Ke,ve,null),t(ve,_t),t(ve,ne),ne.innerHTML=_e,t(ve,st),t(ve,je),je.innerHTML=sn,t(ve,W),t(ve,pe),pe.innerHTML=Z,t(ve,ut),t(ve,Be),Be.innerHTML=Ct,t(ve,mt),t(ve,De),De.innerHTML=St,t(ve,$t),t(ve,Ye),Ye.innerHTML=Kt,t(ve,Nt),t(ve,et),et.innerHTML=kt,g(y,Lt,te),g(y,F,te),t(F,Ee),t(F,We),We.innerHTML=Et,t(F,Rt),t(F,He),He.innerHTML=bt,t(F,qt),t(F,on),on.innerHTML=Tt,t(F,At),t(F,ue),ue.innerHTML=wn,t(F,Ue),g(y,Ht,te),g(y,oe,te),t(oe,tt),t(oe,xt),xt.innerHTML=jt,t(oe,Dt),t(oe,lt),lt.innerHTML=Yt,t(oe,Wt),t(oe,It),It.innerHTML=ia,t(oe,Ft),t(oe,un),un.innerHTML=$a,t(oe,he),t(oe,ye),ye.innerHTML=ft,t(oe,tn),t(oe,Ut),Ut.innerHTML=Qt,t(oe,gn),t(oe,Zt),Zt.innerHTML=pt,t(oe,yn),t(oe,zt),zt.innerHTML=Qa,t(oe,mn),t(oe,de),de.innerHTML=za,t(oe,Ot),t(oe,fn),fn.innerHTML=Xn,t(oe,Pn),t(oe,Fe),Fe.innerHTML=In,t(oe,pn),g(y,Pt,te),g(y,Mt,te),t(Mt,Fn),g(y,Mn,te),g(y,nn,te),t(nn,Qn),t(nn,cn),cn.innerHTML=Gt,t(nn,zn),g(y,Sn,te),g(y,Dn,te),t(Dn,Vt),Vt.innerHTML=Na,g(y,Vn,te),g(y,Ze,te),t(Ze,Bn),t(Ze,$n),$n.innerHTML=ln,t(Ze,Cn),g(y,Nn,te),g(y,ka,te),t(ka,_n),_n.innerHTML=Wn,g(y,Ka,te),g(y,we,te),t(we,qn),t(we,Ea),Ea.innerHTML=ea,t(we,An),t(we,Ta),Ta.innerHTML=ta,t(we,Un),t(we,na),na.innerHTML=la,t(we,$e),t(we,dt),dt.innerHTML=Hn,t(we,Jt),t(we,On),On.innerHTML=ht,t(we,ot),t(we,ha),ha.innerHTML=z,t(we,Te),t(we,Ce),Ce.innerHTML=ua,t(we,Ya),t(we,Gn),Gn.innerHTML=aa,t(we,an),t(we,Kn),Kn.innerHTML=ma,t(we,Za),t(we,Xt),Xt.innerHTML=Ja,t(we,Er),t(we,Ge),Ge.innerHTML=Xa,t(we,Ur),t(we,Pa),Pa.innerHTML=vt,t(we,Or),t(we,Ma),Ma.innerHTML=er,t(we,Gr),t(we,fa),fa.innerHTML=xe,t(we,Kr),t(we,pa),pa.innerHTML=kn,t(we,En),t(we,Yn),Yn.innerHTML=vs,t(we,Ln),g(y,ca,te),g(y,tr,te),t(tr,Qe),g(y,_a,te),g(y,nr,te),t(nr,Sa),Sa.innerHTML=ar,g(y,Tr,te),g(y,hn,te),t(hn,da),t(hn,rn),rn.innerHTML=Pr,t(hn,Ie),t(hn,qa),qa.innerHTML=rr,t(hn,ws),g(y,Mr,te),g(y,ba,te),t(ba,Sr),t(Sr,qr),qr.innerHTML=Xr,t(Sr,so),t(Sr,Ar),Ar.innerHTML=es,t(Sr,oo),t(ba,gs),t(ba,Aa),t(Aa,ts),ts.innerHTML=io,t(Aa,Hr),t(Aa,ns),ns.innerHTML=lo,g(y,ur,te),g(y,as,te),t(as,ys),g(y,mr,te),g(y,Ha,te),t(Ha,$s),t(Ha,Va),Va.innerHTML=ti,t(Ha,Ns),t(Ha,sr),t(sr,ho),t(Ha,ks),t(Ha,or),t(or,uo),t(Ha,Es),g(y,fr,te),g(y,Lr,te),t(Lr,Ts),t(Lr,ir),t(ir,mo),t(Lr,Ps),g(y,pr,te),g(y,rs,te),t(rs,xr),xr.innerHTML=ss,g(y,Ds,te),g(y,Ir,te),t(Ir,Ba),Ba.innerHTML=ni,g(y,Yr,te),g(y,Ca,te),t(Ca,Ms),g(y,Zr,te),g(y,Tn,te),t(Tn,Fr),Fr.innerHTML=os,g(y,Ws,te),g(y,La,te),t(La,Qr),t(La,is),is.innerHTML=fo,t(La,zr),t(La,ls),ls.innerHTML=po,t(La,Vr),g(y,Us,te),g(y,cr,te),t(cr,Ra),Ra.innerHTML=co,g(y,Jr,te),g(y,Je,te),t(Je,Ss),t(Je,ja),ja.innerHTML=ai,t(Je,qs),t(Je,Da),Da.innerHTML=ri,t(Je,As),t(Je,Wa),Wa.innerHTML=si,t(Je,Hs),t(Je,va),va.innerHTML=_o,t(Je,Br),t(Je,hs),hs.innerHTML=bo,t(Je,Cr),t(Je,us),us.innerHTML=Os,t(Je,Rn),g(y,ms,te),g(y,Ua,te),t(Ua,fs),fs.innerHTML=vo,g(y,_r,te),g(y,ps,te),t(ps,Ls),g(y,dr,te),g(y,jn,te),t(jn,xs),t(jn,Oa),Oa.innerHTML=oi,t(jn,Is),t(jn,br),br.innerHTML=wo,t(jn,Gs),t(jn,k),k.innerHTML=ge,t(jn,dn),t(jn,vr),vr.innerHTML=ii,t(jn,go),t(jn,cs),cs.innerHTML=li,t(jn,en),Ks=!0,yo||(Po=[p(b,"mouseenter",e[0]),p(N,"mouseenter",e[1]),p(Y,"mouseenter",e[2]),p(C,"mouseenter",e[3]),p(q,"mouseenter",e[4]),p(T,"mouseenter",e[5]),p(R,"mouseenter",e[6]),p(me,"mouseenter",e[7]),p(le,"mouseenter",e[8]),p(re,"mouseenter",e[9]),p(ke,"mouseenter",e[10]),p(ne,"mouseenter",e[11]),p(je,"mouseenter",e[12]),p(pe,"mouseenter",e[13]),p(Be,"mouseenter",e[14]),p(De,"mouseenter",e[15]),p(Ye,"mouseenter",e[16]),p(et,"mouseenter",e[17]),p(We,"mouseenter",e[18]),p(He,"mouseenter",e[19]),p(on,"mouseenter",e[20]),p(ue,"mouseenter",e[21]),p(xt,"mouseenter",e[22]),p(lt,"mouseenter",e[23]),p(It,"mouseenter",e[24]),p(un,"mouseenter",e[25]),p(ye,"mouseenter",e[26]),p(Ut,"mouseenter",e[27]),p(Zt,"mouseenter",e[28]),p(zt,"mouseenter",e[29]),p(de,"mouseenter",e[30]),p(fn,"mouseenter",e[31]),p(Fe,"mouseenter",e[32]),p(cn,"mouseenter",e[33]),p(Vt,"mouseenter",e[34]),p($n,"mouseenter",e[35]),p(_n,"mouseenter",e[36]),p(Ea,"mouseenter",e[37]),p(Ta,"mouseenter",e[38]),p(na,"mouseenter",e[39]),p(dt,"mouseenter",e[40]),p(On,"mouseenter",e[41]),p(ha,"mouseenter",e[42]),p(Ce,"mouseenter",e[43]),p(Gn,"mouseenter",e[44]),p(Kn,"mouseenter",e[45]),p(Xt,"mouseenter",e[46]),p(Ge,"mouseenter",e[47]),p(Pa,"mouseenter",e[48]),p(Ma,"mouseenter",e[49]),p(fa,"mouseenter",e[50]),p(pa,"mouseenter",e[51]),p(Yn,"mouseenter",e[52]),p(Sa,"mouseenter",e[53]),p(rn,"mouseenter",e[54]),p(qa,"mouseenter",e[55]),p(qr,"mouseenter",e[56]),p(Ar,"mouseenter",e[57]),p(ts,"mouseenter",e[58]),p(ns,"mouseenter",e[59]),p(Va,"mouseenter",e[60]),p(xr,"mouseenter",e[61]),p(Ba,"mouseenter",e[62]),p(Fr,"mouseenter",e[63]),p(is,"mouseenter",e[64]),p(ls,"mouseenter",e[65]),p(Ra,"mouseenter",e[66]),p(ja,"mouseenter",e[67]),p(Da,"mouseenter",e[68]),p(Wa,"mouseenter",e[69]),p(va,"mouseenter",e[70]),p(hs,"mouseenter",e[71]),p(us,"mouseenter",e[72]),p(fs,"mouseenter",e[73]),p(Oa,"mouseenter",e[74]),p(br,"mouseenter",e[75]),p(k,"mouseenter",e[76]),p(vr,"mouseenter",e[77]),p(cs,"mouseenter",e[78])],yo=!0)},p(y,te){const Fs={};te[2]&131072&&(Fs.$$scope={dirty:te,ctx:y}),ee.$set(Fs);const ra={};te[2]&131072&&(ra.$$scope={dirty:te,ctx:y}),Ke.$set(ra)},i(y){Ks||(be(ee.$$.fragment,y),be(Ke.$$.fragment,y),Ks=!0)},o(y){Ne(ee.$$.fragment,y),Ne(Ke.$$.fragment,y),Ks=!1},d(y){y&&a(n),y&&a(i),y&&a(m),y&&a(_),y&&a(c),y&&a(X),y&&a(A),qe(ee),y&&a(yt),y&&a(fe),y&&a(rt),y&&a(ve),qe(Ke),y&&a(Lt),y&&a(F),y&&a(Ht),y&&a(oe),y&&a(Pt),y&&a(Mt),y&&a(Mn),y&&a(nn),y&&a(Sn),y&&a(Dn),y&&a(Vn),y&&a(Ze),y&&a(Nn),y&&a(ka),y&&a(Ka),y&&a(we),y&&a(ca),y&&a(tr),y&&a(_a),y&&a(nr),y&&a(Tr),y&&a(hn),y&&a(Mr),y&&a(ba),y&&a(ur),y&&a(as),y&&a(mr),y&&a(Ha),y&&a(fr),y&&a(Lr),y&&a(pr),y&&a(rs),y&&a(Ds),y&&a(Ir),y&&a(Yr),y&&a(Ca),y&&a(Zr),y&&a(Tn),y&&a(Ws),y&&a(La),y&&a(Us),y&&a(cr),y&&a(Jr),y&&a(Je),y&&a(ms),y&&a(Ua),y&&a(_r),y&&a(ps),y&&a(dr),y&&a(jn),yo=!1,kr(Po)}}}function J(e){console.log(e)}function Au(e){return[()=>J(["n"]),()=>J([]),()=>J([]),()=>J(["m","n","s","t"]),()=>J(["n","N"]),()=>J([]),()=>J(["N"]),()=>J(["n"]),()=>J([]),()=>J([]),()=>J([]),()=>J(["x"]),()=>J(["x"]),()=>J(["k"]),()=>J(["x","k"]),()=>J(["k","\\alpha"]),()=>J(["\\beta","x","k"]),()=>J(["k","n"]),()=>J(["\\beta","k","\\alpha"]),()=>J(["\\beta","k","\\alpha"]),()=>J(["k","n"]),()=>J(["x","k"]),()=>J([]),()=>J([]),()=>J(["n"]),()=>J(["n"]),()=>J([]),()=>J(["N"]),()=>J(["n"]),()=>J(["n"]),()=>J([]),()=>J(["n"]),()=>J(["m","s","n","r","t","N"]),()=>J(["\\psi"]),()=>J(["m","s","\\psi","n","r","t","x"]),()=>J([]),()=>J(["\\psi","x","n","N"]),()=>J(["y"]),()=>J(["n"]),()=>J(["y","k"]),()=>J(["k"]),()=>J(["y"]),()=>J(["y","k"]),()=>J(["k"]),()=>J([]),()=>J(["y","k"]),()=>J([]),()=>J(["k","n"]),()=>J(["y"]),()=>J(["y","k","n"]),()=>J(["n"]),()=>J(["k"]),()=>J(["y","k","n","N"]),()=>J(["m","s","\\psi","n","r","t","y","x","N"]),()=>J(["k"]),()=>J(["y","x","k"]),()=>J(["x","k"]),()=>J(["y","k"]),()=>J(["x","k"]),()=>J(["y","k"]),()=>J(["n"]),()=>J(["\\psi","n","y","x","N"]),()=>J(["\\psi","k","n","y","x","N"]),()=>J(["\\psi","k","n","y","x","N"]),()=>J(["x"]),()=>J(["k"]),()=>J(["\\psi","k","n","y","x","N"]),()=>J(["y","k","n"]),()=>J(["y","N"]),()=>J(["y","k"]),()=>J(["y"]),()=>J(["y"]),()=>J(["y","n"]),()=>J(["\\psi","x","y","N"]),()=>J(["x"]),()=>J(["y","x","N"]),()=>J(["y"]),()=>J(["x"]),()=>J(["x"])]}class Hu extends wa{constructor(n){super(),ga(this,n,Au,qu,ya,{},null,[-1,-1,-1])}}function Ko(e,n){return e==null||n==null?NaN:e<n?-1:e>n?1:e>=n?0:NaN}function Lu(e,n){return e==null||n==null?NaN:n<e?-1:n>e?1:n>=e?0:NaN}function th(e){let n,r,i;e.length!==2?(n=Ko,r=(c,v)=>Ko(e(c),v),i=(c,v)=>e(c)-v):(n=e===Ko||e===Lu?e:xu,r=e,i=e);function m(c,v,b=0,E=c.length){if(b<E){if(n(v,v)!==0)return E;do{const w=b+E>>>1;r(c[w],v)<0?b=w+1:E=w}while(b<E)}return b}function d(c,v,b=0,E=c.length){if(b<E){if(n(v,v)!==0)return E;do{const w=b+E>>>1;r(c[w],v)<=0?b=w+1:E=w}while(b<E)}return b}function _(c,v,b=0,E=c.length){const w=m(c,v,b,E-1);return w>b&&i(c[w-1],v)>-i(c[w],v)?w-1:w}return{left:m,center:_,right:d}}function xu(){return 0}function Iu(e){return e===null?NaN:+e}const Fu=th(Ko),Qu=Fu.right;th(Iu).center;const zu=Qu;function Hl(e,n){let r,i;if(n===void 0)for(const m of e)m!=null&&(r===void 0?m>=m&&(r=i=m):(r>m&&(r=m),i<m&&(i=m)));else{let m=-1;for(let d of e)(d=n(d,++m,e))!=null&&(r===void 0?d>=d&&(r=i=d):(r>d&&(r=d),i<d&&(i=d)))}return[r,i]}var hl=Math.sqrt(50),ul=Math.sqrt(10),ml=Math.sqrt(2);function Vu(e,n,r){var i,m=-1,d,_,c;if(n=+n,e=+e,r=+r,e===n&&r>0)return[e];if((i=n<e)&&(d=e,e=n,n=d),(c=nh(e,n,r))===0||!isFinite(c))return[];if(c>0){let v=Math.round(e/c),b=Math.round(n/c);for(v*c<e&&++v,b*c>n&&--b,_=new Array(d=b-v+1);++m<d;)_[m]=(v+m)*c}else{c=-c;let v=Math.round(e*c),b=Math.round(n*c);for(v/c<e&&++v,b/c>n&&--b,_=new Array(d=b-v+1);++m<d;)_[m]=(v+m)/c}return i&&_.reverse(),_}function nh(e,n,r){var i=(n-e)/Math.max(0,r),m=Math.floor(Math.log(i)/Math.LN10),d=i/Math.pow(10,m);return m>=0?(d>=hl?10:d>=ul?5:d>=ml?2:1)*Math.pow(10,m):-Math.pow(10,-m)/(d>=hl?10:d>=ul?5:d>=ml?2:1)}function Bu(e,n,r){var i=Math.abs(n-e)/Math.max(0,r),m=Math.pow(10,Math.floor(Math.log(i)/Math.LN10)),d=i/m;return d>=hl?m*=10:d>=ul?m*=5:d>=ml&&(m*=2),n<e?-m:m}function Cu(e,n){switch(arguments.length){case 0:break;case 1:this.range(e);break;default:this.range(n).domain(e);break}return this}function gl(e,n,r){e.prototype=n.prototype=r,r.constructor=e}function ah(e,n){var r=Object.create(e.prototype);for(var i in n)r[i]=n[i];return r}function To(){}var No=.7,Yo=1/No,ao="\\s*([+-]?\\d+)\\s*",ko="\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",Wr="\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",Ru=/^#([0-9a-f]{3,8})$/,ju=new RegExp(`^rgb\\(${ao},${ao},${ao}\\)$`),Du=new RegExp(`^rgb\\(${Wr},${Wr},${Wr}\\)$`),Wu=new RegExp(`^rgba\\(${ao},${ao},${ao},${ko}\\)$`),Uu=new RegExp(`^rgba\\(${Wr},${Wr},${Wr},${ko}\\)$`),Ou=new RegExp(`^hsl\\(${ko},${Wr},${Wr}\\)$`),Gu=new RegExp(`^hsla\\(${ko},${Wr},${Wr},${ko}\\)$`),Ll={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074};gl(To,Eo,{copy(e){return Object.assign(new this.constructor,this,e)},displayable(){return this.rgb().displayable()},hex:xl,formatHex:xl,formatHex8:Ku,formatHsl:Yu,formatRgb:Il,toString:Il});function xl(){return this.rgb().formatHex()}function Ku(){return this.rgb().formatHex8()}function Yu(){return rh(this).formatHsl()}function Il(){return this.rgb().formatRgb()}function Eo(e){var n,r;return e=(e+"").trim().toLowerCase(),(n=Ru.exec(e))?(r=n[1].length,n=parseInt(n[1],16),r===6?Fl(n):r===3?new Fa(n>>8&15|n>>4&240,n>>4&15|n&240,(n&15)<<4|n&15,1):r===8?Uo(n>>24&255,n>>16&255,n>>8&255,(n&255)/255):r===4?Uo(n>>12&15|n>>8&240,n>>8&15|n>>4&240,n>>4&15|n&240,((n&15)<<4|n&15)/255):null):(n=ju.exec(e))?new Fa(n[1],n[2],n[3],1):(n=Du.exec(e))?new Fa(n[1]*255/100,n[2]*255/100,n[3]*255/100,1):(n=Wu.exec(e))?Uo(n[1],n[2],n[3],n[4]):(n=Uu.exec(e))?Uo(n[1]*255/100,n[2]*255/100,n[3]*255/100,n[4]):(n=Ou.exec(e))?Vl(n[1],n[2]/100,n[3]/100,1):(n=Gu.exec(e))?Vl(n[1],n[2]/100,n[3]/100,n[4]):Ll.hasOwnProperty(e)?Fl(Ll[e]):e==="transparent"?new Fa(NaN,NaN,NaN,0):null}function Fl(e){return new Fa(e>>16&255,e>>8&255,e&255,1)}function Uo(e,n,r,i){return i<=0&&(e=n=r=NaN),new Fa(e,n,r,i)}function Zu(e){return e instanceof To||(e=Eo(e)),e?(e=e.rgb(),new Fa(e.r,e.g,e.b,e.opacity)):new Fa}function fl(e,n,r,i){return arguments.length===1?Zu(e):new Fa(e,n,r,i==null?1:i)}function Fa(e,n,r,i){this.r=+e,this.g=+n,this.b=+r,this.opacity=+i}gl(Fa,fl,ah(To,{brighter(e){return e=e==null?Yo:Math.pow(Yo,e),new Fa(this.r*e,this.g*e,this.b*e,this.opacity)},darker(e){return e=e==null?No:Math.pow(No,e),new Fa(this.r*e,this.g*e,this.b*e,this.opacity)},rgb(){return this},clamp(){return new Fa(Rs(this.r),Rs(this.g),Rs(this.b),Zo(this.opacity))},displayable(){return-.5<=this.r&&this.r<255.5&&-.5<=this.g&&this.g<255.5&&-.5<=this.b&&this.b<255.5&&0<=this.opacity&&this.opacity<=1},hex:Ql,formatHex:Ql,formatHex8:Ju,formatRgb:zl,toString:zl}));function Ql(){return`#${Cs(this.r)}${Cs(this.g)}${Cs(this.b)}`}function Ju(){return`#${Cs(this.r)}${Cs(this.g)}${Cs(this.b)}${Cs((isNaN(this.opacity)?1:this.opacity)*255)}`}function zl(){const e=Zo(this.opacity);return`${e===1?"rgb(":"rgba("}${Rs(this.r)}, ${Rs(this.g)}, ${Rs(this.b)}${e===1?")":`, ${e})`}`}function Zo(e){return isNaN(e)?1:Math.max(0,Math.min(1,e))}function Rs(e){return Math.max(0,Math.min(255,Math.round(e)||0))}function Cs(e){return e=Rs(e),(e<16?"0":"")+e.toString(16)}function Vl(e,n,r,i){return i<=0?e=n=r=NaN:r<=0||r>=1?e=n=NaN:n<=0&&(e=NaN),new Nr(e,n,r,i)}function rh(e){if(e instanceof Nr)return new Nr(e.h,e.s,e.l,e.opacity);if(e instanceof To||(e=Eo(e)),!e)return new Nr;if(e instanceof Nr)return e;e=e.rgb();var n=e.r/255,r=e.g/255,i=e.b/255,m=Math.min(n,r,i),d=Math.max(n,r,i),_=NaN,c=d-m,v=(d+m)/2;return c?(n===d?_=(r-i)/c+(r<i)*6:r===d?_=(i-n)/c+2:_=(n-r)/c+4,c/=v<.5?d+m:2-d-m,_*=60):c=v>0&&v<1?0:_,new Nr(_,c,v,e.opacity)}function Xu(e,n,r,i){return arguments.length===1?rh(e):new Nr(e,n,r,i==null?1:i)}function Nr(e,n,r,i){this.h=+e,this.s=+n,this.l=+r,this.opacity=+i}gl(Nr,Xu,ah(To,{brighter(e){return e=e==null?Yo:Math.pow(Yo,e),new Nr(this.h,this.s,this.l*e,this.opacity)},darker(e){return e=e==null?No:Math.pow(No,e),new Nr(this.h,this.s,this.l*e,this.opacity)},rgb(){var e=this.h%360+(this.h<0)*360,n=isNaN(e)||isNaN(this.s)?0:this.s,r=this.l,i=r+(r<.5?r:1-r)*n,m=2*r-i;return new Fa(ol(e>=240?e-240:e+120,m,i),ol(e,m,i),ol(e<120?e+240:e-120,m,i),this.opacity)},clamp(){return new Nr(Bl(this.h),Oo(this.s),Oo(this.l),Zo(this.opacity))},displayable(){return(0<=this.s&&this.s<=1||isNaN(this.s))&&0<=this.l&&this.l<=1&&0<=this.opacity&&this.opacity<=1},formatHsl(){const e=Zo(this.opacity);return`${e===1?"hsl(":"hsla("}${Bl(this.h)}, ${Oo(this.s)*100}%, ${Oo(this.l)*100}%${e===1?")":`, ${e})`}`}}));function Bl(e){return e=(e||0)%360,e<0?e+360:e}function Oo(e){return Math.max(0,Math.min(1,e||0))}function ol(e,n,r){return(e<60?n+(r-n)*e/60:e<180?r:e<240?n+(r-n)*(240-e)/60:n)*255}const yl=e=>()=>e;function em(e,n){return function(r){return e+r*n}}function tm(e,n,r){return e=Math.pow(e,r),n=Math.pow(n,r)-e,r=1/r,function(i){return Math.pow(e+i*n,r)}}function nm(e){return(e=+e)==1?sh:function(n,r){return r-n?tm(n,r,e):yl(isNaN(n)?r:n)}}function sh(e,n){var r=n-e;return r?em(e,r):yl(isNaN(e)?n:e)}const Cl=function e(n){var r=nm(n);function i(m,d){var _=r((m=fl(m)).r,(d=fl(d)).r),c=r(m.g,d.g),v=r(m.b,d.b),b=sh(m.opacity,d.opacity);return function(E){return m.r=_(E),m.g=c(E),m.b=v(E),m.opacity=b(E),m+""}}return i.gamma=e,i}(1);function am(e,n){n||(n=[]);var r=e?Math.min(n.length,e.length):0,i=n.slice(),m;return function(d){for(m=0;m<r;++m)i[m]=e[m]*(1-d)+n[m]*d;return i}}function rm(e){return ArrayBuffer.isView(e)&&!(e instanceof DataView)}function sm(e,n){var r=n?n.length:0,i=e?Math.min(r,e.length):0,m=new Array(i),d=new Array(r),_;for(_=0;_<i;++_)m[_]=$l(e[_],n[_]);for(;_<r;++_)d[_]=n[_];return function(c){for(_=0;_<i;++_)d[_]=m[_](c);return d}}function om(e,n){var r=new Date;return e=+e,n=+n,function(i){return r.setTime(e*(1-i)+n*i),r}}function Jo(e,n){return e=+e,n=+n,function(r){return e*(1-r)+n*r}}function im(e,n){var r={},i={},m;(e===null||typeof e!="object")&&(e={}),(n===null||typeof n!="object")&&(n={});for(m in n)m in e?r[m]=$l(e[m],n[m]):i[m]=n[m];return function(d){for(m in r)i[m]=r[m](d);return i}}var pl=/[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,il=new RegExp(pl.source,"g");function lm(e){return function(){return e}}function hm(e){return function(n){return e(n)+""}}function um(e,n){var r=pl.lastIndex=il.lastIndex=0,i,m,d,_=-1,c=[],v=[];for(e=e+"",n=n+"";(i=pl.exec(e))&&(m=il.exec(n));)(d=m.index)>r&&(d=n.slice(r,d),c[_]?c[_]+=d:c[++_]=d),(i=i[0])===(m=m[0])?c[_]?c[_]+=m:c[++_]=m:(c[++_]=null,v.push({i:_,x:Jo(i,m)})),r=il.lastIndex;return r<n.length&&(d=n.slice(r),c[_]?c[_]+=d:c[++_]=d),c.length<2?v[0]?hm(v[0].x):lm(n):(n=v.length,function(b){for(var E=0,w;E<n;++E)c[(w=v[E]).i]=w.x(b);return c.join("")})}function $l(e,n){var r=typeof n,i;return n==null||r==="boolean"?yl(n):(r==="number"?Jo:r==="string"?(i=Eo(n))?(n=i,Cl):um:n instanceof Eo?Cl:n instanceof Date?om:rm(n)?am:Array.isArray(n)?sm:typeof n.valueOf!="function"&&typeof n.toString!="function"||isNaN(n)?im:Jo)(e,n)}function mm(e,n){return e=+e,n=+n,function(r){return Math.round(e*(1-r)+n*r)}}function fm(e){return function(){return e}}function pm(e){return+e}var Rl=[0,1];function no(e){return e}function cl(e,n){return(n-=e=+e)?function(r){return(r-e)/n}:fm(isNaN(n)?NaN:.5)}function cm(e,n){var r;return e>n&&(r=e,e=n,n=r),function(i){return Math.max(e,Math.min(n,i))}}function _m(e,n,r){var i=e[0],m=e[1],d=n[0],_=n[1];return m<i?(i=cl(m,i),d=r(_,d)):(i=cl(i,m),d=r(d,_)),function(c){return d(i(c))}}function dm(e,n,r){var i=Math.min(e.length,n.length)-1,m=new Array(i),d=new Array(i),_=-1;for(e[i]<e[0]&&(e=e.slice().reverse(),n=n.slice().reverse());++_<i;)m[_]=cl(e[_],e[_+1]),d[_]=r(n[_],n[_+1]);return function(c){var v=zu(e,c,1,i)-1;return d[v](m[v](c))}}function bm(e,n){return n.domain(e.domain()).range(e.range()).interpolate(e.interpolate()).clamp(e.clamp()).unknown(e.unknown())}function vm(){var e=Rl,n=Rl,r=$l,i,m,d,_=no,c,v,b;function E(){var N=Math.min(e.length,n.length);return _!==no&&(_=cm(e[0],e[N-1])),c=N>2?dm:_m,v=b=null,w}function w(N){return N==null||isNaN(N=+N)?d:(v||(v=c(e.map(i),n,r)))(i(_(N)))}return w.invert=function(N){return _(m((b||(b=c(n,e.map(i),Jo)))(N)))},w.domain=function(N){return arguments.length?(e=Array.from(N,pm),E()):e.slice()},w.range=function(N){return arguments.length?(n=Array.from(N),E()):n.slice()},w.rangeRound=function(N){return n=Array.from(N),r=mm,E()},w.clamp=function(N){return arguments.length?(_=N?!0:no,E()):_!==no},w.interpolate=function(N){return arguments.length?(r=N,E()):r},w.unknown=function(N){return arguments.length?(d=N,w):d},function(N,$){return i=N,m=$,E()}}function wm(){return vm()(no,no)}function gm(e){return Math.abs(e=Math.round(e))>=1e21?e.toLocaleString("en").replace(/,/g,""):e.toString(10)}function Xo(e,n){if((r=(e=n?e.toExponential(n-1):e.toExponential()).indexOf("e"))<0)return null;var r,i=e.slice(0,r);return[i.length>1?i[0]+i.slice(2):i,+e.slice(r+1)]}function ro(e){return e=Xo(Math.abs(e)),e?e[1]:NaN}function ym(e,n){return function(r,i){for(var m=r.length,d=[],_=0,c=e[0],v=0;m>0&&c>0&&(v+c+1>i&&(c=Math.max(1,i-v)),d.push(r.substring(m-=c,m+c)),!((v+=c+1)>i));)c=e[_=(_+1)%e.length];return d.reverse().join(n)}}function $m(e){return function(n){return n.replace(/[0-9]/g,function(r){return e[+r]})}}var Nm=/^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;function ei(e){if(!(n=Nm.exec(e)))throw new Error("invalid format: "+e);var n;return new Nl({fill:n[1],align:n[2],sign:n[3],symbol:n[4],zero:n[5],width:n[6],comma:n[7],precision:n[8]&&n[8].slice(1),trim:n[9],type:n[10]})}ei.prototype=Nl.prototype;function Nl(e){this.fill=e.fill===void 0?" ":e.fill+"",this.align=e.align===void 0?">":e.align+"",this.sign=e.sign===void 0?"-":e.sign+"",this.symbol=e.symbol===void 0?"":e.symbol+"",this.zero=!!e.zero,this.width=e.width===void 0?void 0:+e.width,this.comma=!!e.comma,this.precision=e.precision===void 0?void 0:+e.precision,this.trim=!!e.trim,this.type=e.type===void 0?"":e.type+""}Nl.prototype.toString=function(){return this.fill+this.align+this.sign+this.symbol+(this.zero?"0":"")+(this.width===void 0?"":Math.max(1,this.width|0))+(this.comma?",":"")+(this.precision===void 0?"":"."+Math.max(0,this.precision|0))+(this.trim?"~":"")+this.type};function km(e){e:for(var n=e.length,r=1,i=-1,m;r<n;++r)switch(e[r]){case".":i=m=r;break;case"0":i===0&&(i=r),m=r;break;default:if(!+e[r])break e;i>0&&(i=0);break}return i>0?e.slice(0,i)+e.slice(m+1):e}var oh;function Em(e,n){var r=Xo(e,n);if(!r)return e+"";var i=r[0],m=r[1],d=m-(oh=Math.max(-8,Math.min(8,Math.floor(m/3)))*3)+1,_=i.length;return d===_?i:d>_?i+new Array(d-_+1).join("0"):d>0?i.slice(0,d)+"."+i.slice(d):"0."+new Array(1-d).join("0")+Xo(e,Math.max(0,n+d-1))[0]}function jl(e,n){var r=Xo(e,n);if(!r)return e+"";var i=r[0],m=r[1];return m<0?"0."+new Array(-m).join("0")+i:i.length>m+1?i.slice(0,m+1)+"."+i.slice(m+1):i+new Array(m-i.length+2).join("0")}const Dl={"%":(e,n)=>(e*100).toFixed(n),b:e=>Math.round(e).toString(2),c:e=>e+"",d:gm,e:(e,n)=>e.toExponential(n),f:(e,n)=>e.toFixed(n),g:(e,n)=>e.toPrecision(n),o:e=>Math.round(e).toString(8),p:(e,n)=>jl(e*100,n),r:jl,s:Em,X:e=>Math.round(e).toString(16).toUpperCase(),x:e=>Math.round(e).toString(16)};function Wl(e){return e}var Ul=Array.prototype.map,Ol=["y","z","a","f","p","n","\xB5","m","","k","M","G","T","P","E","Z","Y"];function Tm(e){var n=e.grouping===void 0||e.thousands===void 0?Wl:ym(Ul.call(e.grouping,Number),e.thousands+""),r=e.currency===void 0?"":e.currency[0]+"",i=e.currency===void 0?"":e.currency[1]+"",m=e.decimal===void 0?".":e.decimal+"",d=e.numerals===void 0?Wl:$m(Ul.call(e.numerals,String)),_=e.percent===void 0?"%":e.percent+"",c=e.minus===void 0?"\u2212":e.minus+"",v=e.nan===void 0?"NaN":e.nan+"";function b(w){w=ei(w);var N=w.fill,$=w.align,I=w.sign,Y=w.symbol,U=w.zero,L=w.width,C=w.comma,V=w.precision,H=w.trim,q=w.type;q==="n"?(C=!0,q="g"):Dl[q]||(V===void 0&&(V=12),H=!0,q="g"),(U||N==="0"&&$==="=")&&(U=!0,N="0",$="=");var D=Y==="$"?r:Y==="#"&&/[boxX]/.test(q)?"0"+q.toLowerCase():"",X=Y==="$"?i:/[%p]/.test(q)?_:"",A=Dl[q],se=/[defgprs%]/.test(q);V=V===void 0?6:/[gprs]/.test(q)?Math.max(1,Math.min(21,V)):Math.max(0,Math.min(20,V));function ee(j){var T=D,x=X,ie,R,Q;if(q==="c")x=A(j)+x,j="";else{j=+j;var G=j<0||1/j<0;if(j=isNaN(j)?v:A(Math.abs(j),V),H&&(j=km(j)),G&&+j==0&&I!=="+"&&(G=!1),T=(G?I==="("?I:c:I==="-"||I==="("?"":I)+T,x=(q==="s"?Ol[8+oh/3]:"")+x+(G&&I==="("?")":""),se){for(ie=-1,R=j.length;++ie<R;)if(Q=j.charCodeAt(ie),48>Q||Q>57){x=(Q===46?m+j.slice(ie+1):j.slice(ie))+x,j=j.slice(0,ie);break}}}C&&!U&&(j=n(j,1/0));var me=T.length+j.length+x.length,ae=me<L?new Array(L-me+1).join(N):"";switch(C&&U&&(j=n(ae+j,ae.length?L-x.length:1/0),ae=""),$){case"<":j=T+j+x+ae;break;case"=":j=T+ae+j+x;break;case"^":j=ae.slice(0,me=ae.length>>1)+T+j+x+ae.slice(me);break;default:j=ae+T+j+x;break}return d(j)}return ee.toString=function(){return w+""},ee}function E(w,N){var $=b((w=ei(w),w.type="f",w)),I=Math.max(-8,Math.min(8,Math.floor(ro(N)/3)))*3,Y=Math.pow(10,-I),U=Ol[8+I/3];return function(L){return $(Y*L)+U}}return{format:b,formatPrefix:E}}var Go,ih,lh;Pm({thousands:",",grouping:[3],currency:["$",""]});function Pm(e){return Go=Tm(e),ih=Go.format,lh=Go.formatPrefix,Go}function Mm(e){return Math.max(0,-ro(Math.abs(e)))}function Sm(e,n){return Math.max(0,Math.max(-8,Math.min(8,Math.floor(ro(n)/3)))*3-ro(Math.abs(e)))}function qm(e,n){return e=Math.abs(e),n=Math.abs(n)-e,Math.max(0,ro(n)-ro(e))+1}function Am(e,n,r,i){var m=Bu(e,n,r),d;switch(i=ei(i==null?",f":i),i.type){case"s":{var _=Math.max(Math.abs(e),Math.abs(n));return i.precision==null&&!isNaN(d=Sm(m,_))&&(i.precision=d),lh(i,_)}case"":case"e":case"g":case"p":case"r":{i.precision==null&&!isNaN(d=qm(m,Math.max(Math.abs(e),Math.abs(n))))&&(i.precision=d-(i.type==="e"));break}case"f":case"%":{i.precision==null&&!isNaN(d=Mm(m))&&(i.precision=d-(i.type==="%")*2);break}}return ih(i)}function Hm(e){var n=e.domain;return e.ticks=function(r){var i=n();return Vu(i[0],i[i.length-1],r==null?10:r)},e.tickFormat=function(r,i){var m=n();return Am(m[0],m[m.length-1],r==null?10:r,i)},e.nice=function(r){r==null&&(r=10);var i=n(),m=0,d=i.length-1,_=i[m],c=i[d],v,b,E=10;for(c<_&&(b=_,_=c,c=b,b=m,m=d,d=b);E-- >0;){if(b=nh(_,c,r),b===v)return i[m]=_,i[d]=c,n(i);if(b>0)_=Math.floor(_/b)*b,c=Math.ceil(c/b)*b;else if(b<0)_=Math.ceil(_*b)/b,c=Math.floor(c*b)/b;else break;v=b}return e},e}function _l(){var e=wm();return e.copy=function(){return bm(e,_l())},Cu.apply(e,arguments),Hm(e)}const dl=Math.PI,bl=2*dl,Bs=1e-6,Lm=bl-Bs;function vl(){this._x0=this._y0=this._x1=this._y1=null,this._=""}function hh(){return new vl}vl.prototype=hh.prototype={constructor:vl,moveTo:function(e,n){this._+="M"+(this._x0=this._x1=+e)+","+(this._y0=this._y1=+n)},closePath:function(){this._x1!==null&&(this._x1=this._x0,this._y1=this._y0,this._+="Z")},lineTo:function(e,n){this._+="L"+(this._x1=+e)+","+(this._y1=+n)},quadraticCurveTo:function(e,n,r,i){this._+="Q"+ +e+","+ +n+","+(this._x1=+r)+","+(this._y1=+i)},bezierCurveTo:function(e,n,r,i,m,d){this._+="C"+ +e+","+ +n+","+ +r+","+ +i+","+(this._x1=+m)+","+(this._y1=+d)},arcTo:function(e,n,r,i,m){e=+e,n=+n,r=+r,i=+i,m=+m;var d=this._x1,_=this._y1,c=r-e,v=i-n,b=d-e,E=_-n,w=b*b+E*E;if(m<0)throw new Error("negative radius: "+m);if(this._x1===null)this._+="M"+(this._x1=e)+","+(this._y1=n);else if(w>Bs)if(!(Math.abs(E*c-v*b)>Bs)||!m)this._+="L"+(this._x1=e)+","+(this._y1=n);else{var N=r-d,$=i-_,I=c*c+v*v,Y=N*N+$*$,U=Math.sqrt(I),L=Math.sqrt(w),C=m*Math.tan((dl-Math.acos((I+w-Y)/(2*U*L)))/2),V=C/L,H=C/U;Math.abs(V-1)>Bs&&(this._+="L"+(e+V*b)+","+(n+V*E)),this._+="A"+m+","+m+",0,0,"+ +(E*N>b*$)+","+(this._x1=e+H*c)+","+(this._y1=n+H*v)}},arc:function(e,n,r,i,m,d){e=+e,n=+n,r=+r,d=!!d;var _=r*Math.cos(i),c=r*Math.sin(i),v=e+_,b=n+c,E=1^d,w=d?i-m:m-i;if(r<0)throw new Error("negative radius: "+r);this._x1===null?this._+="M"+v+","+b:(Math.abs(this._x1-v)>Bs||Math.abs(this._y1-b)>Bs)&&(this._+="L"+v+","+b),r&&(w<0&&(w=w%bl+bl),w>Lm?this._+="A"+r+","+r+",0,1,"+E+","+(e-_)+","+(n-c)+"A"+r+","+r+",0,1,"+E+","+(this._x1=v)+","+(this._y1=b):w>Bs&&(this._+="A"+r+","+r+",0,"+ +(w>=dl)+","+E+","+(this._x1=e+r*Math.cos(m))+","+(this._y1=n+r*Math.sin(m))))},rect:function(e,n,r,i){this._+="M"+(this._x0=this._x1=+e)+","+(this._y0=this._y1=+n)+"h"+ +r+"v"+ +i+"h"+-r+"Z"},toString:function(){return this._}};function eo(e){return function(){return e}}function xm(e){return typeof e=="object"&&"length"in e?e:Array.from(e)}function uh(e){this._context=e}uh.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._point=0},lineEnd:function(){(this._line||this._line!==0&&this._point===1)&&this._context.closePath(),this._line=1-this._line},point:function(e,n){switch(e=+e,n=+n,this._point){case 0:this._point=1,this._line?this._context.lineTo(e,n):this._context.moveTo(e,n);break;case 1:this._point=2;default:this._context.lineTo(e,n);break}}};function Im(e){return new uh(e)}function Fm(e){return e[0]}function Qm(e){return e[1]}function zm(e,n){var r=eo(!0),i=null,m=Im,d=null;e=typeof e=="function"?e:e===void 0?Fm:eo(e),n=typeof n=="function"?n:n===void 0?Qm:eo(n);function _(c){var v,b=(c=xm(c)).length,E,w=!1,N;for(i==null&&(d=m(N=hh())),v=0;v<=b;++v)!(v<b&&r(E=c[v],v,c))===w&&((w=!w)?d.lineStart():d.lineEnd()),w&&d.point(+e(E,v,c),+n(E,v,c));if(N)return d=null,N+""||null}return _.x=function(c){return arguments.length?(e=typeof c=="function"?c:eo(+c),_):e},_.y=function(c){return arguments.length?(n=typeof c=="function"?c:eo(+c),_):n},_.defined=function(c){return arguments.length?(r=typeof c=="function"?c:eo(!!c),_):r},_.curve=function(c){return arguments.length?(m=c,i!=null&&(d=m(i)),_):m},_.context=function(c){return arguments.length?(c==null?i=d=null:d=m(i=c),_):i},_}function Gl(e,n,r){const i=e.slice();return i[10]=n[r],i}function Kl(e,n,r){const i=e.slice();return i[10]=n[r],i}function Yl(e){let n,r,i,m=e[10]+"",d,_;return{c(){n=ds("g"),r=ds("line"),i=ds("text"),d=s(m),this.h()},l(c){n=bs(c,"g",{transform:!0});var v=u(n);r=bs(v,"line",{y2:!0,stroke:!0,class:!0}),u(r).forEach(a),i=bs(v,"text",{"font-size":!0,"text-anchor":!0,y:!0});var b=u(i);d=o(b,m),b.forEach(a),v.forEach(a),this.h()},h(){B(r,"y2","3"),B(r,"stroke","black"),B(r,"class","svelte-e941bf"),B(i,"font-size","5"),B(i,"text-anchor","middle"),B(i,"y","8"),B(n,"transform",_=`translate(${e[5](e[10]).toPrecision(3)}, 102)`)},m(c,v){g(c,n,v),t(n,r),t(n,i),t(i,d)},p(c,v){v&288&&m!==(m=c[10]+"")&&wl(d,m),v&288&&_!==(_=`translate(${c[5](c[10]).toPrecision(3)}, 102)`)&&B(n,"transform",_)},d(c){c&&a(n)}}}function Zl(e){let n,r,i,m=e[10]+"",d,_;return{c(){n=ds("g"),r=ds("line"),i=ds("text"),d=s(m),this.h()},l(c){n=bs(c,"g",{transform:!0});var v=u(n);r=bs(v,"line",{x2:!0,stroke:!0,class:!0}),u(r).forEach(a),i=bs(v,"text",{"font-size":!0,"text-anchor":!0,x:!0,y:!0});var b=u(i);d=o(b,m),b.forEach(a),v.forEach(a),this.h()},h(){B(r,"x2","-3"),B(r,"stroke","black"),B(r,"class","svelte-e941bf"),B(i,"font-size","5"),B(i,"text-anchor","end"),B(i,"x","-6"),B(i,"y","1.5"),B(n,"transform",_=`translate(-2, ${e[4](e[10]).toPrecision(3)})`)},m(c,v){g(c,n,v),t(n,r),t(n,i),t(i,d)},p(c,v){v&272&&m!==(m=c[10]+"")&&wl(d,m),v&272&&_!==(_=`translate(-2, ${c[4](c[10]).toPrecision(3)})`)&&B(n,"transform",_)},d(c){c&&a(n)}}}function Jl(e){let n,r,i,m;return{c(){n=ds("path"),this.h()},l(d){n=bs(d,"path",{d:!0,stroke:!0,class:!0}),u(n).forEach(a),this.h()},h(){B(n,"d",r=e[7](e[0])),B(n,"stroke",e[2]),B(n,"class","svelte-e941bf")},m(d,_){g(d,n,_),m=!0},p(d,_){(!m||_&129&&r!==(r=d[7](d[0])))&&B(n,"d",r),(!m||_&4)&&B(n,"stroke",d[2])},i(d){m||(eh(()=>{i||(i=Ml(n,ql,{duration:2e3},!0)),i.run(1)}),m=!0)},o(d){i||(i=Ml(n,ql,{duration:2e3},!1)),i.run(0),m=!1},d(d){d&&a(n),d&&i&&i.end()}}}function Vm(e){let n,r,i,m,d,_=e[5].ticks(Wo(e[8],10)),c=[];for(let w=0;w<_.length;w+=1)c[w]=Yl(Kl(e,_,w));let v=e[4].ticks(Wo(e[8],7)),b=[];for(let w=0;w<v.length;w+=1)b[w]=Zl(Gl(e,v,w));let E=e[1]&&Jl(e);return{c(){n=ds("svg");for(let w=0;w<c.length;w+=1)c[w].c();r=to();for(let w=0;w<b.length;w+=1)b[w].c();i=to(),E&&E.c(),this.h()},l(w){n=bs(w,"svg",{width:!0,height:!0,viewBox:!0});var N=u(n);for(let $=0;$<c.length;$+=1)c[$].l(N);r=to();for(let $=0;$<b.length;$+=1)b[$].l(N);i=to(),E&&E.l(N),N.forEach(a),this.h()},h(){B(n,"width","100%"),B(n,"height",e[3]),B(n,"viewBox",m="-15 -10 "+(e[6]+15)+" 120")},m(w,N){g(w,n,N);for(let $=0;$<c.length;$+=1)c[$].m(n,null);t(n,r);for(let $=0;$<b.length;$+=1)b[$].m(n,null);t(n,i),E&&E.m(n,null),d=!0},p(w,[N]){if(N&288){_=w[5].ticks(Wo(w[8],10));let $;for($=0;$<_.length;$+=1){const I=Kl(w,_,$);c[$]?c[$].p(I,N):(c[$]=Yl(I),c[$].c(),c[$].m(n,r))}for(;$<c.length;$+=1)c[$].d(1);c.length=_.length}if(N&272){v=w[4].ticks(Wo(w[8],7));let $;for($=0;$<v.length;$+=1){const I=Gl(w,v,$);b[$]?b[$].p(I,N):(b[$]=Zl(I),b[$].c(),b[$].m(n,i))}for(;$<b.length;$+=1)b[$].d(1);b.length=v.length}w[1]?E?(E.p(w,N),N&2&&be(E,1)):(E=Jl(w),E.c(),be(E,1),E.m(n,null)):E&&(Lh(),Ne(E,1,1,()=>{E=null}),xh()),(!d||N&8)&&B(n,"height",w[3]),(!d||N&64&&m!==(m="-15 -10 "+(w[6]+15)+" 120"))&&B(n,"viewBox",m)},i(w){d||(be(E),d=!0)},o(w){Ne(E),d=!1},d(w){w&&a(n),Pl(c,w),Pl(b,w),E&&E.d()}}}function Bm(e,n,r){let i,m,d,_,c,{data:v}=n,{show:b}=n,{strokeColor:E="#8A2BE2"}=n,{height:w=300}=n,{aspectRatio:N=2}=n;return e.$$set=$=>{"data"in $&&r(0,v=$.data),"show"in $&&r(1,b=$.show),"strokeColor"in $&&r(2,E=$.strokeColor),"height"in $&&r(3,w=$.height),"aspectRatio"in $&&r(9,N=$.aspectRatio)},e.$$.update=()=>{e.$$.dirty&1&&r(8,i=v.length),e.$$.dirty&512&&r(6,m=N*100),e.$$.dirty&65&&r(5,d=_l().domain(Hl(v.map($=>$.x))).range([0,m])),e.$$.dirty&1&&r(4,_=_l().domain(Hl(v.map($=>$.y))).range([0,100])),e.$$.dirty&48&&r(7,c=zm().x($=>d($.x)).y($=>_($.y)))},[v,b,E,w,_,d,m,c,i,N]}class Xl extends wa{constructor(n){super(),ga(this,n,Bm,Vm,ya,{data:0,show:1,strokeColor:2,height:3,aspectRatio:9})}}function Cm(e){let n,r,i,m,d,_,c=f(`x = ${e[0]}`)+"",v,b,E,w,N,$,I,Y,U,L,C,V,H,q,D,X,A,se,ee,j,T,x,ie,R;return n=new Hu({}),D=new Xl({props:{data:e[3],show:!0,aspectRatio:3}}),T=new Xl({props:{data:e[2],show:!0,aspectRatio:3,strokeColor:"#A0522D"}}),{c(){Pe(n.$$.fragment),r=M(),i=l("div"),m=l("div"),d=l("div"),_=l("span"),v=M(),b=l("input"),E=M(),w=l("div"),N=l("span"),$=s(e[1]),I=s(" qubits"),Y=M(),U=l("input"),L=M(),C=l("div"),V=l("p"),H=s("Real part"),q=M(),Pe(D.$$.fragment),X=M(),A=l("div"),se=l("p"),ee=s("Imaginary part"),j=M(),Pe(T.$$.fragment),this.h()},l(Q){Me(n.$$.fragment,Q),r=S(Q),i=h(Q,"DIV",{class:!0});var G=u(i);m=h(G,"DIV",{class:!0});var me=u(m);d=h(me,"DIV",{class:!0});var ae=u(d);_=h(ae,"SPAN",{class:!0});var ze=u(_);ze.forEach(a),v=S(ae),b=h(ae,"INPUT",{type:!0,min:!0,max:!0,step:!0,class:!0}),ae.forEach(a),E=S(me),w=h(me,"DIV",{class:!0});var le=u(w);N=h(le,"SPAN",{class:!0});var K=u(N);$=o(K,e[1]),I=o(K," qubits"),K.forEach(a),Y=S(le),U=h(le,"INPUT",{type:!0,min:!0,max:!0,step:!0,class:!0}),le.forEach(a),me.forEach(a),L=S(G),C=h(G,"DIV",{class:!0});var P=u(C);V=h(P,"P",{});var re=u(V);H=o(re,"Real part"),re.forEach(a),q=S(P),Me(D.$$.fragment,P),P.forEach(a),X=S(G),A=h(G,"DIV",{});var ce=u(A);se=h(ce,"P",{});var ct=u(se);ee=o(ct,"Imaginary part"),ct.forEach(a),j=S(ce),Me(T.$$.fragment,ce),ce.forEach(a),G.forEach(a),this.h()},h(){B(_,"class","label svelte-1k89lhb"),B(b,"type","range"),B(b,"min",0),B(b,"max",10),B(b,"step",1),B(b,"class","svelte-1k89lhb"),B(d,"class","col-lg-6 col-sm-12"),B(N,"class","label svelte-1k89lhb"),B(U,"type","range"),B(U,"min",3),B(U,"max",10),B(U,"step",1),B(U,"class","svelte-1k89lhb"),B(w,"class","col-lg-6 col-sm-12"),B(m,"class","row"),B(C,"class","mb-3"),B(i,"class","interaction container")},m(Q,G){Se(n,Q,G),g(Q,r,G),g(Q,i,G),t(i,m),t(m,d),t(d,_),_.innerHTML=c,t(d,v),t(d,b),oa(b,e[0]),t(m,E),t(m,w),t(w,N),t(N,$),t(N,I),t(w,Y),t(w,U),oa(U,e[1]),t(i,L),t(i,C),t(C,V),t(V,H),t(C,q),Se(D,C,null),t(i,X),t(i,A),t(A,se),t(se,ee),t(A,j),Se(T,A,null),x=!0,ie||(R=[p(b,"change",e[6]),p(b,"input",e[6]),p(U,"change",e[7]),p(U,"input",e[7])],ie=!0)},p(Q,[G]){(!x||G&1)&&c!==(c=f(`x = ${Q[0]}`)+"")&&(_.innerHTML=c),G&1&&oa(b,Q[0]),(!x||G&2)&&wl($,Q[1]),G&2&&oa(U,Q[1]);const me={};G&8&&(me.data=Q[3]),D.$set(me);const ae={};G&4&&(ae.data=Q[2]),T.$set(ae)},i(Q){x||(be(n.$$.fragment,Q),be(D.$$.fragment,Q),be(T.$$.fragment,Q),x=!0)},o(Q){Ne(n.$$.fragment,Q),Ne(D.$$.fragment,Q),Ne(T.$$.fragment,Q),x=!1},d(Q){qe(n,Q),Q&&a(r),Q&&a(i),qe(D),qe(T),ie=!1,kr(R)}}}function Rm(e,n,r){let i,m,d,_,c,v;function b(){m=Dr(this.value),r(0,m)}function E(){i=Dr(this.value),r(1,i)}return e.$$.update=()=>{e.$$.dirty&2&&r(5,d=Sl(2,i)),e.$$.dirty&33&&r(4,v=[...Array(d).keys()].map(w=>Sl(Fh,Qh(2*ll*m*w/d,zh)))),e.$$.dirty&16&&r(3,_=v.map((w,N)=>({x:N,y:w.im}))),e.$$.dirty&16&&r(2,c=v.map((w,N)=>({x:N,y:w.re})))},r(1,i=3),r(0,m=9),[m,i,c,_,v,d,b,E]}class jm extends wa{constructor(n){super(),ga(this,n,Rm,Cm,ya,{})}}const Dm='<a href="https://en.wikipedia.org/wiki/Projection_(linear_algebra)"><h3>Projection (linear algebra)</h3></a><p>In linear algebra and functional analysis, a <b>projection</b> is a linear transformation <span class="mwe-math-element"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/b4dc73bf40314945ff376bd363916a738548d40a" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align:-0.338ex;width:1.745ex;height:2.176ex" /></span> from a vector space to itself such that <span class="mwe-math-element"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/5369d895625034bc50c9f28975e3293ef6f2105b" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align:-0.338ex;width:10.529ex;height:2.176ex" /></span>. That is, whenever <span class="mwe-math-element"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/b4dc73bf40314945ff376bd363916a738548d40a" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align:-0.338ex;width:1.745ex;height:2.176ex" /></span> is applied twice to any vector, it gives the same result as if it were applied once. It leaves its image unchanged. This definition of "projection" formalizes and generalizes the idea of graphical projection. One can also consider the effect of a projection on a geometrical object by examining the effect of the projection on points in the object.</p>',Wm='<a href="https://en.wikipedia.org/wiki/Bloch_sphere"><h3>Bloch sphere</h3></a><p>In quantum mechanics and computing, the <b>Bloch sphere</b> is a geometrical representation of the pure state space of a two-level quantum mechanical system (qubit), named after the physicist Felix Bloch.</p>',Um='<a href="https://en.wikipedia.org/wiki/Degrees_of_freedom"><h3>Degrees of freedom</h3></a><p><b>Degrees of freedom</b> refers to the number of independent variables or parameters of a system. In various scientific fields, the word "freedom" is used to describe the limits to which physical movement or other physical processes are possible. This relates to the philosophical concept to the extent that people may be considered to have as much freedom as they are physically able to exercise.</p>',Om='<a href="https://en.wikipedia.org/wiki/Phase_factor"><h3>Phase factor</h3></a><p>For any complex number written in polar form, the <b>phase factor</b> is the complex exponential factor. As such, the term "phase factor" is related to the more general term phasor, which may have any magnitude. The phase factor is a unit complex number, i.e. a complex number of absolute value 1. It is commonly used in quantum mechanics.</p>';function Gm(e){let n;return{c(){n=s("projection")},l(r){n=o(r,"projection")},m(r,i){g(r,n,i)},d(r){r&&a(n)}}}function Km(e){let n;return{c(){n=s("Bloch sphere")},l(r){n=o(r,"Bloch sphere")},m(r,i){g(r,n,i)},d(r){r&&a(n)}}}function Ym(e){let n;return{c(){n=s("degrees of freedom")},l(r){n=o(r,"degrees of freedom")},m(r,i){g(r,n,i)},d(r){r&&a(n)}}}function Zm(e){let n;return{c(){n=s("phase")},l(r){n=o(r,"phase")},m(r,i){g(r,n,i)},d(r){r&&a(n)}}}function Jm(e){let n,r,i,m,d,_,c=f("\\alpha")+"",v,b,E=f("\\beta")+"",w,N,$=f("\\alpha = \\Vert{\\alpha}\\Vert \\cdot e^{i \\phi_{\\alpha}}")+"",I,Y,U=f("\\beta = \\Vert{\\beta}\\Vert \\cdot e^{i \\phi_{\\beta}}.")+"",L,C,V=f("\\Vert{\\alpha}\\Vert \\cdot e^{i \\phi_{\\alpha}} |0\\rangle + \\Vert{\\beta}\\Vert \\cdot e^{i \\phi_{\\beta}} |1\\rangle.")+"",H,q,D,X,A=f("e^{i \\phi_{\\alpha}}")+"",se,ee,j=f("\\Vert{e^{i \\phi_{\\alpha}}}\\Vert^2")+"",T,x,ie=f("1.")+"",R,Q,G=f("\\phi_{\\alpha}")+"",me,ae,ze=f("\\phi_{\\beta}")+"",le,K,P=f("e^{i \\phi_{\\alpha}}")+"",re,ce,ct=f("\\Vert{\\alpha}\\Vert \\cdot |0\\rangle + \\Vert{\\beta}\\Vert \\cdot \\frac{e^{i \\phi_{\\beta}}}{e^{i \\phi_{\\alpha}}} |1\\rangle.")+"",ke,Ve,yt=f("\\frac{e^{i \\phi_{\\beta}}}{e^{i \\phi_{\\alpha}}} = e^{i (\\phi_{\\beta} - \\phi_{\\alpha})}.")+"",fe,Le,rt=f("\\phi = \\phi_{\\beta} - \\phi_{\\alpha},")+"",ve,Ae,Ke=f("\\Vert{\\alpha}\\Vert \\cdot |0\\rangle + \\Vert{\\beta}\\Vert \\cdot e^{i \\phi} |1\\rangle.")+"",_t,ne,_e,st,je=f("\\Vert{\\alpha}\\Vert^2 + \\Vert{\\beta}\\Vert^2 = 1.")+"",sn,W,pe=f("\\theta.")+"",Z,ut,Be=f("\\cos{(\\frac{\\theta}{2})} \\cdot |0 \\rangle + \\sin{(\\frac{\\theta}{2})} \\cdot e^{i \\phi} |1 \\rangle.")+"",Ct,mt,De=f("\\theta")+"",St,$t,Ye=f("\\phi.")+"",Kt,Nt,et=f("\\theta")+"",kt,Lt,F=f("z")+"",Ee,We,Et=f("\\phi")+"",Rt,He,bt,qt,on=f("x-y")+"",Tt,At,ue,wn,Ue,Ht,oe,tt,xt,jt=f("\\theta")+"",Dt,lt,Yt=f("\\phi")+"",Wt,It,ia,Ft,un,$a;return He=new it({props:{hovertext:Dm,$$slots:{default:[Gm]},$$scope:{ctx:e}}}),At=new it({props:{hovertext:Wm,$$slots:{default:[Km]},$$scope:{ctx:e}}}),oe=new it({props:{hovertext:Um,$$slots:{default:[Ym]},$$scope:{ctx:e}}}),It=new it({props:{hovertext:Om,$$slots:{default:[Zm]},$$scope:{ctx:e}}}),{c(){n=l("h2"),r=s("The Bloch-sphere"),i=M(),m=l("p"),d=s("As the coefficients "),_=l("span"),v=s(" and "),b=l("span"),w=s(" are complex numbers, they can be expressed in the form "),N=l("span"),I=s(" and "),Y=l("span"),L=s(" Thus, the state of the qubit can be rewritten as "),C=l("span"),H=M(),q=l("p"),D=s("Remember that "),X=l("span"),se=s(" is a unit vector rotated around the origin, and therefore the square of its norm "),ee=l("span"),T=s(" also equals to "),x=l("span"),R=s(" This means that we can modify the angles "),Q=l("span"),me=s(" and "),ae=l("span"),le=s(" freely without affecting the measurement probabilities. Therefore, we can do an algebraic trick to simplify the expression above. Namely, let's divide the state by "),K=l("span"),re=s(" to obtain "),ce=l("span"),ke=s(" By the rules of exponentiation, "),Ve=l("span"),fe=s(" Next, let's introduce a new variable "),Le=l("span"),ve=s(" with the help of which the state can be further simplified to "),Ae=l("span"),_t=M(),ne=l("p"),_e=s("We know that "),st=l("span"),sn=s(" Consequently, these two numbers can also be represented geometrically as vector of unit length rotated around the origin by some angle, the double of which we'll denote as "),W=l("span"),Z=s(" Using trigonometry, we can now rewrite the state as "),ut=l("span"),Ct=s(" Notice that we now only need two variables to express the state of the qubit: the angles "),mt=l("span"),St=s(" and "),$t=l("span"),Kt=s(" Geometrically, this can be represented as a vector pointing to the surface of 3-dimensional sphere with unit radius, where "),Nt=l("span"),kt=s(" is the angle of the vector and the "),Lt=l("span"),Ee=s(" axis, and "),We=l("span"),Rt=s(" is the angle of the vertical "),Pe(He.$$.fragment),bt=s(" of the vector on the "),qt=l("span"),Tt=s(" plane. This representation of qubit states is called the "),Pe(At.$$.fragment),ue=s("."),wn=M(),Ue=l("p"),Ht=s("It's important to note that of the two "),Pe(oe.$$.fragment),tt=s(" on the Bloch sphere, only the angle "),xt=l("span"),Dt=s(" is related to measurement probabilities. "),lt=l("span"),Wt=s(" is an inherently quantum property called the "),Pe(It.$$.fragment),ia=s(" that does not have physical manifestation directly observable to us. Because of this, it's hard to find any intuitive analogy from everyday life that could help us understand what exactly the phase is. The most useful approach in this context is to look at the phase as a matematical property of quantum objects that we can leverage to design clever algorithms.")},l(he){n=h(he,"H2",{});var ye=u(n);r=o(ye,"The Bloch-sphere"),ye.forEach(a),i=S(he),m=h(he,"P",{});var ft=u(m);d=o(ft,"As the coefficients "),_=h(ft,"SPAN",{});var tn=u(_);tn.forEach(a),v=o(ft," and "),b=h(ft,"SPAN",{});var Ut=u(b);Ut.forEach(a),w=o(ft," are complex numbers, they can be expressed in the form "),N=h(ft,"SPAN",{});var Qt=u(N);Qt.forEach(a),I=o(ft," and "),Y=h(ft,"SPAN",{});var gn=u(Y);gn.forEach(a),L=o(ft," Thus, the state of the qubit can be rewritten as "),C=h(ft,"SPAN",{});var Zt=u(C);Zt.forEach(a),ft.forEach(a),H=S(he),q=h(he,"P",{});var pt=u(q);D=o(pt,"Remember that "),X=h(pt,"SPAN",{});var yn=u(X);yn.forEach(a),se=o(pt," is a unit vector rotated around the origin, and therefore the square of its norm "),ee=h(pt,"SPAN",{});var zt=u(ee);zt.forEach(a),T=o(pt," also equals to "),x=h(pt,"SPAN",{});var Qa=u(x);Qa.forEach(a),R=o(pt," This means that we can modify the angles "),Q=h(pt,"SPAN",{});var mn=u(Q);mn.forEach(a),me=o(pt," and "),ae=h(pt,"SPAN",{});var de=u(ae);de.forEach(a),le=o(pt," freely without affecting the measurement probabilities. Therefore, we can do an algebraic trick to simplify the expression above. Namely, let's divide the state by "),K=h(pt,"SPAN",{});var za=u(K);za.forEach(a),re=o(pt," to obtain "),ce=h(pt,"SPAN",{});var Ot=u(ce);Ot.forEach(a),ke=o(pt," By the rules of exponentiation, "),Ve=h(pt,"SPAN",{});var fn=u(Ve);fn.forEach(a),fe=o(pt," Next, let's introduce a new variable "),Le=h(pt,"SPAN",{});var Xn=u(Le);Xn.forEach(a),ve=o(pt," with the help of which the state can be further simplified to "),Ae=h(pt,"SPAN",{});var Pn=u(Ae);Pn.forEach(a),pt.forEach(a),_t=S(he),ne=h(he,"P",{});var Fe=u(ne);_e=o(Fe,"We know that "),st=h(Fe,"SPAN",{});var In=u(st);In.forEach(a),sn=o(Fe," Consequently, these two numbers can also be represented geometrically as vector of unit length rotated around the origin by some angle, the double of which we'll denote as "),W=h(Fe,"SPAN",{});var pn=u(W);pn.forEach(a),Z=o(Fe," Using trigonometry, we can now rewrite the state as "),ut=h(Fe,"SPAN",{});var Pt=u(ut);Pt.forEach(a),Ct=o(Fe," Notice that we now only need two variables to express the state of the qubit: the angles "),mt=h(Fe,"SPAN",{});var Mt=u(mt);Mt.forEach(a),St=o(Fe," and "),$t=h(Fe,"SPAN",{});var Fn=u($t);Fn.forEach(a),Kt=o(Fe," Geometrically, this can be represented as a vector pointing to the surface of 3-dimensional sphere with unit radius, where "),Nt=h(Fe,"SPAN",{});var Mn=u(Nt);Mn.forEach(a),kt=o(Fe," is the angle of the vector and the "),Lt=h(Fe,"SPAN",{});var nn=u(Lt);nn.forEach(a),Ee=o(Fe," axis, and "),We=h(Fe,"SPAN",{});var Qn=u(We);Qn.forEach(a),Rt=o(Fe," is the angle of the vertical "),Me(He.$$.fragment,Fe),bt=o(Fe," of the vector on the "),qt=h(Fe,"SPAN",{});var cn=u(qt);cn.forEach(a),Tt=o(Fe," plane. This representation of qubit states is called the "),Me(At.$$.fragment,Fe),ue=o(Fe,"."),Fe.forEach(a),wn=S(he),Ue=h(he,"P",{});var Gt=u(Ue);Ht=o(Gt,"It's important to note that of the two "),Me(oe.$$.fragment,Gt),tt=o(Gt," on the Bloch sphere, only the angle "),xt=h(Gt,"SPAN",{});var zn=u(xt);zn.forEach(a),Dt=o(Gt," is related to measurement probabilities. "),lt=h(Gt,"SPAN",{});var Sn=u(lt);Sn.forEach(a),Wt=o(Gt," is an inherently quantum property called the "),Me(It.$$.fragment,Gt),ia=o(Gt," that does not have physical manifestation directly observable to us. Because of this, it's hard to find any intuitive analogy from everyday life that could help us understand what exactly the phase is. The most useful approach in this context is to look at the phase as a matematical property of quantum objects that we can leverage to design clever algorithms."),Gt.forEach(a)},m(he,ye){g(he,n,ye),t(n,r),g(he,i,ye),g(he,m,ye),t(m,d),t(m,_),_.innerHTML=c,t(m,v),t(m,b),b.innerHTML=E,t(m,w),t(m,N),N.innerHTML=$,t(m,I),t(m,Y),Y.innerHTML=U,t(m,L),t(m,C),C.innerHTML=V,g(he,H,ye),g(he,q,ye),t(q,D),t(q,X),X.innerHTML=A,t(q,se),t(q,ee),ee.innerHTML=j,t(q,T),t(q,x),x.innerHTML=ie,t(q,R),t(q,Q),Q.innerHTML=G,t(q,me),t(q,ae),ae.innerHTML=ze,t(q,le),t(q,K),K.innerHTML=P,t(q,re),t(q,ce),ce.innerHTML=ct,t(q,ke),t(q,Ve),Ve.innerHTML=yt,t(q,fe),t(q,Le),Le.innerHTML=rt,t(q,ve),t(q,Ae),Ae.innerHTML=Ke,g(he,_t,ye),g(he,ne,ye),t(ne,_e),t(ne,st),st.innerHTML=je,t(ne,sn),t(ne,W),W.innerHTML=pe,t(ne,Z),t(ne,ut),ut.innerHTML=Be,t(ne,Ct),t(ne,mt),mt.innerHTML=De,t(ne,St),t(ne,$t),$t.innerHTML=Ye,t(ne,Kt),t(ne,Nt),Nt.innerHTML=et,t(ne,kt),t(ne,Lt),Lt.innerHTML=F,t(ne,Ee),t(ne,We),We.innerHTML=Et,t(ne,Rt),Se(He,ne,null),t(ne,bt),t(ne,qt),qt.innerHTML=on,t(ne,Tt),Se(At,ne,null),t(ne,ue),g(he,wn,ye),g(he,Ue,ye),t(Ue,Ht),Se(oe,Ue,null),t(Ue,tt),t(Ue,xt),xt.innerHTML=jt,t(Ue,Dt),t(Ue,lt),lt.innerHTML=Yt,t(Ue,Wt),Se(It,Ue,null),t(Ue,ia),Ft=!0,un||($a=[p(_,"mouseenter",e[0]),p(b,"mouseenter",e[1]),p(N,"mouseenter",e[2]),p(Y,"mouseenter",e[3]),p(C,"mouseenter",e[4]),p(X,"mouseenter",e[5]),p(ee,"mouseenter",e[6]),p(x,"mouseenter",e[7]),p(Q,"mouseenter",e[8]),p(ae,"mouseenter",e[9]),p(K,"mouseenter",e[10]),p(ce,"mouseenter",e[11]),p(Ve,"mouseenter",e[12]),p(Le,"mouseenter",e[13]),p(Ae,"mouseenter",e[14]),p(st,"mouseenter",e[15]),p(W,"mouseenter",e[16]),p(ut,"mouseenter",e[17]),p(mt,"mouseenter",e[18]),p($t,"mouseenter",e[19]),p(Nt,"mouseenter",e[20]),p(Lt,"mouseenter",e[21]),p(We,"mouseenter",e[22]),p(qt,"mouseenter",e[23]),p(xt,"mouseenter",e[24]),p(lt,"mouseenter",e[25])],un=!0)},p(he,[ye]){const ft={};ye&67108864&&(ft.$$scope={dirty:ye,ctx:he}),He.$set(ft);const tn={};ye&67108864&&(tn.$$scope={dirty:ye,ctx:he}),At.$set(tn);const Ut={};ye&67108864&&(Ut.$$scope={dirty:ye,ctx:he}),oe.$set(Ut);const Qt={};ye&67108864&&(Qt.$$scope={dirty:ye,ctx:he}),It.$set(Qt)},i(he){Ft||(be(He.$$.fragment,he),be(At.$$.fragment,he),be(oe.$$.fragment,he),be(It.$$.fragment,he),Ft=!0)},o(he){Ne(He.$$.fragment,he),Ne(At.$$.fragment,he),Ne(oe.$$.fragment,he),Ne(It.$$.fragment,he),Ft=!1},d(he){he&&a(n),he&&a(i),he&&a(m),he&&a(H),he&&a(q),he&&a(_t),he&&a(ne),qe(He),qe(At),he&&a(wn),he&&a(Ue),qe(oe),qe(It),un=!1,kr($a)}}}function Bt(e){console.log(e)}function Xm(e){return[()=>Bt(["\\alpha"]),()=>Bt(["\\beta"]),()=>Bt(["\\phi","\\alpha"]),()=>Bt(["\\beta","\\phi"]),()=>Bt(["\\beta","\\phi","\\alpha"]),()=>Bt(["\\phi","\\alpha"]),()=>Bt(["\\phi","\\alpha"]),()=>Bt([]),()=>Bt(["\\phi","\\alpha"]),()=>Bt(["\\beta","\\phi"]),()=>Bt(["\\phi","\\alpha"]),()=>Bt(["\\beta","\\phi","\\alpha"]),()=>Bt(["\\beta","\\phi","\\alpha"]),()=>Bt(["\\beta","\\phi","\\alpha"]),()=>Bt(["\\beta","\\phi","\\alpha"]),()=>Bt(["\\beta","\\alpha"]),()=>Bt(["\\theta"]),()=>Bt(["\\theta","\\phi"]),()=>Bt(["\\theta"]),()=>Bt(["\\phi"]),()=>Bt(["\\theta"]),()=>Bt(["z"]),()=>Bt(["\\phi"]),()=>Bt(["y","x"]),()=>Bt(["\\theta"]),()=>Bt(["\\phi"])]}class ef extends wa{constructor(n){super(),ga(this,n,Xm,Jm,ya,{})}}const tf='<a href="https://en.wikipedia.org/wiki/Complex_number"><h3 class="text-lg font-semibold">Complex number</h3></a><p>In mathematics, a <b>complex number</b> is an element of a number system that extends the real numbers with a specific element denoted <span class="texhtml mvar" style="font-style:italic">i</span>, called the imaginary unit and satisfying the equation <span class="texhtml "><i>i</i><sup>2</sup> = \u22121</span>; every complex number can be expressed in the form <span class="texhtml "><i>a</i> + <i>bi</i></span>, where <span class="texhtml mvar" style="font-style:italic">a</span> and <span class="texhtml mvar" style="font-style:italic">b</span> are real numbers. Because no real number satisfies the above equation, <span class="texhtml mvar" style="font-style:italic">i</span> was called an imaginary number by Ren\xE9 Descartes. For the complex number <span class="texhtml "><i>a</i> + <i>bi</i></span>, <span class="texhtml mvar" style="font-style:italic">a</span> is called the <b><span class="vanchor"><span class="vanchor-text">real part</span></span></b> and <span class="texhtml mvar" style="font-style:italic">b</span> is called the <b><span class="vanchor"><span class="vanchor-text">imaginary part</span></span></b>. The set of complex numbers is denoted by either of the symbols <span class="mwe-math-element"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f9add4085095b9b6d28d045fd9c92c2c09f549a7" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align:-0.338ex;width:1.678ex;height:2.176ex" /></span> or <span class="texhtml "><b>C</b></span>. Despite the historical nomenclature "imaginary", complex numbers are regarded in the mathematical sciences as just as "real" as the real numbers and are fundamental in many aspects of the scientific description of the natural world.</p>',nf='<a href="https://en.wikipedia.org/wiki/Imaginary_number"><h3>Imaginary number</h3></a><p>An <b>imaginary number</b> is a real number multiplied by the imaginary unit <span class="texhtml mvar" style="font-style:italic">i</span>, which is defined by its property <span class="texhtml "><i>i</i><sup>2</sup> = \u22121</span>. The square of an imaginary number <span class="texhtml mvar" style="font-style:italic">bi</span> is <span class="texhtml ">\u2212<i>b</i><sup>2</sup></span>. For example, <span class="texhtml ">5<i>i</i></span> is an imaginary number, and its square is <span class="texhtml ">\u221225</span>. By definition, zero is considered to be both real and imaginary.</p>',af='<a href="https://en.wikipedia.org/wiki/Real_number"><h3>Real number</h3></a><p>In mathematics, a <b>real number</b> is a value of a continuous quantity that can represent a distance along a line. The adjective <i>real</i> in this context was introduced in the 17th century by Ren\xE9 Descartes, who distinguished between real and imaginary roots of polynomials. The real numbers include all the rational numbers, such as the integer \u22125 and the fraction 4/3, and all the irrational numbers, such as <span class="mwe-math-element"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/b4afc1e27d418021bf10898eb44a7f5f315735ff" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align:-0.671ex;width:3.098ex;height:3.009ex" /></span>. Included within the irrationals are the real transcendental numbers, such as <span><span class="texhtml mvar" style="font-style:italic">\u03C0</span></span> (3.14159265...). In addition to measuring distance, real numbers can be used to measure quantities such as time, mass, energy, velocity, and many more. The set of real numbers is denoted using the symbol <b>R</b> or <span class="mwe-math-element"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/786849c765da7a84dbc3cce43e96aad58a5868dc" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align:-0.338ex;width:1.678ex;height:2.176ex" /></span> and is sometimes called "the reals".</p>',rf='<a href="https://en.wikipedia.org/wiki/Complex_plane"><h3>Complex plane</h3></a><p>In mathematics, the <b>complex plane</b> is the plane formed by the complex numbers, with a Cartesian coordinate system such that the <span class="texhtml mvar" style="font-style:italic">x</span>-axis, called <b>real axis</b>, is formed by the real numbers, and the <span class="texhtml mvar" style="font-style:italic">y</span>-axis, called <b>imaginary axis</b>, is formed by the imaginary numbers.</p>',sf='<a href="https://en.wikipedia.org/wiki/Bit"><h3 class="text-lg font-semibold">Bit</h3></a><p>The <b>bit</b> is the most basic unit of information in computing and digital communications. The name is a portmanteau of <b>binary digit</b>. The bit represents a logical state with one of two possible values. These values are most commonly represented as either <span class="nowrap">"<span class="monospaced">1</span>" or "<span class="monospaced">0</span>"</span>, but other representations such as <i>true</i>/<i>false</i>, <i>yes</i>/<i>no</i>, <i>on</i>/<i>off</i>, or <i>+</i>/<i>\u2212</i> are also commonly used.</p>',of='<a href="https://en.wikipedia.org/wiki/Information_theory"><h3>Information theory</h3></a><p><b>Information theory</b> is the scientific study of the quantification, storage, and communication of digital information. The field was fundamentally established by the works of Harry Nyquist and Ralph Hartley, in the 1920s, and Claude Shannon in the 1940s. The field is at the intersection of probability theory, statistics, computer science, statistical mechanics, information engineering, and electrical engineering.</p>',lf='<a href="https://en.wikipedia.org/wiki/Qubit"><h3 class="text-lg font-semibold">Qubit</h3></a><p>In quantum computing, a <b>qubit</b> or <b>quantum bit</b> is a basic unit of quantum information\u2014the quantum version of the classic binary bit physically realized with a two-state device. A qubit is a two-state quantum-mechanical system, one of the simplest quantum systems displaying the peculiarity of quantum mechanics. Examples include the spin of the electron in which the two levels can be taken as spin up and spin down; or the polarization of a single photon in which the two states can be taken to be the vertical polarization and the horizontal polarization. In a classical system, a bit would have to be in one state or the other. However, quantum mechanics allows the qubit to be in a coherent superposition of both states simultaneously, a property that is fundamental to quantum mechanics and quantum computing.</p>',hf='<a href="https://en.wikipedia.org/wiki/Measurement_in_quantum_mechanics"><h3>Measurement in quantum mechanics</h3></a><p>In quantum physics, a <b>measurement</b> is the testing or manipulation of a physical system to yield a numerical result. The predictions that quantum physics makes are in general probabilistic. The mathematical tools for making predictions about what measurement outcomes may occur were developed during the 20th century and make use of linear algebra and functional analysis.</p>',uf=`<a href="https://en.wikipedia.org/wiki/Quantum_state"><h3>Quantum state</h3></a><p>In quantum physics, a <b>quantum state</b> is a mathematical entity that provides a probability distribution for the outcomes of each possible measurement on a system. Knowledge of the quantum state together with the rules for the system's evolution in time exhausts all that can be predicted about the system's behavior. A mixture of quantum states is again a quantum state. Quantum states that cannot be written as a mixture of other states are called <b>pure quantum states</b>, while all other states are called <b>mixed quantum states</b>. A pure quantum state can be represented by a ray in a Hilbert space over the complex numbers, while mixed states are represented by density matrices, which are positive semidefinite operators that act on Hilbert spaces.</p>`,mf=`<a href="https://en.wikipedia.org/wiki/Linear_combination"><h3>Linear combination</h3></a><p>In mathematics, a <b>linear combination</b> is an expression constructed from a set of terms by multiplying each term by a constant and adding the results. The concept of linear combinations is central to linear algebra and related fields of mathematics.
Most of this article deals with linear combinations in the context of a vector space over a field, with some generalizations given at the end of the article.</p>`;function ff(e){let n;return{c(){n=s("complex number")},l(r){n=o(r,"complex number")},m(r,i){g(r,n,i)},d(r){r&&a(n)}}}function pf(e){let n;return{c(){n=s("imaginary")},l(r){n=o(r,"imaginary")},m(r,i){g(r,n,i)},d(r){r&&a(n)}}}function cf(e){let n;return{c(){n=s("real")},l(r){n=o(r,"real")},m(r,i){g(r,n,i)},d(r){r&&a(n)}}}function _f(e){let n;return{c(){n=s("complex plane")},l(r){n=o(r,"complex plane")},m(r,i){g(r,n,i)},d(r){r&&a(n)}}}function df(e){let n;return{c(){n=s("bits")},l(r){n=o(r,"bits")},m(r,i){g(r,n,i)},d(r){r&&a(n)}}}function bf(e){let n;return{c(){n=s("bit of information")},l(r){n=o(r,"bit of information")},m(r,i){g(r,n,i)},d(r){r&&a(n)}}}function vf(e){let n;return{c(){n=s("Qubits")},l(r){n=o(r,"Qubits")},m(r,i){g(r,n,i)},d(r){r&&a(n)}}}function wf(e){let n;return{c(){n=s("measured")},l(r){n=o(r,"measured")},m(r,i){g(r,n,i)},d(r){r&&a(n)}}}function gf(e){let n;return{c(){n=s("state")},l(r){n=o(r,"state")},m(r,i){g(r,n,i)},d(r){r&&a(n)}}}function yf(e){let n;return{c(){n=s("linear combination")},l(r){n=o(r,"linear combination")},m(r,i){g(r,n,i)},d(r){r&&a(n)}}}function $f(e){let n,r,i,m,d,_,c,v,b=f("z \\in \\mathbb{C}")+"",E,w,N=f("z = a i + b,")+"",$,I,Y=f("a, b \\in \\mathbb{R}")+"",U,L,C=f("i = \\sqrt{-1}.")+"",V,H,q=f("a")+"",D,X,A,se,ee=f("b")+"",j,T,x,ie,R=f("z.")+"",Q,G,me=f("a=0")+"",ae,ze,le,K,P,re,ce,ct=f("x")+"",ke,Ve,yt=f("y")+"",fe,Le,rt,ve,Ae,Ke=f("\\Vert{z}\\Vert = \\sqrt{a^2 + b^2}")+"",_t,ne,_e=f("z.")+"",st,je,sn=f("\\Vert{z}\\Vert^2 = a^2 + b^2")+"",W,pe,Z,ut,Be,Ct=f("z")+"",mt,De,St=f("\\Vert{z}\\Vert \\cdot e^{i \\phi_z},")+"",$t,Ye,Kt=f("\\phi_z \\in [0, 2\\pi].")+"",Nt,et,kt=f("e^{i \\phi_z}")+"",Lt,F,Ee=f("\\phi_z")+"",We,Et,Rt=f("2\\pi")+"",He,bt,qt=f("z,")+"",on,Tt,At=f("\\Vert{z}\\Vert")+"",ue,wn,Ue,Ht,oe,tt,xt,jt,Dt,lt,Yt,Wt,It=f("0")+"",ia,Ft,un=f("1")+"",$a,he,ye,ft,tn,Ut,Qt=f("0")+"",gn,Zt,pt=f("1,")+"",yn,zt,Qa,mn,de,za,Ot,fn=f("|0\\rangle")+"",Xn,Pn,Fe=f("|1\\rangle")+"",In,pn,Pt,Mt,Fn,Mn,nn=f("\\alpha |0\\rangle + \\beta |1\\rangle.")+"",Qn,cn,Gt=f("\\alpha")+"",zn,Sn,Dn=f("\\beta")+"",Vt,Na,Vn=f("|0\\rangle")+"",Ze,Bn,$n=f("\\Vert{\\alpha}\\Vert^2,")+"",ln,Cn,Nn=f("|1\\rangle")+"",ka,_n,Wn=f("\\Vert{\\beta}\\Vert^2.")+"",Ka,we,qn=f("|0\\rangle")+"",Ea,ea,An=f("|1\\rangle")+"",Ta,ta,Un=f("\\Vert{\\alpha}\\Vert^2 + \\Vert{\\beta}\\Vert^2 = 1")+"",na,la,$e=f("\\Vert{\\alpha}\\Vert^2")+"",dt,Hn,Jt=f("\\Vert{\\beta}\\Vert^2")+"",On,ht,ot,ha;return _=new it({props:{hovertext:tf,$$slots:{default:[ff]},$$scope:{ctx:e}}}),X=new it({props:{hovertext:nf,$$slots:{default:[pf]},$$scope:{ctx:e}}}),T=new it({props:{hovertext:af,$$slots:{default:[cf]},$$scope:{ctx:e}}}),P=new it({props:{hovertext:rf,$$slots:{default:[_f]},$$scope:{ctx:e}}}),jt=new it({props:{hovertext:sf,$$slots:{default:[df]},$$scope:{ctx:e}}}),lt=new it({props:{hovertext:of,$$slots:{default:[bf]},$$scope:{ctx:e}}}),ft=new it({props:{hovertext:lf,$$slots:{default:[vf]},$$scope:{ctx:e}}}),zt=new it({props:{hovertext:hf,$$slots:{default:[wf]},$$scope:{ctx:e}}}),pn=new it({props:{hovertext:uf,$$slots:{default:[gf]},$$scope:{ctx:e}}}),Mt=new it({props:{hovertext:mf,$$slots:{default:[yf]},$$scope:{ctx:e}}}),{c(){n=l("h2"),r=s("Important properties of complex numbers"),i=M(),m=l("p"),d=s("The general form of a "),Pe(_.$$.fragment),c=M(),v=l("span"),E=s(" is the following: "),w=l("span"),$=s(" where "),I=l("span"),U=s(" and "),L=l("span"),V=M(),H=l("span"),D=s(" is called the "),Pe(X.$$.fragment),A=s(" and "),se=l("span"),j=s(" the "),Pe(T.$$.fragment),x=s(" component of "),ie=l("span"),Q=s(" In fact, all real numbers are complex numbers, the imaginary component of which is zero ("),G=l("span"),ae=s(")."),ze=M(),le=l("p"),K=s("Complex numbers can be represented geometrically as two-dimensional vectors in the so called "),Pe(P.$$.fragment),re=s(", where the "),ce=l("span"),ke=s("-axis stands for the real, and the "),Ve=l("span"),fe=s("-axis for the imaginary component."),Le=M(),rt=l("p"),ve=s("Let "),Ae=l("span"),_t=s(" denote the Euclidean norm of the vector associated with the complex number "),ne=l("span"),st=s(" Consequently, "),je=l("span"),W=s(" is the square of this norm, and it's going to play an important role in what follows."),pe=M(),Z=l("p"),ut=s("Another important thing to note is that each 2-dimensional vector is uniquely defined by two properties: its length and angle of rotation. Consequently, a complex number "),Be=l("span"),mt=s(" can be expressed as "),De=l("span"),$t=s(" where "),Ye=l("span"),Nt=s(" Here, "),et=l("span"),Lt=s(" is a vector of unit length in the complex plane, rotated around the origin by an angle of "),F=l("span"),We=s(" ("),Et=l("span"),He=s(" corresponds to a full rotation). All we have to do to get back "),bt=l("span"),on=s(" then, is multiply this rotated unit vector by "),Tt=l("span"),ue=s(" to adjust its norm."),wn=M(),Ue=l("h2"),Ht=s("Qubit states"),oe=M(),tt=l("p"),xt=s("The elementary units of information in classical computing are "),Pe(jt.$$.fragment),Dt=s(". As their name suggests, bits represent one single "),Pe(lt.$$.fragment),Yt=s(", which means they can take on either of two values "),Wt=l("span"),ia=s(" and "),Ft=l("span"),$a=s(" at a time."),he=M(),ye=l("p"),Pe(ft.$$.fragment),tn=s(" are the quantum computing equivalent of bits. They differ from classical bits - among other things - in that they can take on a multitude of values instead of just "),Ut=l("span"),gn=s(" and "),Zt=l("span"),yn=s(" until that value is "),Pe(zt.$$.fragment),Qa=s(", at which point they behave just like classical bits. To explain what this means exactly, we'll need to introduce some further concepts."),mn=M(),de=l("p"),za=s("Let "),Ot=l("span"),Xn=s(" and "),Pn=l("span"),In=s(" denote the so called basis states of a qubit that are the quantum-equivalent of classical bit states. If you look at a qubit directly to learn it's value, you'll see one of these basis states. But while you're not looking - due to it's quantum nature - the "),Pe(pn.$$.fragment),Pt=s(" of a qubit may be something more intricate. Generally, it can be expressed as the "),Pe(Mt.$$.fragment),Fn=s(" of the two basis states: "),Mn=l("span"),Qn=s(" Here, "),cn=l("span"),zn=s(" and "),Sn=l("span"),Vt=s(" are complex numbers that indicate the relative weight, with which the two basis states are present in this combination. More precisely, if we now look at the qubit, we'll see the basis state "),Na=l("span"),Ze=s(" with a probability of "),Bn=l("span"),ln=s(" and the basis state "),Cn=l("span"),ka=s(" with a probability of "),_n=l("span"),Ka=s(" Because these probabilities must add up to one - as "),we=l("span"),Ea=s(" and "),ea=l("span"),Ta=s(" are the only possible outcomes - the equation "),ta=l("span"),na=s(" must hold for all possible qubit states. Let's call "),la=l("span"),dt=s(" and "),Hn=l("span"),On=s(" the measurement probabilities of the basis states.")},l(z){n=h(z,"H2",{});var Te=u(n);r=o(Te,"Important properties of complex numbers"),Te.forEach(a),i=S(z),m=h(z,"P",{});var Ce=u(m);d=o(Ce,"The general form of a "),Me(_.$$.fragment,Ce),c=S(Ce),v=h(Ce,"SPAN",{});var ua=u(v);ua.forEach(a),E=o(Ce," is the following: "),w=h(Ce,"SPAN",{});var Ya=u(w);Ya.forEach(a),$=o(Ce," where "),I=h(Ce,"SPAN",{});var Gn=u(I);Gn.forEach(a),U=o(Ce," and "),L=h(Ce,"SPAN",{});var aa=u(L);aa.forEach(a),V=S(Ce),H=h(Ce,"SPAN",{});var an=u(H);an.forEach(a),D=o(Ce," is called the "),Me(X.$$.fragment,Ce),A=o(Ce," and "),se=h(Ce,"SPAN",{});var Kn=u(se);Kn.forEach(a),j=o(Ce," the "),Me(T.$$.fragment,Ce),x=o(Ce," component of "),ie=h(Ce,"SPAN",{});var ma=u(ie);ma.forEach(a),Q=o(Ce," In fact, all real numbers are complex numbers, the imaginary component of which is zero ("),G=h(Ce,"SPAN",{});var Za=u(G);Za.forEach(a),ae=o(Ce,")."),Ce.forEach(a),ze=S(z),le=h(z,"P",{});var Xt=u(le);K=o(Xt,"Complex numbers can be represented geometrically as two-dimensional vectors in the so called "),Me(P.$$.fragment,Xt),re=o(Xt,", where the "),ce=h(Xt,"SPAN",{});var Ja=u(ce);Ja.forEach(a),ke=o(Xt,"-axis stands for the real, and the "),Ve=h(Xt,"SPAN",{});var Er=u(Ve);Er.forEach(a),fe=o(Xt,"-axis for the imaginary component."),Xt.forEach(a),Le=S(z),rt=h(z,"P",{});var Ge=u(rt);ve=o(Ge,"Let "),Ae=h(Ge,"SPAN",{});var Xa=u(Ae);Xa.forEach(a),_t=o(Ge," denote the Euclidean norm of the vector associated with the complex number "),ne=h(Ge,"SPAN",{});var Ur=u(ne);Ur.forEach(a),st=o(Ge," Consequently, "),je=h(Ge,"SPAN",{});var Pa=u(je);Pa.forEach(a),W=o(Ge," is the square of this norm, and it's going to play an important role in what follows."),Ge.forEach(a),pe=S(z),Z=h(z,"P",{});var vt=u(Z);ut=o(vt,"Another important thing to note is that each 2-dimensional vector is uniquely defined by two properties: its length and angle of rotation. Consequently, a complex number "),Be=h(vt,"SPAN",{});var Or=u(Be);Or.forEach(a),mt=o(vt," can be expressed as "),De=h(vt,"SPAN",{});var Ma=u(De);Ma.forEach(a),$t=o(vt," where "),Ye=h(vt,"SPAN",{});var er=u(Ye);er.forEach(a),Nt=o(vt," Here, "),et=h(vt,"SPAN",{});var Gr=u(et);Gr.forEach(a),Lt=o(vt," is a vector of unit length in the complex plane, rotated around the origin by an angle of "),F=h(vt,"SPAN",{});var fa=u(F);fa.forEach(a),We=o(vt," ("),Et=h(vt,"SPAN",{});var xe=u(Et);xe.forEach(a),He=o(vt," corresponds to a full rotation). All we have to do to get back "),bt=h(vt,"SPAN",{});var Kr=u(bt);Kr.forEach(a),on=o(vt," then, is multiply this rotated unit vector by "),Tt=h(vt,"SPAN",{});var pa=u(Tt);pa.forEach(a),ue=o(vt," to adjust its norm."),vt.forEach(a),wn=S(z),Ue=h(z,"H2",{});var kn=u(Ue);Ht=o(kn,"Qubit states"),kn.forEach(a),oe=S(z),tt=h(z,"P",{});var En=u(tt);xt=o(En,"The elementary units of information in classical computing are "),Me(jt.$$.fragment,En),Dt=o(En,". As their name suggests, bits represent one single "),Me(lt.$$.fragment,En),Yt=o(En,", which means they can take on either of two values "),Wt=h(En,"SPAN",{});var Yn=u(Wt);Yn.forEach(a),ia=o(En," and "),Ft=h(En,"SPAN",{});var vs=u(Ft);vs.forEach(a),$a=o(En," at a time."),En.forEach(a),he=S(z),ye=h(z,"P",{});var Ln=u(ye);Me(ft.$$.fragment,Ln),tn=o(Ln," are the quantum computing equivalent of bits. They differ from classical bits - among other things - in that they can take on a multitude of values instead of just "),Ut=h(Ln,"SPAN",{});var ca=u(Ut);ca.forEach(a),gn=o(Ln," and "),Zt=h(Ln,"SPAN",{});var tr=u(Zt);tr.forEach(a),yn=o(Ln," until that value is "),Me(zt.$$.fragment,Ln),Qa=o(Ln,", at which point they behave just like classical bits. To explain what this means exactly, we'll need to introduce some further concepts."),Ln.forEach(a),mn=S(z),de=h(z,"P",{});var Qe=u(de);za=o(Qe,"Let "),Ot=h(Qe,"SPAN",{});var _a=u(Ot);_a.forEach(a),Xn=o(Qe," and "),Pn=h(Qe,"SPAN",{});var nr=u(Pn);nr.forEach(a),In=o(Qe," denote the so called basis states of a qubit that are the quantum-equivalent of classical bit states. If you look at a qubit directly to learn it's value, you'll see one of these basis states. But while you're not looking - due to it's quantum nature - the "),Me(pn.$$.fragment,Qe),Pt=o(Qe," of a qubit may be something more intricate. Generally, it can be expressed as the "),Me(Mt.$$.fragment,Qe),Fn=o(Qe," of the two basis states: "),Mn=h(Qe,"SPAN",{});var Sa=u(Mn);Sa.forEach(a),Qn=o(Qe," Here, "),cn=h(Qe,"SPAN",{});var ar=u(cn);ar.forEach(a),zn=o(Qe," and "),Sn=h(Qe,"SPAN",{});var Tr=u(Sn);Tr.forEach(a),Vt=o(Qe," are complex numbers that indicate the relative weight, with which the two basis states are present in this combination. More precisely, if we now look at the qubit, we'll see the basis state "),Na=h(Qe,"SPAN",{});var hn=u(Na);hn.forEach(a),Ze=o(Qe," with a probability of "),Bn=h(Qe,"SPAN",{});var da=u(Bn);da.forEach(a),ln=o(Qe," and the basis state "),Cn=h(Qe,"SPAN",{});var rn=u(Cn);rn.forEach(a),ka=o(Qe," with a probability of "),_n=h(Qe,"SPAN",{});var Pr=u(_n);Pr.forEach(a),Ka=o(Qe," Because these probabilities must add up to one - as "),we=h(Qe,"SPAN",{});var Ie=u(we);Ie.forEach(a),Ea=o(Qe," and "),ea=h(Qe,"SPAN",{});var qa=u(ea);qa.forEach(a),Ta=o(Qe," are the only possible outcomes - the equation "),ta=h(Qe,"SPAN",{});var rr=u(ta);rr.forEach(a),na=o(Qe," must hold for all possible qubit states. Let's call "),la=h(Qe,"SPAN",{});var ws=u(la);ws.forEach(a),dt=o(Qe," and "),Hn=h(Qe,"SPAN",{});var Mr=u(Hn);Mr.forEach(a),On=o(Qe," the measurement probabilities of the basis states."),Qe.forEach(a)},m(z,Te){g(z,n,Te),t(n,r),g(z,i,Te),g(z,m,Te),t(m,d),Se(_,m,null),t(m,c),t(m,v),v.innerHTML=b,t(m,E),t(m,w),w.innerHTML=N,t(m,$),t(m,I),I.innerHTML=Y,t(m,U),t(m,L),L.innerHTML=C,t(m,V),t(m,H),H.innerHTML=q,t(m,D),Se(X,m,null),t(m,A),t(m,se),se.innerHTML=ee,t(m,j),Se(T,m,null),t(m,x),t(m,ie),ie.innerHTML=R,t(m,Q),t(m,G),G.innerHTML=me,t(m,ae),g(z,ze,Te),g(z,le,Te),t(le,K),Se(P,le,null),t(le,re),t(le,ce),ce.innerHTML=ct,t(le,ke),t(le,Ve),Ve.innerHTML=yt,t(le,fe),g(z,Le,Te),g(z,rt,Te),t(rt,ve),t(rt,Ae),Ae.innerHTML=Ke,t(rt,_t),t(rt,ne),ne.innerHTML=_e,t(rt,st),t(rt,je),je.innerHTML=sn,t(rt,W),g(z,pe,Te),g(z,Z,Te),t(Z,ut),t(Z,Be),Be.innerHTML=Ct,t(Z,mt),t(Z,De),De.innerHTML=St,t(Z,$t),t(Z,Ye),Ye.innerHTML=Kt,t(Z,Nt),t(Z,et),et.innerHTML=kt,t(Z,Lt),t(Z,F),F.innerHTML=Ee,t(Z,We),t(Z,Et),Et.innerHTML=Rt,t(Z,He),t(Z,bt),bt.innerHTML=qt,t(Z,on),t(Z,Tt),Tt.innerHTML=At,t(Z,ue),g(z,wn,Te),g(z,Ue,Te),t(Ue,Ht),g(z,oe,Te),g(z,tt,Te),t(tt,xt),Se(jt,tt,null),t(tt,Dt),Se(lt,tt,null),t(tt,Yt),t(tt,Wt),Wt.innerHTML=It,t(tt,ia),t(tt,Ft),Ft.innerHTML=un,t(tt,$a),g(z,he,Te),g(z,ye,Te),Se(ft,ye,null),t(ye,tn),t(ye,Ut),Ut.innerHTML=Qt,t(ye,gn),t(ye,Zt),Zt.innerHTML=pt,t(ye,yn),Se(zt,ye,null),t(ye,Qa),g(z,mn,Te),g(z,de,Te),t(de,za),t(de,Ot),Ot.innerHTML=fn,t(de,Xn),t(de,Pn),Pn.innerHTML=Fe,t(de,In),Se(pn,de,null),t(de,Pt),Se(Mt,de,null),t(de,Fn),t(de,Mn),Mn.innerHTML=nn,t(de,Qn),t(de,cn),cn.innerHTML=Gt,t(de,zn),t(de,Sn),Sn.innerHTML=Dn,t(de,Vt),t(de,Na),Na.innerHTML=Vn,t(de,Ze),t(de,Bn),Bn.innerHTML=$n,t(de,ln),t(de,Cn),Cn.innerHTML=Nn,t(de,ka),t(de,_n),_n.innerHTML=Wn,t(de,Ka),t(de,we),we.innerHTML=qn,t(de,Ea),t(de,ea),ea.innerHTML=An,t(de,Ta),t(de,ta),ta.innerHTML=Un,t(de,na),t(de,la),la.innerHTML=$e,t(de,dt),t(de,Hn),Hn.innerHTML=Jt,t(de,On),ht=!0,ot||(ha=[p(v,"mouseenter",e[0]),p(w,"mouseenter",e[1]),p(I,"mouseenter",e[2]),p(L,"mouseenter",e[3]),p(H,"mouseenter",e[4]),p(se,"mouseenter",e[5]),p(ie,"mouseenter",e[6]),p(G,"mouseenter",e[7]),p(ce,"mouseenter",e[8]),p(Ve,"mouseenter",e[9]),p(Ae,"mouseenter",e[10]),p(ne,"mouseenter",e[11]),p(je,"mouseenter",e[12]),p(Be,"mouseenter",e[13]),p(De,"mouseenter",e[14]),p(Ye,"mouseenter",e[15]),p(et,"mouseenter",e[16]),p(F,"mouseenter",e[17]),p(Et,"mouseenter",e[18]),p(bt,"mouseenter",e[19]),p(Tt,"mouseenter",e[20]),p(Wt,"mouseenter",e[21]),p(Ft,"mouseenter",e[22]),p(Ut,"mouseenter",e[23]),p(Zt,"mouseenter",e[24]),p(Ot,"mouseenter",e[25]),p(Pn,"mouseenter",e[26]),p(Mn,"mouseenter",e[27]),p(cn,"mouseenter",e[28]),p(Sn,"mouseenter",e[29]),p(Na,"mouseenter",e[30]),p(Bn,"mouseenter",e[31]),p(Cn,"mouseenter",e[32]),p(_n,"mouseenter",e[33]),p(we,"mouseenter",e[34]),p(ea,"mouseenter",e[35]),p(ta,"mouseenter",e[36]),p(la,"mouseenter",e[37]),p(Hn,"mouseenter",e[38])],ot=!0)},p(z,Te){const Ce={};Te[1]&256&&(Ce.$$scope={dirty:Te,ctx:z}),_.$set(Ce);const ua={};Te[1]&256&&(ua.$$scope={dirty:Te,ctx:z}),X.$set(ua);const Ya={};Te[1]&256&&(Ya.$$scope={dirty:Te,ctx:z}),T.$set(Ya);const Gn={};Te[1]&256&&(Gn.$$scope={dirty:Te,ctx:z}),P.$set(Gn);const aa={};Te[1]&256&&(aa.$$scope={dirty:Te,ctx:z}),jt.$set(aa);const an={};Te[1]&256&&(an.$$scope={dirty:Te,ctx:z}),lt.$set(an);const Kn={};Te[1]&256&&(Kn.$$scope={dirty:Te,ctx:z}),ft.$set(Kn);const ma={};Te[1]&256&&(ma.$$scope={dirty:Te,ctx:z}),zt.$set(ma);const Za={};Te[1]&256&&(Za.$$scope={dirty:Te,ctx:z}),pn.$set(Za);const Xt={};Te[1]&256&&(Xt.$$scope={dirty:Te,ctx:z}),Mt.$set(Xt)},i(z){ht||(be(_.$$.fragment,z),be(X.$$.fragment,z),be(T.$$.fragment,z),be(P.$$.fragment,z),be(jt.$$.fragment,z),be(lt.$$.fragment,z),be(ft.$$.fragment,z),be(zt.$$.fragment,z),be(pn.$$.fragment,z),be(Mt.$$.fragment,z),ht=!0)},o(z){Ne(_.$$.fragment,z),Ne(X.$$.fragment,z),Ne(T.$$.fragment,z),Ne(P.$$.fragment,z),Ne(jt.$$.fragment,z),Ne(lt.$$.fragment,z),Ne(ft.$$.fragment,z),Ne(zt.$$.fragment,z),Ne(pn.$$.fragment,z),Ne(Mt.$$.fragment,z),ht=!1},d(z){z&&a(n),z&&a(i),z&&a(m),qe(_),qe(X),qe(T),z&&a(ze),z&&a(le),qe(P),z&&a(Le),z&&a(rt),z&&a(pe),z&&a(Z),z&&a(wn),z&&a(Ue),z&&a(oe),z&&a(tt),qe(jt),qe(lt),z&&a(he),z&&a(ye),qe(ft),qe(zt),z&&a(mn),z&&a(de),qe(pn),qe(Mt),ot=!1,kr(ha)}}}function Oe(e){console.log(e)}function Nf(e){return[()=>Oe(["C","z"]),()=>Oe(["a","z","b"]),()=>Oe(["R","a","b"]),()=>Oe([]),()=>Oe(["a"]),()=>Oe(["b"]),()=>Oe(["z"]),()=>Oe(["a"]),()=>Oe(["x"]),()=>Oe(["y"]),()=>Oe(["a","z","b"]),()=>Oe(["z"]),()=>Oe(["a","z","b"]),()=>Oe(["z"]),()=>Oe(["\\phi","z"]),()=>Oe(["\\phi","z"]),()=>Oe(["\\phi","z"]),()=>Oe(["\\phi","z"]),()=>Oe([]),()=>Oe(["z"]),()=>Oe(["z"]),()=>Oe([]),()=>Oe([]),()=>Oe([]),()=>Oe([]),()=>Oe([]),()=>Oe([]),()=>Oe(["\\beta","\\alpha"]),()=>Oe(["\\alpha"]),()=>Oe(["\\beta"]),()=>Oe([]),()=>Oe(["\\alpha"]),()=>Oe([]),()=>Oe(["\\beta"]),()=>Oe([]),()=>Oe([]),()=>Oe(["\\beta","\\alpha"]),()=>Oe(["\\alpha"]),()=>Oe(["\\beta"])]}class kf extends wa{constructor(n){super(),ga(this,n,Nf,$f,ya,{},null,[-1,-1])}}const Ef='<a href="https://en.wikipedia.org/wiki/Separable_state"><h3>Separable state</h3></a><p>In quantum mechanics, <b>separable states</b> are quantum states belonging to a composite space that can be factored into individual states belonging to separate subspaces. A state is said to be entangled if it is not separable. In general, determining if a state is separable is not straightforward and the problem is classed as NP-hard.</p>',Tf='<a href="https://en.wikipedia.org/wiki/Quantum_entanglement"><h3>Quantum entanglement</h3></a><p><b>Quantum entanglement</b> is the physical phenomenon that occurs when a group of particles are generated, interact, or share spatial proximity in a way such that the quantum state of each particle of the group cannot be described independently of the state of the others, including when the particles are separated by a large distance. The topic of quantum entanglement is at the heart of the disparity between classical and quantum physics: entanglement is a primary feature of quantum mechanics lacking in classical mechanics.</p>',Pf='<a href="https://en.wikipedia.org/wiki/Quantum_register"><h3>Quantum register</h3></a><p>In quantum computing, a <b>quantum register</b> is a system comprising multiple qubits. It is the quantum analogue of the classical processor register. Quantum computers perform calculations by manipulating qubits within a quantum register.</p>',Mf='<a href="https://en.wikipedia.org/wiki/Operator_(physics)"><h3>Operator (physics)</h3></a><p>In physics, an <b>operator</b> is a function over a space of physical states onto another space of physical states. The simplest example of the utility of operators is the study of symmetry. Because of this, they are very useful tools in classical mechanics. Operators are even more important in quantum mechanics, where they form an intrinsic part of the formulation of the theory.</p>',Sf=`<a href="https://en.wikipedia.org/wiki/Quantum_circuit"><h3>Quantum circuit</h3></a><p>In quantum information theory, a <b>quantum circuit</b> is a model for quantum computation, similar to classical circuits, in which a computation is a sequence of quantum gates, measurements, initializations of qubits to known values, and possibly other actions. The minimum set of actions that a circuit needs to be able to perform on the qubits to enable quantum computation is known as DiVincenzo's criteria.</p>`,qf='<a href="https://en.wikipedia.org/wiki/Quantum_logic_gate"><h3>Quantum logic gate</h3></a><p>In quantum computing and specifically the quantum circuit model of computation, a <b>quantum logic gate</b> is a basic quantum circuit operating on a small number of qubits. They are the building blocks of quantum circuits, like classical logic gates are for conventional digital circuits.</p>';function Af(e){let n;return{c(){n=s("separable")},l(r){n=o(r,"separable")},m(r,i){g(r,n,i)},d(r){r&&a(n)}}}function Hf(e){let n;return{c(){n=s("entaglement")},l(r){n=o(r,"entaglement")},m(r,i){g(r,n,i)},d(r){r&&a(n)}}}function Lf(e){let n;return{c(){n=s("quantum register")},l(r){n=o(r,"quantum register")},m(r,i){g(r,n,i)},d(r){r&&a(n)}}}function xf(e){let n;return{c(){n=s("Quantum operators")},l(r){n=o(r,"Quantum operators")},m(r,i){g(r,n,i)},d(r){r&&a(n)}}}function If(e){let n;return{c(){n=s("quantum circuit")},l(r){n=o(r,"quantum circuit")},m(r,i){g(r,n,i)},d(r){r&&a(n)}}}function Ff(e){let n;return{c(){n=s("quantum logic gates")},l(r){n=o(r,"quantum logic gates")},m(r,i){g(r,n,i)},d(r){r&&a(n)}}}function Qf(e){let n,r,i,m,d,_,c,v,b,E,w=f("|0\\rangle,")+"",N,$,I=f("|1\\rangle,")+"",Y,U,L,C,V,H,q,D=f("|\\psi\\rangle")+"",X,A,se=f("n")+"",ee,j,T=f("|\\psi\\rangle = \\left( \\alpha_1 |0\\rangle + \\beta_1 |1\\rangle \\right) \\otimes ... \\otimes \\left( \\alpha_n |0\\rangle + \\beta_n |1\\rangle \\right),")+"",x,ie,R=f("\\alpha_k, \\beta_k")+"",Q,G,me=f("k")+"",ae,ze,le=f("\\otimes")+"",K,P,re,ce,ct,ke,Ve,yt,fe,Le,rt,ve,Ae,Ke,_t,ne,_e,st,je,sn=f("U")+"",W,pe,Z=f("|\\psi\\rangle")+"",ut,Be,Ct=f("U|\\psi\\rangle.")+"",mt,De,St,$t,Ye,Kt,Nt,et,kt,Lt;return _=new it({props:{hovertext:Ef,$$slots:{default:[Af]},$$scope:{ctx:e}}}),v=new it({props:{hovertext:Tf,$$slots:{default:[Hf]},$$scope:{ctx:e}}}),V=new it({props:{hovertext:Pf,$$slots:{default:[Lf]},$$scope:{ctx:e}}}),Le=new it({props:{hovertext:Mf,$$slots:{default:[xf]},$$scope:{ctx:e}}}),ve=new it({props:{hovertext:Sf,$$slots:{default:[If]},$$scope:{ctx:e}}}),Ke=new it({props:{hovertext:qf,$$slots:{default:[Ff]},$$scope:{ctx:e}}}),{c(){n=l("h2"),r=s("Multiple qubits"),i=M(),m=l("p"),d=s("Most quantum algorithms require not only one, but several qubits. The states of these qubits may be "),Pe(_.$$.fragment),c=s(", meaning they each contain one independent unit of information. However, it is possible for multiple qubits to share some information with each other, in which case they no longer have states of their own, but only one joint state. This is called "),Pe(v.$$.fragment),b=s(", and it is another fundamental difference between classical and quantum computing. As an example, two qubits can be entangled in a way that, if we look at one of them and find it's in the basis state "),E=l("span"),N=s(" we learn immediately that the other one must be in the basis state "),$=l("span"),Y=s(" and vice versa."),U=M(),L=l("p"),C=s("From now on, we'll refer to a sequence of qubits as a "),Pe(V.$$.fragment),H=s(". Let "),q=l("span"),X=s(" denote the state of a register consisting of "),A=l("span"),ee=s(" qubits. If the qubits are separable, the state can be written as "),j=l("span"),x=s(" where "),ie=l("span"),Q=s(" are the coefficients associated with the state of the "),G=l("span"),ae=s("-th qubit as described above, and the operator "),ze=l("span"),K=s(" indicates that none of the qubits are entagled with each other."),P=M(),re=l("p"),ce=s("Note that the state of the register can also be written as a vector, but what you saw above and what we're going to use in the rest of the explanation is the alternative, so called Dirac or bra-ket notation."),ct=M(),ke=l("h2"),Ve=s("Quantum circuits and algorithms"),yt=M(),fe=l("p"),Pe(Le.$$.fragment),rt=s(" are functions that act on the state of a quantum system. Quantum algorithms are sequences of specific quantum operators that modify the state of single or multiple qubits. The physical device that implements quantum algorithms is called a "),Pe(ve.$$.fragment),Ae=s(", the building blocks of which are "),Pe(Ke.$$.fragment),_t=s(" that correspond to the individual operators in the sequence."),ne=M(),_e=l("p"),st=s("For each quantum operator, there's a corresponding matrix and - as we mentioned above - the state of the register can be written as a vector, so the algebraic representation of an operator "),je=l("span"),W=s(" acting on the state "),pe=l("span"),ut=s(" is essentially the matrix multiplication "),Be=l("span"),mt=s(" You can think of this representation as the "),De=l("em"),St=s("how"),$t=s(" of the algorithm, which we do not elaborate on here, in order to avoid overwhelming you with information. Instead, we only show "),Ye=l("em"),Kt=s("what"),Nt=s(" a particular operator does to the state of the register, and leave it to your curiosity to go into further details.")},l(F){n=h(F,"H2",{});var Ee=u(n);r=o(Ee,"Multiple qubits"),Ee.forEach(a),i=S(F),m=h(F,"P",{});var We=u(m);d=o(We,"Most quantum algorithms require not only one, but several qubits. The states of these qubits may be "),Me(_.$$.fragment,We),c=o(We,", meaning they each contain one independent unit of information. However, it is possible for multiple qubits to share some information with each other, in which case they no longer have states of their own, but only one joint state. This is called "),Me(v.$$.fragment,We),b=o(We,", and it is another fundamental difference between classical and quantum computing. As an example, two qubits can be entangled in a way that, if we look at one of them and find it's in the basis state "),E=h(We,"SPAN",{});var Et=u(E);Et.forEach(a),N=o(We," we learn immediately that the other one must be in the basis state "),$=h(We,"SPAN",{});var Rt=u($);Rt.forEach(a),Y=o(We," and vice versa."),We.forEach(a),U=S(F),L=h(F,"P",{});var He=u(L);C=o(He,"From now on, we'll refer to a sequence of qubits as a "),Me(V.$$.fragment,He),H=o(He,". Let "),q=h(He,"SPAN",{});var bt=u(q);bt.forEach(a),X=o(He," denote the state of a register consisting of "),A=h(He,"SPAN",{});var qt=u(A);qt.forEach(a),ee=o(He," qubits. If the qubits are separable, the state can be written as "),j=h(He,"SPAN",{});var on=u(j);on.forEach(a),x=o(He," where "),ie=h(He,"SPAN",{});var Tt=u(ie);Tt.forEach(a),Q=o(He," are the coefficients associated with the state of the "),G=h(He,"SPAN",{});var At=u(G);At.forEach(a),ae=o(He,"-th qubit as described above, and the operator "),ze=h(He,"SPAN",{});var ue=u(ze);ue.forEach(a),K=o(He," indicates that none of the qubits are entagled with each other."),He.forEach(a),P=S(F),re=h(F,"P",{});var wn=u(re);ce=o(wn,"Note that the state of the register can also be written as a vector, but what you saw above and what we're going to use in the rest of the explanation is the alternative, so called Dirac or bra-ket notation."),wn.forEach(a),ct=S(F),ke=h(F,"H2",{});var Ue=u(ke);Ve=o(Ue,"Quantum circuits and algorithms"),Ue.forEach(a),yt=S(F),fe=h(F,"P",{});var Ht=u(fe);Me(Le.$$.fragment,Ht),rt=o(Ht," are functions that act on the state of a quantum system. Quantum algorithms are sequences of specific quantum operators that modify the state of single or multiple qubits. The physical device that implements quantum algorithms is called a "),Me(ve.$$.fragment,Ht),Ae=o(Ht,", the building blocks of which are "),Me(Ke.$$.fragment,Ht),_t=o(Ht," that correspond to the individual operators in the sequence."),Ht.forEach(a),ne=S(F),_e=h(F,"P",{});var oe=u(_e);st=o(oe,"For each quantum operator, there's a corresponding matrix and - as we mentioned above - the state of the register can be written as a vector, so the algebraic representation of an operator "),je=h(oe,"SPAN",{});var tt=u(je);tt.forEach(a),W=o(oe," acting on the state "),pe=h(oe,"SPAN",{});var xt=u(pe);xt.forEach(a),ut=o(oe," is essentially the matrix multiplication "),Be=h(oe,"SPAN",{});var jt=u(Be);jt.forEach(a),mt=o(oe," You can think of this representation as the "),De=h(oe,"EM",{});var Dt=u(De);St=o(Dt,"how"),Dt.forEach(a),$t=o(oe," of the algorithm, which we do not elaborate on here, in order to avoid overwhelming you with information. Instead, we only show "),Ye=h(oe,"EM",{});var lt=u(Ye);Kt=o(lt,"what"),lt.forEach(a),Nt=o(oe," a particular operator does to the state of the register, and leave it to your curiosity to go into further details."),oe.forEach(a)},m(F,Ee){g(F,n,Ee),t(n,r),g(F,i,Ee),g(F,m,Ee),t(m,d),Se(_,m,null),t(m,c),Se(v,m,null),t(m,b),t(m,E),E.innerHTML=w,t(m,N),t(m,$),$.innerHTML=I,t(m,Y),g(F,U,Ee),g(F,L,Ee),t(L,C),Se(V,L,null),t(L,H),t(L,q),q.innerHTML=D,t(L,X),t(L,A),A.innerHTML=se,t(L,ee),t(L,j),j.innerHTML=T,t(L,x),t(L,ie),ie.innerHTML=R,t(L,Q),t(L,G),G.innerHTML=me,t(L,ae),t(L,ze),ze.innerHTML=le,t(L,K),g(F,P,Ee),g(F,re,Ee),t(re,ce),g(F,ct,Ee),g(F,ke,Ee),t(ke,Ve),g(F,yt,Ee),g(F,fe,Ee),Se(Le,fe,null),t(fe,rt),Se(ve,fe,null),t(fe,Ae),Se(Ke,fe,null),t(fe,_t),g(F,ne,Ee),g(F,_e,Ee),t(_e,st),t(_e,je),je.innerHTML=sn,t(_e,W),t(_e,pe),pe.innerHTML=Z,t(_e,ut),t(_e,Be),Be.innerHTML=Ct,t(_e,mt),t(_e,De),t(De,St),t(_e,$t),t(_e,Ye),t(Ye,Kt),t(_e,Nt),et=!0,kt||(Lt=[p(E,"mouseenter",e[0]),p($,"mouseenter",e[1]),p(q,"mouseenter",e[2]),p(A,"mouseenter",e[3]),p(j,"mouseenter",e[4]),p(ie,"mouseenter",e[5]),p(G,"mouseenter",e[6]),p(ze,"mouseenter",e[7]),p(je,"mouseenter",e[8]),p(pe,"mouseenter",e[9]),p(Be,"mouseenter",e[10])],kt=!0)},p(F,[Ee]){const We={};Ee&2048&&(We.$$scope={dirty:Ee,ctx:F}),_.$set(We);const Et={};Ee&2048&&(Et.$$scope={dirty:Ee,ctx:F}),v.$set(Et);const Rt={};Ee&2048&&(Rt.$$scope={dirty:Ee,ctx:F}),V.$set(Rt);const He={};Ee&2048&&(He.$$scope={dirty:Ee,ctx:F}),Le.$set(He);const bt={};Ee&2048&&(bt.$$scope={dirty:Ee,ctx:F}),ve.$set(bt);const qt={};Ee&2048&&(qt.$$scope={dirty:Ee,ctx:F}),Ke.$set(qt)},i(F){et||(be(_.$$.fragment,F),be(v.$$.fragment,F),be(V.$$.fragment,F),be(Le.$$.fragment,F),be(ve.$$.fragment,F),be(Ke.$$.fragment,F),et=!0)},o(F){Ne(_.$$.fragment,F),Ne(v.$$.fragment,F),Ne(V.$$.fragment,F),Ne(Le.$$.fragment,F),Ne(ve.$$.fragment,F),Ne(Ke.$$.fragment,F),et=!1},d(F){F&&a(n),F&&a(i),F&&a(m),qe(_),qe(v),F&&a(U),F&&a(L),qe(V),F&&a(P),F&&a(re),F&&a(ct),F&&a(ke),F&&a(yt),F&&a(fe),qe(Le),qe(ve),qe(Ke),F&&a(ne),F&&a(_e),kt=!1,kr(Lt)}}}function $r(e){console.log(e)}function zf(e){return[()=>$r([]),()=>$r([]),()=>$r(["\\psi"]),()=>$r(["n"]),()=>$r(["\\psi","n","\\alpha","\\beta"]),()=>$r(["\\beta","k","\\alpha"]),()=>$r(["k"]),()=>$r([]),()=>$r(["U"]),()=>$r(["\\psi"]),()=>$r(["\\psi","U"])]}class Vf extends wa{constructor(n){super(),ga(this,n,zf,Qf,ya,{})}}function Bf(e){let n,r,i,m,d,_,c,v,b,E,w,N,$,I,Y=f("\\phi_\\alpha")+"",U,L,C,V=f("\\phi_\\beta")+"",H,q,D,X=f("r_\\alpha")+"",A,se,ee,j,T,x,ie,R,Q,G,me,ae,ze,le,K;return m=new kf({}),R=new Vh({props:{displayBloch:e[2],phiAlpha:e[4],phiBeta:e[3],rAlpha:e[5],blochClass:"col-lg-4 col-sm-12",vectorClass:"col-lg-4 col-sm-12"}}),G=new ef({}),ae=new Vf({}),{c(){n=l("h2"),r=s("Quantum Basics"),i=M(),Pe(m.$$.fragment),d=M(),_=l("div"),c=l("div"),v=l("div"),b=l("p"),E=s(`Play around with 2 representations of a single qubit. You adjust the view of the 3D Bloch
				sphere by clicking on the image and dragging.`),w=M(),N=l("div"),$=l("div"),I=new wt(!1),U=l("input"),L=M(),C=new wt(!1),H=l("input"),q=M(),D=new wt(!1),A=l("input"),se=M(),ee=l("b"),j=s("Display Bloch sphere"),T=M(),x=l("input"),ie=M(),Pe(R.$$.fragment),Q=M(),Pe(G.$$.fragment),me=M(),Pe(ae.$$.fragment),this.h()},l(P){n=h(P,"H2",{});var re=u(n);r=o(re,"Quantum Basics"),re.forEach(a),i=S(P),Me(m.$$.fragment,P),d=S(P),_=h(P,"DIV",{class:!0});var ce=u(_);c=h(ce,"DIV",{class:!0});var ct=u(c);v=h(ct,"DIV",{class:!0});var ke=u(v);b=h(ke,"P",{});var Ve=u(b);E=o(Ve,`Play around with 2 representations of a single qubit. You adjust the view of the 3D Bloch
				sphere by clicking on the image and dragging.`),Ve.forEach(a),ke.forEach(a),ct.forEach(a),w=S(ce),N=h(ce,"DIV",{class:!0});var yt=u(N);$=h(yt,"DIV",{class:!0});var fe=u($);I=gt(fe,!1),U=h(fe,"INPUT",{type:!0,min:!0,max:!0,step:!0,class:!0}),L=S(fe),C=gt(fe,!1),H=h(fe,"INPUT",{type:!0,min:!0,max:!0,step:!0,class:!0}),q=S(fe),D=gt(fe,!1),A=h(fe,"INPUT",{type:!0,min:!0,max:!0,step:!0,class:!0}),se=S(fe),ee=h(fe,"B",{});var Le=u(ee);j=o(Le,"Display Bloch sphere"),Le.forEach(a),T=S(fe),x=h(fe,"INPUT",{type:!0,style:!0,class:!0}),fe.forEach(a),ie=S(yt),Me(R.$$.fragment,yt),yt.forEach(a),ce.forEach(a),Q=S(P),Me(G.$$.fragment,P),me=S(P),Me(ae.$$.fragment,P),this.h()},h(){B(v,"class","col-12"),B(c,"class","row mb-4"),I.a=U,B(U,"type","range"),B(U,"min",0),B(U,"max",360),B(U,"step",1),B(U,"class","svelte-unwbto"),C.a=H,B(H,"type","range"),B(H,"min",0),B(H,"max",360),B(H,"step",1),B(H,"class","svelte-unwbto"),D.a=A,B(A,"type","range"),B(A,"min",0),B(A,"max",1),B(A,"step",.01),B(A,"class","svelte-unwbto"),B(x,"type","checkbox"),Ih(x,"width","auto"),B(x,"class","svelte-unwbto"),B($,"class","col-lg-4 col-sm-12"),B(N,"class","row"),B(_,"class","interaction container")},m(P,re){g(P,n,re),t(n,r),g(P,i,re),Se(m,P,re),g(P,d,re),g(P,_,re),t(_,c),t(c,v),t(v,b),t(b,E),t(_,w),t(_,N),t(N,$),I.m(Y,$),t($,U),oa(U,e[1]),t($,L),C.m(V,$),t($,H),oa(H,e[0]),t($,q),D.m(X,$),t($,A),oa(A,e[5]),t($,se),t($,ee),t(ee,j),t($,T),t($,x),x.checked=e[2],t(N,ie),Se(R,N,null),g(P,Q,re),Se(G,P,re),g(P,me,re),Se(ae,P,re),ze=!0,le||(K=[p(U,"change",e[6]),p(U,"input",e[6]),p(H,"change",e[7]),p(H,"input",e[7]),p(A,"change",e[8]),p(A,"input",e[8]),p(x,"change",e[9])],le=!0)},p(P,[re]){re&2&&oa(U,P[1]),re&1&&oa(H,P[0]),re&32&&oa(A,P[5]),re&4&&(x.checked=P[2]);const ce={};re&4&&(ce.displayBloch=P[2]),re&16&&(ce.phiAlpha=P[4]),re&8&&(ce.phiBeta=P[3]),re&32&&(ce.rAlpha=P[5]),R.$set(ce)},i(P){ze||(be(m.$$.fragment,P),be(R.$$.fragment,P),be(G.$$.fragment,P),be(ae.$$.fragment,P),ze=!0)},o(P){Ne(m.$$.fragment,P),Ne(R.$$.fragment,P),Ne(G.$$.fragment,P),Ne(ae.$$.fragment,P),ze=!1},d(P){P&&a(n),P&&a(i),qe(m,P),P&&a(d),P&&a(_),qe(R),P&&a(Q),qe(G,P),P&&a(me),qe(ae,P),le=!1,kr(K)}}}function Cf(e,n,r){let i,m,d,_,c,v=!0;function b(){i=Dr(this.value),r(1,i)}function E(){m=Dr(this.value),r(0,m)}function w(){d=Dr(this.value),r(5,d)}function N(){v=this.checked,r(2,v)}return e.$$.update=()=>{e.$$.dirty&2&&r(4,_=i/180*ll),e.$$.dirty&1&&r(3,c=m/180*ll)},r(1,i=15),r(0,m=310),r(5,d=.9),[m,i,v,c,_,d,b,E,w,N]}class Rf extends wa{constructor(n){super(),ga(this,n,Cf,Bf,ya,{})}}const jf='<a href="https://en.wikipedia.org/wiki/Periodic_function"><h3 class="text-lg font-semibold">Periodic function</h3></a><p>A <b>periodic function</b> is a function that repeats its values at regular intervals. For example, the trigonometric functions, which repeat at intervals of <span class="mwe-math-element"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/73efd1f6493490b058097060a572606d2c550a06" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align:-0.338ex;width:2.494ex;height:2.176ex" /></span> radians, are periodic functions. Periodic functions are used throughout science to describe oscillations, waves, and other phenomena that exhibit periodicity. Any function that is not periodic is called <b>aperiodic</b>.</p>',Df='<a href="https://en.wikipedia.org/wiki/Wave_interference"><h3>Wave interference</h3></a><p>In physics, <b>interference</b> is a phenomenon in which two waves combine by adding their displacement together at every single point in space and time, to form a resultant wave of greater, lower, or the same amplitude. <b>Constructive</b> and <b>destructive interference</b> result from the interaction of waves that are correlated or coherent with each other, either because they come from the same source or because they have the same or nearly the same frequency. Interference effects can be observed with all types of waves, for example, light, radio, acoustic, surface water waves, gravity waves, or matter waves.</p>';function Wf(e){let n;return{c(){n=s("periodic")},l(r){n=o(r,"periodic")},m(r,i){g(r,n,i)},d(r){r&&a(n)}}}function Uf(e){let n;return{c(){n=s("interfere")},l(r){n=o(r,"interfere")},m(r,i){g(r,n,i)},d(r){r&&a(n)}}}function Of(e){let n,r,i,m,d,_,c=f("N,")+"",v,b,E=f("1 < \\hat{r} < N")+"",w,N,$=f("f_{a, N}(\\hat{r}) = a^{\\hat{r}} \\mod N = 1.")+"",I,Y,U=f("f_{a, N}")+"",L,C,V,H,q=f("\\hat{r}")+"",D,X,A,se,ee,j=f("g")+"",T,x,ie=f("0 < p,")+"",R,Q,G=f("g(x) = g(x + p)")+"",me,ae,ze=f("x")+"",le,K,P=f("g.")+"",re,ce,ct=f("g")+"",ke,Ve,yt=f("p.")+"",fe,Le,rt=f("f_{a, N},")+"",ve,Ae,Ke=f("\\mathbb{N},")+"",_t,ne,_e,st,je,sn=f("\\hat{p} \\in \\mathbb{N}")+"",W,pe,Z=f("f_{a, N}.")+"",ut,Be,Ct=f("f_{a, N}(0) = a^{0} \\mod N = 1 \\mod N = 1,")+"",mt,De,St=f("f_{a, N}(0) = f_{a, N}(0 + \\hat{p}) = f_{a, N}(\\hat{p}) = 1.")+"",$t,Ye,Kt=f("\\hat{p}")+"",Nt,et,kt=f("f_{a, N}")+"",Lt,F,Ee=f("1.")+"",We,Et,Rt=f("\\hat{r},")+"",He,bt,qt=f("\\hat{r} = \\hat{p}.")+"",on,Tt,At,ue,wn=f("f_{a, N},")+"",Ue,Ht,oe,tt,xt,jt,Dt,lt,Yt,Wt,It,ia=f("\\log_2N")+"",Ft,un,$a=f("N")+"",he,ye,ft=f("\\log_2N")+"",tn,Ut,Qt,gn,Zt,pt=f("\\log_2N \\leq n")+"",yn,zt,Qa=f("|\\psi_1\\rangle, |\\psi_2\\rangle")+"",mn,de,za=f("|0\\rangle,")+"",Ot,fn,Xn=f("|\\psi_1\\rangle = \\underbrace{|0\\rangle \\otimes \\ldots \\otimes |0\\rangle}_\\text{n terms}.")+"",Pn,Fe,In,pn,Pt,Mt,Fn,Mn=f("H")+"",nn,Qn,cn=f("|\\psi_1\\rangle = \\underbrace{\\frac{1}{\\sqrt{2}}(|0\\rangle + |1\\rangle) \\otimes \\ldots \\otimes \\frac{1}{\\sqrt{2}}(|0\\rangle + |1\\rangle)}_\\text{n terms}.")+"",Gt,zn,Sn=f("\\frac{1}{\\sqrt{2}}")+"",Dn,Vt,Na=f("|\\psi_1\\rangle = \\frac{1}{\\sqrt{2^n}}(|0\\rangle + |1\\rangle) \\otimes \\ldots \\otimes (|0\\rangle + |1\\rangle).")+"",Vn,Ze,Bn,$n,ln=f("x")+"",Cn,Nn,ka=f("x")+"",_n,Wn,Ka=f("0")+"",we,qn,Ea=f("2^n - 1.")+"",ea,An,Ta=f("|\\psi_1\\rangle = \\displaystyle{\\frac{1}{\\sqrt{2^n}}\\sum_{x=0}^{2^n-1}|x\\rangle}.")+"",ta,Un,na=f("x,")+"",la,$e,dt=f("\\frac{1}{2^n}.")+"",Hn,Jt,On,ht,ot,ha,z,Te=f("|1\\rangle,")+"",Ce,ua,Ya=f("|\\psi_2\\rangle = \\underbrace{|0\\rangle \\otimes \\ldots \\otimes |0\\rangle}_\\text{n terms}.")+"",Gn,aa,an=f("y")+"",Kn,ma,Za=f("x.")+"",Xt,Ja,Er=f("f_{a, N}(x) = a^x \\mod N.")+"",Ge,Xa,Ur=f("x")+"",Pa,vt,Or=f("0")+"",Ma,er,Gr=f("2^n - 1,")+"",fa,xe,Kr=f("y = a^x \\mod N.")+"",pa,kn,En,Yn,vs=f("x,")+"",Ln,ca,tr=f("y = a^x \\mod N")+"",Qe,_a,nr=f("x.")+"",Sa,ar,Tr=f("\\displaystyle{|\\psi_2\\rangle = \\sum_{x=0}^{2^n - 1} |y\\rangle = \\sum_{x=0}^{2^n - 1} |a^x \\mod N\\rangle}.")+"",hn,da,rn,Pr,Ie,qa,rr,ws=f("y")+"",Mr,ba,Sr=f("|\\psi_2,")+"",qr,Xr,so=f("\\psi_1,")+"",Ar,es,oo=f("y")+"",gs,Aa,ts=f("x,")+"",io,Hr,ns=f("y,")+"",lo,ur,as=f("x")+"",ys,mr,Ha=f("a^x \\mod N = y.")+"",$s,Va,ti=f("x")+"",Ns,sr,ho=f("f_{a, N}")+"",ks,or,uo=f("\\hat{p},")+"",Es,fr,Lr=f("\\hat{p}")+"",Ts,ir,mo=f("0 \\leq x_0, \\ldots, x_k < 2^n")+"",Ps,pr,rs=f("\\displaystyle{|\\psi_1\\rangle = \\sum_{i=0}^{k} |x_i\\rangle},")+"",xr,ss,Ds=f("x_{i + 1} - x_i = \\hat{p}")+"",Ir,Ba,ni=f("i < k.")+"",Yr,Ca,Ms,Zr,Tn,Fr,os,Ws=f("x,")+"",La,Qr,is=f("\\displaystyle{|\\psi_1\\rangle = \\frac{1}{\\sqrt{2^n}} \\sum_{y=0}^{2^n - 1} e^{\\frac{2 \\pi i x y}{2^n}} |y\\rangle}.")+"",fo,zr,ls=f("x")+"",po,Vr,Us=f("\\displaystyle{|\\psi_1\\rangle = \\frac{1}{\\sqrt{2^n}} \\sum_{i=0}^{k} \\sum_{x=0}^{2^n - 1} e^{\\frac{2 \\pi i x_i y}{2^n}} |x\\rangle}.")+"",cr,Ra,co,Jr,Je,Ss,ja,ai=f("x,")+"",qs,Da,ri=f("x.")+"",As,Wa,si=f("x_0, \\ldots, x_k.")+"",Hs,va,_o,Br,hs=f("x_0, \\ldots, x_k,")+"",bo,Cr,us=f("1.")+"",Os,Rn,ms,Ua,fs=f("x")+"",vo,_r,ps=f("x,")+"",Ls,dr,jn=f("\\frac{j\\cdot N}{\\hat{p}}")+"",xs,Oa,oi=f("j = 0, \\ldots, \\hat{p} - 1.")+"",Is,br,wo,Gs;return C=new it({props:{hovertext:jf,$$slots:{default:[Wf]},$$scope:{ctx:e}}}),va=new it({props:{hovertext:Df,$$slots:{default:[Uf]},$$scope:{ctx:e}}}),{c(){n=l("h2"),r=s("The period-finding problem"),i=M(),m=l("p"),d=s("Recall the steps for computing the prime factors of a large integer "),_=l("span"),v=s(" the hard part of which was finding the smallest "),b=l("span"),w=s(" such that "),N=l("span"),I=s(" It turns out that "),Y=l("span"),L=s(" is a "),Pe(C.$$.fragment),V=s(" function, and below we'll show that the number "),H=l("span"),D=s(" we're looking for is exactly its period."),X=M(),A=l("p"),se=s("In general, the period of a function "),ee=l("span"),T=s(" is defined as the smallest positive number "),x=l("span"),R=s(" for which "),Q=l("span"),me=s(" for all "),ae=l("span"),le=s(" in the domain of "),K=l("span"),re=s(" (In other words, "),ce=l("span"),ke=s(" is a repeating sequence of the same pattern with length "),Ve=l("span"),fe=s(") Specifically for "),Le=l("span"),ve=s(" because its domain is "),Ae=l("span"),_t=s(" its period has to be an integer."),ne=M(),_e=l("p"),st=s("Let "),je=l("span"),W=s(" denote the period of "),pe=l("span"),ut=s(" We know for sure that "),Be=l("span"),mt=s(" from which follows that "),De=l("span"),$t=s(" Thus, the "),Ye=l("span"),Nt=s(" is the smallest positive integer, for which the value of "),et=l("span"),Lt=s(" equals "),F=l("span"),We=s(" Notice that this is exactly how we originally defined "),Et=l("span"),He=s(" and so "),bt=l("span"),on=M(),Tt=l("p"),At=s("Thus, the factoring problem can essentially be reformulated as the problem of finding the period of the function "),ue=l("span"),Ue=s(" for which the quantum Fourier transform turns out to be really useful."),Ht=M(),oe=l("h2"),tt=s("The algorithm"),xt=M(),jt=l("h4"),Dt=s("Step 1."),lt=M(),Yt=l("p"),Wt=s("In order to implement Shor's algorithm, we'll need two quantum register with at least "),It=l("span"),Ft=s(" qubits, as that is the number of digits required to represent "),un=l("span"),he=s(" in binary notation. (In case "),ye=l("span"),tn=s(" is not an integer, we have to round it up.) Note that this is a lower limit, and the more qubits we use, the faster we'll find the solution."),Ut=M(),Qt=l("p"),gn=s("Let "),Zt=l("span"),yn=s(" denote the number of qubits we chose to construct the both registers, and "),zt=l("span"),mn=s(" the current state of the two registers. Let's ignore the second register for now, and start with all qubits of the first register being in the basis state "),de=l("span"),Ot=s(" thus we can write its state as "),fn=l("span"),Pn=M(),Fe=l("h4"),In=s("Step 2."),pn=M(),Pt=l("p"),Mt=s("Next, we apply the so called "),Fn=l("span"),nn=s(" (Hadamard) gate to each qubit of the first register, in order to set them into an equal superposition of the two basis states. This means the state of the register is now "),Qn=l("span"),Gt=s(" We can factor out the "),zn=l("span"),Dn=s(" terms to obtain "),Vt=l("span"),Vn=M(),Ze=l("p"),Bn=s("Let "),$n=l("span"),Cn=s(" denote the number represented by the qubits of the first register (that is, the number we get if we read out the state as a sequence of binary digits). As we already saw in the case of the QFT, each qubit being in an equal superposition of the two basis states translates to the entire register being in the superposition of all combinations of these basis states, and consequently "),Nn=l("span"),_n=s(" being in the superposition of all values from "),Wn=l("span"),we=s(" to "),qn=l("span"),ea=s(" Let's express the state as the superposition of these values: "),An=l("span"),ta=s(" Thus, if we now measure the entire register and read out "),Un=l("span"),la=s(" we're going to get each possible value with an equal probability of "),$e=l("span"),Hn=M(),Jt=l("h4"),On=s("Step 3."),ht=M(),ot=l("p"),ha=s("This is the point where the second register enters the picture. We begin with all qubits of this register being in the basis state "),z=l("span"),Ce=s(" so "),ua=l("span"),Gn=s(" Let "),aa=l("span"),Kn=s(" denote the number represented by the second register, analogously to "),ma=l("span"),Xt=s(" Next, we apply a combination of gates to entangle the qubits of the two registers in a special way, in order to implement the function "),Ja=l("span"),Ge=s(" To see what this means, let's take a step back and assume all qubits of the first register are in one particular basis state, and so "),Xa=l("span"),Pa=s(" is a definite value between "),vt=l("span"),Ma=s(" and "),er=l("span"),fa=s(" instead of a superposition of values. If we now applied the current step of the algorithm to the registers, it would set "),xe=l("span"),pa=M(),kn=l("p"),En=s("But because in our case the first register is actually in a superposition of all possible values of "),Yn=l("span"),Ln=s(" after this step, the second register is also going to be in a superposition of representing "),ca=l("span"),Qe=s(" for all values of "),_a=l("span"),Sa=s(" Thus, we can write its state as "),ar=l("span"),hn=M(),da=l("h4"),rn=s("Step 4."),Pr=M(),Ie=l("p"),qa=s("Next, we measure the second register. This will make all qubits of the second register into one of the basis states randomly, and so "),rr=l("span"),Mr=s(" will take on a definite value. Furthermore, the measurement will not only modify "),ba=l("span"),qr=s(" but also "),Xr=l("span"),Ar=s(" because the qubits of the two registers are entangled. The value of "),es=l("span"),gs=s(" is a function of the value of "),Aa=l("span"),io=s(" and so if we measure a particular "),Hr=l("span"),lo=s(" the superposition of the first register can only contains those values of "),ur=l("span"),ys=s(" that are consistent with the measurement, namely for which "),mr=l("span"),$s=s(" So, although the measurement does not make the superposition of the first register disappear entirely, it filters it to the values of "),Va=l("span"),Ns=s(" that fulfil this criterion. And because "),sr=l("span"),ks=s(" is a repeating pattern with period "),or=l("span"),Es=s(" those values are going to be "),fr=l("span"),Ts=s(" apart from each other. Let the sequence "),ir=l("span"),Ps=s(" denote these values. Thus, we can write the state of the first register as "),pr=l("span"),xr=s(" where "),ss=l("span"),Ir=s(" for all "),Ba=l("span"),Yr=M(),Ca=l("h4"),Ms=s("Step 5."),Zr=M(),Tn=l("p"),Fr=s("Now, we apply the QFT to the first register. For a definite value of "),os=l("span"),La=s(" this would yield the state "),Qr=l("span"),fo=s(" But just like above, the register is in a superposition, and so the state after is going to be a linear combination of the QFT for all values of "),zr=l("span"),po=s(": "),Vr=l("span"),cr=M(),Ra=l("h4"),co=s("Step 6."),Jr=M(),Je=l("p"),Ss=s("We saw in the section on the QFT that for a given "),ja=l("span"),qs=s(" the resulting phases form a sinusoidal wave pattern with a frequency of "),Da=l("span"),As=s(" In this case, because of the superposition, the resulting phases are going to form a linear combination of sinusoidal wave patterns with frequencies "),Wa=l("span"),Hs=s(" And this is the key to the solution, because these waves are going to "),Pe(va.$$.fragment),_o=s(" with each other in a particular way. Remember that the phases generated by the QFT were complex vectors of unit length. Now, we're adding those vectors together for "),Br=l("span"),bo=s(" and so the length of the resulting vectors will no longer be "),Cr=l("span"),Os=M(),Rn=l("p"),ms=s("Instead, at certain points (values of "),Ua=l("span"),vo=s("), the waves constructively interfere, meaning their displacements sum up to a large positive or negative value, and so the measurement probabilities of those points get amplified. At other points, the displacements cancel each other out, leading to probability amplitudes near zero. If we then measure the register and read out the represented value "),_r=l("span"),Ls=s(" it's most likely going to be one of the points of constructive interference. And the points, at which this constructive interference happens are related to the period in a special way. Namely, they are the points "),dr=l("span"),xs=s(" for "),Oa=l("span"),Is=s(" Thus, all we have to do now is measure the final state of the first register a sufficient number of times to get a statistically reliable estimation of the period.")},l(k){n=h(k,"H2",{});var ge=u(n);r=o(ge,"The period-finding problem"),ge.forEach(a),i=S(k),m=h(k,"P",{});var dn=u(m);d=o(dn,"Recall the steps for computing the prime factors of a large integer "),_=h(dn,"SPAN",{});var vr=u(_);vr.forEach(a),v=o(dn," the hard part of which was finding the smallest "),b=h(dn,"SPAN",{});var ii=u(b);ii.forEach(a),w=o(dn," such that "),N=h(dn,"SPAN",{});var go=u(N);go.forEach(a),I=o(dn," It turns out that "),Y=h(dn,"SPAN",{});var cs=u(Y);cs.forEach(a),L=o(dn," is a "),Me(C.$$.fragment,dn),V=o(dn," function, and below we'll show that the number "),H=h(dn,"SPAN",{});var li=u(H);li.forEach(a),D=o(dn," we're looking for is exactly its period."),dn.forEach(a),X=S(k),A=h(k,"P",{});var en=u(A);se=o(en,"In general, the period of a function "),ee=h(en,"SPAN",{});var Ks=u(ee);Ks.forEach(a),T=o(en," is defined as the smallest positive number "),x=h(en,"SPAN",{});var yo=u(x);yo.forEach(a),R=o(en," for which "),Q=h(en,"SPAN",{});var Po=u(Q);Po.forEach(a),me=o(en," for all "),ae=h(en,"SPAN",{});var y=u(ae);y.forEach(a),le=o(en," in the domain of "),K=h(en,"SPAN",{});var te=u(K);te.forEach(a),re=o(en," (In other words, "),ce=h(en,"SPAN",{});var Fs=u(ce);Fs.forEach(a),ke=o(en," is a repeating sequence of the same pattern with length "),Ve=h(en,"SPAN",{});var ra=u(Ve);ra.forEach(a),fe=o(en,") Specifically for "),Le=h(en,"SPAN",{});var hi=u(Le);hi.forEach(a),ve=o(en," because its domain is "),Ae=h(en,"SPAN",{});var ui=u(Ae);ui.forEach(a),_t=o(en," its period has to be an integer."),en.forEach(a),ne=S(k),_e=h(k,"P",{});var bn=u(_e);st=o(bn,"Let "),je=h(bn,"SPAN",{});var mi=u(je);mi.forEach(a),W=o(bn," denote the period of "),pe=h(bn,"SPAN",{});var fi=u(pe);fi.forEach(a),ut=o(bn," We know for sure that "),Be=h(bn,"SPAN",{});var Zn=u(Be);Zn.forEach(a),mt=o(bn," from which follows that "),De=h(bn,"SPAN",{});var pi=u(De);pi.forEach(a),$t=o(bn," Thus, the "),Ye=h(bn,"SPAN",{});var ci=u(Ye);ci.forEach(a),Nt=o(bn," is the smallest positive integer, for which the value of "),et=h(bn,"SPAN",{});var _i=u(et);_i.forEach(a),Lt=o(bn," equals "),F=h(bn,"SPAN",{});var di=u(F);di.forEach(a),We=o(bn," Notice that this is exactly how we originally defined "),Et=h(bn,"SPAN",{});var bi=u(Et);bi.forEach(a),He=o(bn," and so "),bt=h(bn,"SPAN",{});var vi=u(bt);vi.forEach(a),bn.forEach(a),on=S(k),Tt=h(k,"P",{});var Qs=u(Tt);At=o(Qs,"Thus, the factoring problem can essentially be reformulated as the problem of finding the period of the function "),ue=h(Qs,"SPAN",{});var xn=u(ue);xn.forEach(a),Ue=o(Qs," for which the quantum Fourier transform turns out to be really useful."),Qs.forEach(a),Ht=S(k),oe=h(k,"H2",{});var Mo=u(oe);tt=o(Mo,"The algorithm"),Mo.forEach(a),xt=S(k),jt=h(k,"H4",{});var So=u(jt);Dt=o(So,"Step 1."),So.forEach(a),lt=S(k),Yt=h(k,"P",{});var Rr=u(Yt);Wt=o(Rr,"In order to implement Shor's algorithm, we'll need two quantum register with at least "),It=h(Rr,"SPAN",{});var wi=u(It);wi.forEach(a),Ft=o(Rr," qubits, as that is the number of digits required to represent "),un=h(Rr,"SPAN",{});var gi=u(un);gi.forEach(a),he=o(Rr," in binary notation. (In case "),ye=h(Rr,"SPAN",{});var yi=u(ye);yi.forEach(a),tn=o(Rr," is not an integer, we have to round it up.) Note that this is a lower limit, and the more qubits we use, the faster we'll find the solution."),Rr.forEach(a),Ut=S(k),Qt=h(k,"P",{});var wr=u(Qt);gn=o(wr,"Let "),Zt=h(wr,"SPAN",{});var lr=u(Zt);lr.forEach(a),yn=o(wr," denote the number of qubits we chose to construct the both registers, and "),zt=h(wr,"SPAN",{});var $i=u(zt);$i.forEach(a),mn=o(wr," the current state of the two registers. Let's ignore the second register for now, and start with all qubits of the first register being in the basis state "),de=h(wr,"SPAN",{});var Ni=u(de);Ni.forEach(a),Ot=o(wr," thus we can write its state as "),fn=h(wr,"SPAN",{});var ki=u(fn);ki.forEach(a),wr.forEach(a),Pn=S(k),Fe=h(k,"H4",{});var qo=u(Fe);In=o(qo,"Step 2."),qo.forEach(a),pn=S(k),Pt=h(k,"P",{});var at=u(Pt);Mt=o(at,"Next, we apply the so called "),Fn=h(at,"SPAN",{});var Ei=u(Fn);Ei.forEach(a),nn=o(at," (Hadamard) gate to each qubit of the first register, in order to set them into an equal superposition of the two basis states. This means the state of the register is now "),Qn=h(at,"SPAN",{});var Ti=u(Qn);Ti.forEach(a),Gt=o(at," We can factor out the "),zn=h(at,"SPAN",{});var Pi=u(zn);Pi.forEach(a),Dn=o(at," terms to obtain "),Vt=h(at,"SPAN",{});var Mi=u(Vt);Mi.forEach(a),at.forEach(a),Vn=S(k),Ze=h(k,"P",{});var Jn=u(Ze);Bn=o(Jn,"Let "),$n=h(Jn,"SPAN",{});var Si=u($n);Si.forEach(a),Cn=o(Jn," denote the number represented by the qubits of the first register (that is, the number we get if we read out the state as a sequence of binary digits). As we already saw in the case of the QFT, each qubit being in an equal superposition of the two basis states translates to the entire register being in the superposition of all combinations of these basis states, and consequently "),Nn=h(Jn,"SPAN",{});var qi=u(Nn);qi.forEach(a),_n=o(Jn," being in the superposition of all values from "),Wn=h(Jn,"SPAN",{});var Ai=u(Wn);Ai.forEach(a),we=o(Jn," to "),qn=h(Jn,"SPAN",{});var Hi=u(qn);Hi.forEach(a),ea=o(Jn," Let's express the state as the superposition of these values: "),An=h(Jn,"SPAN",{});var Li=u(An);Li.forEach(a),ta=o(Jn," Thus, if we now measure the entire register and read out "),Un=h(Jn,"SPAN",{});var xi=u(Un);xi.forEach(a),la=o(Jn," we're going to get each possible value with an equal probability of "),$e=h(Jn,"SPAN",{});var Ao=u($e);Ao.forEach(a),Jn.forEach(a),Hn=S(k),Jt=h(k,"H4",{});var zs=u(Jt);On=o(zs,"Step 3."),zs.forEach(a),ht=S(k),ot=h(k,"P",{});var vn=u(ot);ha=o(vn,"This is the point where the second register enters the picture. We begin with all qubits of this register being in the basis state "),z=h(vn,"SPAN",{});var Ho=u(z);Ho.forEach(a),Ce=o(vn," so "),ua=h(vn,"SPAN",{});var Ii=u(ua);Ii.forEach(a),Gn=o(vn," Let "),aa=h(vn,"SPAN",{});var Ys=u(aa);Ys.forEach(a),Kn=o(vn," denote the number represented by the second register, analogously to "),ma=h(vn,"SPAN",{});var Fi=u(ma);Fi.forEach(a),Xt=o(vn," Next, we apply a combination of gates to entangle the qubits of the two registers in a special way, in order to implement the function "),Ja=h(vn,"SPAN",{});var Lo=u(Ja);Lo.forEach(a),Ge=o(vn," To see what this means, let's take a step back and assume all qubits of the first register are in one particular basis state, and so "),Xa=h(vn,"SPAN",{});var Qi=u(Xa);Qi.forEach(a),Pa=o(vn," is a definite value between "),vt=h(vn,"SPAN",{});var Xe=u(vt);Xe.forEach(a),Ma=o(vn," and "),er=h(vn,"SPAN",{});var zi=u(er);zi.forEach(a),fa=o(vn," instead of a superposition of values. If we now applied the current step of the algorithm to the registers, it would set "),xe=h(vn,"SPAN",{});var Vi=u(xe);Vi.forEach(a),vn.forEach(a),pa=S(k),kn=h(k,"P",{});var gr=u(kn);En=o(gr,"But because in our case the first register is actually in a superposition of all possible values of "),Yn=h(gr,"SPAN",{});var Bi=u(Yn);Bi.forEach(a),Ln=o(gr," after this step, the second register is also going to be in a superposition of representing "),ca=h(gr,"SPAN",{});var Ci=u(ca);Ci.forEach(a),Qe=o(gr," for all values of "),_a=h(gr,"SPAN",{});var Ri=u(_a);Ri.forEach(a),Sa=o(gr," Thus, we can write its state as "),ar=h(gr,"SPAN",{});var ji=u(ar);ji.forEach(a),gr.forEach(a),hn=S(k),da=h(k,"H4",{});var xo=u(da);rn=o(xo,"Step 4."),xo.forEach(a),Pr=S(k),Ie=h(k,"P",{});var nt=u(Ie);qa=o(nt,"Next, we measure the second register. This will make all qubits of the second register into one of the basis states randomly, and so "),rr=h(nt,"SPAN",{});var Di=u(rr);Di.forEach(a),Mr=o(nt," will take on a definite value. Furthermore, the measurement will not only modify "),ba=h(nt,"SPAN",{});var Wi=u(ba);Wi.forEach(a),qr=o(nt," but also "),Xr=h(nt,"SPAN",{});var Ui=u(Xr);Ui.forEach(a),Ar=o(nt," because the qubits of the two registers are entangled. The value of "),es=h(nt,"SPAN",{});var Oi=u(es);Oi.forEach(a),gs=o(nt," is a function of the value of "),Aa=h(nt,"SPAN",{});var Gi=u(Aa);Gi.forEach(a),io=o(nt," and so if we measure a particular "),Hr=h(nt,"SPAN",{});var Ki=u(Hr);Ki.forEach(a),lo=o(nt," the superposition of the first register can only contains those values of "),ur=h(nt,"SPAN",{});var Yi=u(ur);Yi.forEach(a),ys=o(nt," that are consistent with the measurement, namely for which "),mr=h(nt,"SPAN",{});var Io=u(mr);Io.forEach(a),$s=o(nt," So, although the measurement does not make the superposition of the first register disappear entirely, it filters it to the values of "),Va=h(nt,"SPAN",{});var Fo=u(Va);Fo.forEach(a),Ns=o(nt," that fulfil this criterion. And because "),sr=h(nt,"SPAN",{});var Zi=u(sr);Zi.forEach(a),ks=o(nt," is a repeating pattern with period "),or=h(nt,"SPAN",{});var _s=u(or);_s.forEach(a),Es=o(nt," those values are going to be "),fr=h(nt,"SPAN",{});var Ji=u(fr);Ji.forEach(a),Ts=o(nt," apart from each other. Let the sequence "),ir=h(nt,"SPAN",{});var Xi=u(ir);Xi.forEach(a),Ps=o(nt," denote these values. Thus, we can write the state of the first register as "),pr=h(nt,"SPAN",{});var Zs=u(pr);Zs.forEach(a),xr=o(nt," where "),ss=h(nt,"SPAN",{});var Vs=u(ss);Vs.forEach(a),Ir=o(nt," for all "),Ba=h(nt,"SPAN",{});var el=u(Ba);el.forEach(a),nt.forEach(a),Yr=S(k),Ca=h(k,"H4",{});var Qo=u(Ca);Ms=o(Qo,"Step 5."),Qo.forEach(a),Zr=S(k),Tn=h(k,"P",{});var xa=u(Tn);Fr=o(xa,"Now, we apply the QFT to the first register. For a definite value of "),os=h(xa,"SPAN",{});var tl=u(os);tl.forEach(a),La=o(xa," this would yield the state "),Qr=h(xa,"SPAN",{});var nl=u(Qr);nl.forEach(a),fo=o(xa," But just like above, the register is in a superposition, and so the state after is going to be a linear combination of the QFT for all values of "),zr=h(xa,"SPAN",{});var zo=u(zr);zo.forEach(a),po=o(xa,": "),Vr=h(xa,"SPAN",{});var jr=u(Vr);jr.forEach(a),xa.forEach(a),cr=S(k),Ra=h(k,"H4",{});var Vo=u(Ra);co=o(Vo,"Step 6."),Vo.forEach(a),Jr=S(k),Je=h(k,"P",{});var sa=u(Je);Ss=o(sa,"We saw in the section on the QFT that for a given "),ja=h(sa,"SPAN",{});var Bo=u(ja);Bo.forEach(a),qs=o(sa," the resulting phases form a sinusoidal wave pattern with a frequency of "),Da=h(sa,"SPAN",{});var Js=u(Da);Js.forEach(a),As=o(sa," In this case, because of the superposition, the resulting phases are going to form a linear combination of sinusoidal wave patterns with frequencies "),Wa=h(sa,"SPAN",{});var Co=u(Wa);Co.forEach(a),Hs=o(sa," And this is the key to the solution, because these waves are going to "),Me(va.$$.fragment,sa),_o=o(sa," with each other in a particular way. Remember that the phases generated by the QFT were complex vectors of unit length. Now, we're adding those vectors together for "),Br=h(sa,"SPAN",{});var Ro=u(Br);Ro.forEach(a),bo=o(sa," and so the length of the resulting vectors will no longer be "),Cr=h(sa,"SPAN",{});var al=u(Cr);al.forEach(a),sa.forEach(a),Os=S(k),Rn=h(k,"P",{});var Ga=u(Rn);ms=o(Ga,"Instead, at certain points (values of "),Ua=h(Ga,"SPAN",{});var rl=u(Ua);rl.forEach(a),vo=o(Ga,"), the waves constructively interfere, meaning their displacements sum up to a large positive or negative value, and so the measurement probabilities of those points get amplified. At other points, the displacements cancel each other out, leading to probability amplitudes near zero. If we then measure the register and read out the represented value "),_r=h(Ga,"SPAN",{});var jo=u(_r);jo.forEach(a),Ls=o(Ga," it's most likely going to be one of the points of constructive interference. And the points, at which this constructive interference happens are related to the period in a special way. Namely, they are the points "),dr=h(Ga,"SPAN",{});var Do=u(dr);Do.forEach(a),xs=o(Ga," for "),Oa=h(Ga,"SPAN",{});var sl=u(Oa);sl.forEach(a),Is=o(Ga," Thus, all we have to do now is measure the final state of the first register a sufficient number of times to get a statistically reliable estimation of the period."),Ga.forEach(a)},m(k,ge){g(k,n,ge),t(n,r),g(k,i,ge),g(k,m,ge),t(m,d),t(m,_),_.innerHTML=c,t(m,v),t(m,b),b.innerHTML=E,t(m,w),t(m,N),N.innerHTML=$,t(m,I),t(m,Y),Y.innerHTML=U,t(m,L),Se(C,m,null),t(m,V),t(m,H),H.innerHTML=q,t(m,D),g(k,X,ge),g(k,A,ge),t(A,se),t(A,ee),ee.innerHTML=j,t(A,T),t(A,x),x.innerHTML=ie,t(A,R),t(A,Q),Q.innerHTML=G,t(A,me),t(A,ae),ae.innerHTML=ze,t(A,le),t(A,K),K.innerHTML=P,t(A,re),t(A,ce),ce.innerHTML=ct,t(A,ke),t(A,Ve),Ve.innerHTML=yt,t(A,fe),t(A,Le),Le.innerHTML=rt,t(A,ve),t(A,Ae),Ae.innerHTML=Ke,t(A,_t),g(k,ne,ge),g(k,_e,ge),t(_e,st),t(_e,je),je.innerHTML=sn,t(_e,W),t(_e,pe),pe.innerHTML=Z,t(_e,ut),t(_e,Be),Be.innerHTML=Ct,t(_e,mt),t(_e,De),De.innerHTML=St,t(_e,$t),t(_e,Ye),Ye.innerHTML=Kt,t(_e,Nt),t(_e,et),et.innerHTML=kt,t(_e,Lt),t(_e,F),F.innerHTML=Ee,t(_e,We),t(_e,Et),Et.innerHTML=Rt,t(_e,He),t(_e,bt),bt.innerHTML=qt,g(k,on,ge),g(k,Tt,ge),t(Tt,At),t(Tt,ue),ue.innerHTML=wn,t(Tt,Ue),g(k,Ht,ge),g(k,oe,ge),t(oe,tt),g(k,xt,ge),g(k,jt,ge),t(jt,Dt),g(k,lt,ge),g(k,Yt,ge),t(Yt,Wt),t(Yt,It),It.innerHTML=ia,t(Yt,Ft),t(Yt,un),un.innerHTML=$a,t(Yt,he),t(Yt,ye),ye.innerHTML=ft,t(Yt,tn),g(k,Ut,ge),g(k,Qt,ge),t(Qt,gn),t(Qt,Zt),Zt.innerHTML=pt,t(Qt,yn),t(Qt,zt),zt.innerHTML=Qa,t(Qt,mn),t(Qt,de),de.innerHTML=za,t(Qt,Ot),t(Qt,fn),fn.innerHTML=Xn,g(k,Pn,ge),g(k,Fe,ge),t(Fe,In),g(k,pn,ge),g(k,Pt,ge),t(Pt,Mt),t(Pt,Fn),Fn.innerHTML=Mn,t(Pt,nn),t(Pt,Qn),Qn.innerHTML=cn,t(Pt,Gt),t(Pt,zn),zn.innerHTML=Sn,t(Pt,Dn),t(Pt,Vt),Vt.innerHTML=Na,g(k,Vn,ge),g(k,Ze,ge),t(Ze,Bn),t(Ze,$n),$n.innerHTML=ln,t(Ze,Cn),t(Ze,Nn),Nn.innerHTML=ka,t(Ze,_n),t(Ze,Wn),Wn.innerHTML=Ka,t(Ze,we),t(Ze,qn),qn.innerHTML=Ea,t(Ze,ea),t(Ze,An),An.innerHTML=Ta,t(Ze,ta),t(Ze,Un),Un.innerHTML=na,t(Ze,la),t(Ze,$e),$e.innerHTML=dt,g(k,Hn,ge),g(k,Jt,ge),t(Jt,On),g(k,ht,ge),g(k,ot,ge),t(ot,ha),t(ot,z),z.innerHTML=Te,t(ot,Ce),t(ot,ua),ua.innerHTML=Ya,t(ot,Gn),t(ot,aa),aa.innerHTML=an,t(ot,Kn),t(ot,ma),ma.innerHTML=Za,t(ot,Xt),t(ot,Ja),Ja.innerHTML=Er,t(ot,Ge),t(ot,Xa),Xa.innerHTML=Ur,t(ot,Pa),t(ot,vt),vt.innerHTML=Or,t(ot,Ma),t(ot,er),er.innerHTML=Gr,t(ot,fa),t(ot,xe),xe.innerHTML=Kr,g(k,pa,ge),g(k,kn,ge),t(kn,En),t(kn,Yn),Yn.innerHTML=vs,t(kn,Ln),t(kn,ca),ca.innerHTML=tr,t(kn,Qe),t(kn,_a),_a.innerHTML=nr,t(kn,Sa),t(kn,ar),ar.innerHTML=Tr,g(k,hn,ge),g(k,da,ge),t(da,rn),g(k,Pr,ge),g(k,Ie,ge),t(Ie,qa),t(Ie,rr),rr.innerHTML=ws,t(Ie,Mr),t(Ie,ba),ba.innerHTML=Sr,t(Ie,qr),t(Ie,Xr),Xr.innerHTML=so,t(Ie,Ar),t(Ie,es),es.innerHTML=oo,t(Ie,gs),t(Ie,Aa),Aa.innerHTML=ts,t(Ie,io),t(Ie,Hr),Hr.innerHTML=ns,t(Ie,lo),t(Ie,ur),ur.innerHTML=as,t(Ie,ys),t(Ie,mr),mr.innerHTML=Ha,t(Ie,$s),t(Ie,Va),Va.innerHTML=ti,t(Ie,Ns),t(Ie,sr),sr.innerHTML=ho,t(Ie,ks),t(Ie,or),or.innerHTML=uo,t(Ie,Es),t(Ie,fr),fr.innerHTML=Lr,t(Ie,Ts),t(Ie,ir),ir.innerHTML=mo,t(Ie,Ps),t(Ie,pr),pr.innerHTML=rs,t(Ie,xr),t(Ie,ss),ss.innerHTML=Ds,t(Ie,Ir),t(Ie,Ba),Ba.innerHTML=ni,g(k,Yr,ge),g(k,Ca,ge),t(Ca,Ms),g(k,Zr,ge),g(k,Tn,ge),t(Tn,Fr),t(Tn,os),os.innerHTML=Ws,t(Tn,La),t(Tn,Qr),Qr.innerHTML=is,t(Tn,fo),t(Tn,zr),zr.innerHTML=ls,t(Tn,po),t(Tn,Vr),Vr.innerHTML=Us,g(k,cr,ge),g(k,Ra,ge),t(Ra,co),g(k,Jr,ge),g(k,Je,ge),t(Je,Ss),t(Je,ja),ja.innerHTML=ai,t(Je,qs),t(Je,Da),Da.innerHTML=ri,t(Je,As),t(Je,Wa),Wa.innerHTML=si,t(Je,Hs),Se(va,Je,null),t(Je,_o),t(Je,Br),Br.innerHTML=hs,t(Je,bo),t(Je,Cr),Cr.innerHTML=us,g(k,Os,ge),g(k,Rn,ge),t(Rn,ms),t(Rn,Ua),Ua.innerHTML=fs,t(Rn,vo),t(Rn,_r),_r.innerHTML=ps,t(Rn,Ls),t(Rn,dr),dr.innerHTML=jn,t(Rn,xs),t(Rn,Oa),Oa.innerHTML=oi,t(Rn,Is),br=!0,wo||(Gs=[p(_,"mouseenter",e[0]),p(b,"mouseenter",e[1]),p(N,"mouseenter",e[2]),p(Y,"mouseenter",e[3]),p(H,"mouseenter",e[4]),p(ee,"mouseenter",e[5]),p(x,"mouseenter",e[6]),p(Q,"mouseenter",e[7]),p(ae,"mouseenter",e[8]),p(K,"mouseenter",e[9]),p(ce,"mouseenter",e[10]),p(Ve,"mouseenter",e[11]),p(Le,"mouseenter",e[12]),p(Ae,"mouseenter",e[13]),p(je,"mouseenter",e[14]),p(pe,"mouseenter",e[15]),p(Be,"mouseenter",e[16]),p(De,"mouseenter",e[17]),p(Ye,"mouseenter",e[18]),p(et,"mouseenter",e[19]),p(F,"mouseenter",e[20]),p(Et,"mouseenter",e[21]),p(bt,"mouseenter",e[22]),p(ue,"mouseenter",e[23]),p(It,"mouseenter",e[24]),p(un,"mouseenter",e[25]),p(ye,"mouseenter",e[26]),p(Zt,"mouseenter",e[27]),p(zt,"mouseenter",e[28]),p(de,"mouseenter",e[29]),p(fn,"mouseenter",e[30]),p(Fn,"mouseenter",e[31]),p(Qn,"mouseenter",e[32]),p(zn,"mouseenter",e[33]),p(Vt,"mouseenter",e[34]),p($n,"mouseenter",e[35]),p(Nn,"mouseenter",e[36]),p(Wn,"mouseenter",e[37]),p(qn,"mouseenter",e[38]),p(An,"mouseenter",e[39]),p(Un,"mouseenter",e[40]),p($e,"mouseenter",e[41]),p(z,"mouseenter",e[42]),p(ua,"mouseenter",e[43]),p(aa,"mouseenter",e[44]),p(ma,"mouseenter",e[45]),p(Ja,"mouseenter",e[46]),p(Xa,"mouseenter",e[47]),p(vt,"mouseenter",e[48]),p(er,"mouseenter",e[49]),p(xe,"mouseenter",e[50]),p(Yn,"mouseenter",e[51]),p(ca,"mouseenter",e[52]),p(_a,"mouseenter",e[53]),p(ar,"mouseenter",e[54]),p(rr,"mouseenter",e[55]),p(ba,"mouseenter",e[56]),p(Xr,"mouseenter",e[57]),p(es,"mouseenter",e[58]),p(Aa,"mouseenter",e[59]),p(Hr,"mouseenter",e[60]),p(ur,"mouseenter",e[61]),p(mr,"mouseenter",e[62]),p(Va,"mouseenter",e[63]),p(sr,"mouseenter",e[64]),p(or,"mouseenter",e[65]),p(fr,"mouseenter",e[66]),p(ir,"mouseenter",e[67]),p(pr,"mouseenter",e[68]),p(ss,"mouseenter",e[69]),p(Ba,"mouseenter",e[70]),p(os,"mouseenter",e[71]),p(Qr,"mouseenter",e[72]),p(zr,"mouseenter",e[73]),p(Vr,"mouseenter",e[74]),p(ja,"mouseenter",e[75]),p(Da,"mouseenter",e[76]),p(Wa,"mouseenter",e[77]),p(Br,"mouseenter",e[78]),p(Cr,"mouseenter",e[79]),p(Ua,"mouseenter",e[80]),p(_r,"mouseenter",e[81]),p(dr,"mouseenter",e[82]),p(Oa,"mouseenter",e[83])],wo=!0)},p(k,ge){const dn={};ge[2]&4194304&&(dn.$$scope={dirty:ge,ctx:k}),C.$set(dn);const vr={};ge[2]&4194304&&(vr.$$scope={dirty:ge,ctx:k}),va.$set(vr)},i(k){br||(be(C.$$.fragment,k),be(va.$$.fragment,k),br=!0)},o(k){Ne(C.$$.fragment,k),Ne(va.$$.fragment,k),br=!1},d(k){k&&a(n),k&&a(i),k&&a(m),qe(C),k&&a(X),k&&a(A),k&&a(ne),k&&a(_e),k&&a(on),k&&a(Tt),k&&a(Ht),k&&a(oe),k&&a(xt),k&&a(jt),k&&a(lt),k&&a(Yt),k&&a(Ut),k&&a(Qt),k&&a(Pn),k&&a(Fe),k&&a(pn),k&&a(Pt),k&&a(Vn),k&&a(Ze),k&&a(Hn),k&&a(Jt),k&&a(ht),k&&a(ot),k&&a(pa),k&&a(kn),k&&a(hn),k&&a(da),k&&a(Pr),k&&a(Ie),k&&a(Yr),k&&a(Ca),k&&a(Zr),k&&a(Tn),k&&a(cr),k&&a(Ra),k&&a(Jr),k&&a(Je),qe(va),k&&a(Os),k&&a(Rn),wo=!1,kr(Gs)}}}function O(e){console.log(e)}function Gf(e){return[()=>O(["N"]),()=>O(["N","r"]),()=>O(["N","a","f","r"]),()=>O(["N","a","f"]),()=>O(["r"]),()=>O(["g"]),()=>O(["p"]),()=>O(["g","x","p"]),()=>O(["x"]),()=>O(["g"]),()=>O(["g"]),()=>O(["p"]),()=>O(["N","a","f"]),()=>O(["N"]),()=>O(["N","p"]),()=>O(["N","a","f"]),()=>O(["N","a","f"]),()=>O(["p","N","a","f"]),()=>O(["p"]),()=>O(["N","a","f"]),()=>O([]),()=>O(["r"]),()=>O(["p","r"]),()=>O(["N","a","f"]),()=>O(["N"]),()=>O(["N"]),()=>O(["N"]),()=>O(["n","N"]),()=>O(["\\psi"]),()=>O([]),()=>O(["m","s","\\psi","n","r","t"]),()=>O(["H"]),()=>O(["m","s","\\psi","n","r","t"]),()=>O([]),()=>O(["\\psi","n"]),()=>O(["x"]),()=>O(["x"]),()=>O([]),()=>O(["n"]),()=>O(["\\psi","x","n"]),()=>O(["x"]),()=>O(["n"]),()=>O([]),()=>O(["m","s","\\psi","n","r","t"]),()=>O(["y"]),()=>O(["x"]),()=>O(["N","x","a","f"]),()=>O(["x"]),()=>O([]),()=>O(["n"]),()=>O(["y","x","a","N"]),()=>O(["x"]),()=>O(["y","x","a","N"]),()=>O(["x"]),()=>O(["\\psi","a","n","y","x","N"]),()=>O(["y"]),()=>O(["\\psi"]),()=>O(["\\psi"]),()=>O(["y"]),()=>O(["x"]),()=>O(["y"]),()=>O(["x"]),()=>O(["y","x","a","N"]),()=>O(["x"]),()=>O(["N","a","f"]),()=>O(["p"]),()=>O(["p"]),()=>O(["x","k","n"]),()=>O(["\\psi","x","k"]),()=>O(["x","p"]),()=>O(["k"]),()=>O(["x"]),()=>O(["\\psi","x","y","n"]),()=>O(["x"]),()=>O(["\\psi","k","n","y","x"]),()=>O(["x"]),()=>O(["x"]),()=>O(["x","k"]),()=>O(["x","k"]),()=>O([]),()=>O(["x"]),()=>O(["x"]),()=>O(["p","N","j"]),()=>O(["p","j"])]}class Kf extends wa{constructor(n){super(),ga(this,n,Gf,Of,ya,{},null,[-1,-1,-1])}}function Yf(e){let n,r,i,m,d;return m=new Kf({}),{c(){n=l("h2"),r=s("Shor's Algorithm"),i=M(),Pe(m.$$.fragment)},l(_){n=h(_,"H2",{});var c=u(n);r=o(c,"Shor's Algorithm"),c.forEach(a),i=S(_),Me(m.$$.fragment,_)},m(_,c){g(_,n,c),t(n,r),g(_,i,c),Se(m,_,c),d=!0},p:js,i(_){d||(be(m.$$.fragment,_),d=!0)},o(_){Ne(m.$$.fragment,_),d=!1},d(_){_&&a(n),_&&a(i),qe(m,_)}}}class Zf extends wa{constructor(n){super(),ga(this,n,null,Yf,ya,{})}}function Jf(e){let n,r,i,m,d,_,c,v,b,E,w,N,$,I,Y,U,L,C,V,H;return $=new Eu({}),Y=new Rf({}),L=new jm({}),V=new Zf({}),{c(){n=l("div"),r=M(),i=l("main"),m=l("h1"),d=s("Interactive Quantum Computing"),_=M(),c=l("p"),v=s("This page intends to introduce concepts, connect them and derive a practical use case"),b=M(),E=l("h2"),w=s("Clickable Table of Contents"),N=M(),Pe($.$$.fragment),I=M(),Pe(Y.$$.fragment),U=M(),Pe(L.$$.fragment),C=M(),Pe(V.$$.fragment),this.h()},l(q){n=h(q,"DIV",{class:!0}),u(n).forEach(a),r=S(q),i=h(q,"MAIN",{});var D=u(i);m=h(D,"H1",{});var X=u(m);d=o(X,"Interactive Quantum Computing"),X.forEach(a),_=S(D),c=h(D,"P",{});var A=u(c);v=o(A,"This page intends to introduce concepts, connect them and derive a practical use case"),A.forEach(a),b=S(D),E=h(D,"H2",{});var se=u(E);w=o(se,"Clickable Table of Contents"),se.forEach(a),N=S(D),Me($.$$.fragment,D),I=S(D),Me(Y.$$.fragment,D),U=S(D),Me(L.$$.fragment,D),C=S(D),Me(V.$$.fragment,D),D.forEach(a),this.h()},h(){B(n,"class","sidebar")},m(q,D){g(q,n,D),g(q,r,D),g(q,i,D),t(i,m),t(m,d),t(i,_),t(i,c),t(c,v),t(i,b),t(i,E),t(E,w),t(i,N),Se($,i,null),t(i,I),Se(Y,i,null),t(i,U),Se(L,i,null),t(i,C),Se(V,i,null),H=!0},p:js,i(q){H||(be($.$$.fragment,q),be(Y.$$.fragment,q),be(L.$$.fragment,q),be(V.$$.fragment,q),H=!0)},o(q){Ne($.$$.fragment,q),Ne(Y.$$.fragment,q),Ne(L.$$.fragment,q),Ne(V.$$.fragment,q),H=!1},d(q){q&&a(n),q&&a(r),q&&a(i),qe($),qe(Y),qe(L),qe(V)}}}const tp=!0;class np extends wa{constructor(n){super(),ga(this,n,null,Jf,ya,{})}}export{np as default,tp as prerender};
