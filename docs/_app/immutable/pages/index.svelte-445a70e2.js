import{S as rn,i as sn,s as on,l as h,u as i,a as q,L as et,e as kr,m as u,p as f,v as l,h as r,c as H,M as tt,q as V,b as y,H as n,N as en,O as w,P as $h,Q as na,R as kh,n as Ia,T as jn,F as Nh,I as Eh,J as Th,K as Mh,f as fe,t as be,U as wi,V as Ph,x as ge,y as ye,z as $e,C as ke,W as ka,X as Na,g as Sh,d as Ah,Y as Go,w as ko,Z as Uo,r as xh}from"../chunks/index-760eefc7.js";import{m as d,g as Qr,a as ms,p as Oo,e as qh,b as Hh,c as fo,i as Lh,Q as Ih}from"../chunks/Qbit-e7529a99.js";function Fh(e){let t,a,s,o=d(`K = ${e[6]}`)+"",c,p,m=d("r")+"",b,_,N=d("a^r \\mod N = 1")+"",v,k,$,A,G,j=d("r")+"",P,C,F=d(`${e[1]}^{${e[2]}} \\mod ${e[0]} = 1`)+"",S,z,M=d("m")+"",Z,K,Q=d(`${e[1]}^{${e[2]}} = m \\cdot ${e[0]} + 1`)+"",ee,I;function E(R,L){return R[2]%2==0?Ch:Vh}let x=E(e),ne=x(e);return{c(){t=h("p"),a=i("As "),s=new et(!1),c=i(", the value of "),p=new et(!1),b=i(" in "),_=new et(!1),v=i(` will
		be informative.`),k=q(),$=h("p"),A=i(`As these are all relatively small numbers, we can try all relevant possible values for
		`),G=new et(!1),P=i(" rather quickly and find that "),C=new et(!1),S=i(` which means
		that there is an `),z=new et(!1),Z=i(" for which "),K=new et(!1),ee=q(),I=h("p"),ne.c(),this.h()},l(R){t=u(R,"P",{});var L=f(t);a=l(L,"As "),s=tt(L,!1),c=l(L,", the value of "),p=tt(L,!1),b=l(L," in "),_=tt(L,!1),v=l(L,` will
		be informative.`),L.forEach(r),k=H(R),$=u(R,"P",{});var D=f($);A=l(D,`As these are all relatively small numbers, we can try all relevant possible values for
		`),G=tt(D,!1),P=l(D," rather quickly and find that "),C=tt(D,!1),S=l(D,` which means
		that there is an `),z=tt(D,!1),Z=l(D," for which "),K=tt(D,!1),D.forEach(r),ee=H(R),I=u(R,"P",{});var oe=f(I);ne.l(oe),oe.forEach(r),this.h()},h(){s.a=c,p.a=b,_.a=v,G.a=P,C.a=S,z.a=Z,K.a=null},m(R,L){y(R,t,L),n(t,a),s.m(o,t),n(t,c),p.m(m,t),n(t,b),_.m(N,t),n(t,v),y(R,k,L),y(R,$,L),n($,A),G.m(j,$),n($,P),C.m(F,$),n($,S),z.m(M,$),n($,Z),K.m(Q,$),y(R,ee,L),y(R,I,L),ne.m(I,null)},p(R,L){L&64&&o!==(o=d(`K = ${R[6]}`)+"")&&s.p(o),L&7&&F!==(F=d(`${R[1]}^{${R[2]}} \\mod ${R[0]} = 1`)+"")&&C.p(F),L&7&&Q!==(Q=d(`${R[1]}^{${R[2]}} = m \\cdot ${R[0]} + 1`)+"")&&K.p(Q),x===(x=E(R))&&ne?ne.p(R,L):(ne.d(1),ne=x(R),ne&&(ne.c(),ne.m(I,null)))},d(R){R&&r(t),R&&r(k),R&&r($),R&&r(ee),R&&r(I),ne.d()}}}function zh(e){let t,a,s,o=d("K \\neq 1")+"",c,p,m=d("a")+"",b,_,N=d("N")+"",v,k,$=d(`K=${e[6]}`)+"",A,G,j=d("a")+"",P;return{c(){t=h("p"),a=i("As in this case "),s=new et(!1),c=i(", a new "),p=new et(!1),b=i(` is needed. Or to put a more positive
		spin on it, we instantly can found a prime factor for `),_=new et(!1),v=i(`, which in fact
		`),k=new et(!1),A=i(` is. However, in order to see the whole algorithm in action, we should choose
		a new `),G=new et(!1),P=i("."),this.h()},l(C){t=u(C,"P",{});var F=f(t);a=l(F,"As in this case "),s=tt(F,!1),c=l(F,", a new "),p=tt(F,!1),b=l(F,` is needed. Or to put a more positive
		spin on it, we instantly can found a prime factor for `),_=tt(F,!1),v=l(F,`, which in fact
		`),k=tt(F,!1),A=l(F,` is. However, in order to see the whole algorithm in action, we should choose
		a new `),G=tt(F,!1),P=l(F,"."),F.forEach(r),this.h()},h(){s.a=c,p.a=b,_.a=v,k.a=A,G.a=P},m(C,F){y(C,t,F),n(t,a),s.m(o,t),n(t,c),p.m(m,t),n(t,b),_.m(N,t),n(t,v),k.m($,t),n(t,A),G.m(j,t),n(t,P)},p(C,F){F&64&&$!==($=d(`K=${C[6]}`)+"")&&k.p($)},d(C){C&&r(t)}}}function Vh(e){let t,a=d("r")+"",s,o,c=d("a")+"",p;return{c(){t=new et(!1),s=i(" is odd, we need a new "),o=new et(!1),p=i("."),this.h()},l(m){t=tt(m,!1),s=l(m," is odd, we need a new "),o=tt(m,!1),p=l(m,"."),this.h()},h(){t.a=s,o.a=p},m(m,b){t.m(a,m,b),y(m,s,b),o.m(c,m,b),y(m,p,b)},p:Ia,d(m){m&&t.d(),m&&r(s),m&&o.d(),m&&r(p)}}}function Ch(e){let t,a=d("r")+"",s,o,c=d("b = a^{\\frac{r}{2}}")+"",p,m,b=d("a^r = m \\cdot N + 1 \\Rightarrow b^2-1 = (b + 1)(b - 1) = m \\cdot N")+"",_,N,v=d(`b = ${e[5]}`)+"",k,$,A=d("N")+"",G,j,P=d("b-1")+"",C,F,S=d("b+1")+"",z,M,Z=d(`${Qr(e[0],e[5]-1)}`)+"",K,Q,ee=d(`${Qr(e[0],e[5]+1)}`)+"",I;return{c(){t=new et(!1),s=i(" is even, so we can create "),o=new et(!1),p=i(`, and expand
			the above so that
			`),m=new et(!1),_=i(`. In this
			case, as `),N=new et(!1),k=i(`, we can calculate the greatest common divisor for
			`),$=new et(!1),G=i(" with "),j=new et(!1),C=i(" and "),F=new et(!1),z=i(` very quickly, which are
			`),M=new et(!1),K=i(" and "),Q=new et(!1),I=i(" respectively"),this.h()},l(E){t=tt(E,!1),s=l(E," is even, so we can create "),o=tt(E,!1),p=l(E,`, and expand
			the above so that
			`),m=tt(E,!1),_=l(E,`. In this
			case, as `),N=tt(E,!1),k=l(E,`, we can calculate the greatest common divisor for
			`),$=tt(E,!1),G=l(E," with "),j=tt(E,!1),C=l(E," and "),F=tt(E,!1),z=l(E,` very quickly, which are
			`),M=tt(E,!1),K=l(E," and "),Q=tt(E,!1),I=l(E," respectively"),this.h()},h(){t.a=s,o.a=p,m.a=_,N.a=k,$.a=G,j.a=C,F.a=z,M.a=K,Q.a=I},m(E,x){t.m(a,E,x),y(E,s,x),o.m(c,E,x),y(E,p,x),m.m(b,E,x),y(E,_,x),N.m(v,E,x),y(E,k,x),$.m(A,E,x),y(E,G,x),j.m(P,E,x),y(E,C,x),F.m(S,E,x),y(E,z,x),M.m(Z,E,x),y(E,K,x),Q.m(ee,E,x),y(E,I,x)},p(E,x){x&32&&v!==(v=d(`b = ${E[5]}`)+"")&&N.p(v),x&33&&Z!==(Z=d(`${Qr(E[0],E[5]-1)}`)+"")&&M.p(Z),x&33&&ee!==(ee=d(`${Qr(E[0],E[5]+1)}`)+"")&&Q.p(ee)},d(E){E&&t.d(),E&&r(s),E&&o.d(),E&&r(p),E&&m.d(),E&&r(_),E&&N.d(),E&&r(k),E&&$.d(),E&&r(G),E&&j.d(),E&&r(C),E&&F.d(),E&&r(z),E&&M.d(),E&&r(K),E&&Q.d(),E&&r(I)}}}function Bh(e){let t,a,s,o,c,p,m,b,_,N,v,k,$,A,G,j,P,C=d(` = ${e[3]} \\cdot ${e[4]}`)+"",F,S,z,M,Z=d(`a = ${e[1]}`)+"",K,Q,ee=d(`N = ${e[0]}`)+"",I,E,x=d(`K = ${e[6]}`)+"",ne,R,L,D,oe;function te(W,T){return W[6]!=1?zh:Fh}let Pe=te(e),ae=Pe(e);return{c(){t=h("div"),a=h("div"),s=i("a:"),o=q(),c=h("input"),m=q(),b=h("input"),N=q(),v=h("div"),k=i("N:"),$=q(),A=h("input"),j=q(),P=h("div"),F=q(),S=h("p"),z=i("The greatest common divisor of "),M=new et(!1),K=i(" and "),Q=new et(!1),I=i(` is
	`),E=new et(!1),ne=i(". This is very quick to calculate."),R=q(),ae.c(),L=kr(),this.h()},l(W){t=u(W,"DIV",{class:!0});var T=f(t);a=u(T,"DIV",{class:!0});var U=f(a);s=l(U,"a:"),U.forEach(r),o=H(T),c=u(T,"INPUT",{class:!0,type:!0,min:!0,max:!0}),m=H(T),b=u(T,"INPUT",{class:!0,type:!0,min:!0,max:!0}),N=H(T),v=u(T,"DIV",{class:!0});var J=f(v);k=l(J,"N:"),J.forEach(r),$=H(T),A=u(T,"INPUT",{class:!0,type:!0,min:!0,max:!0}),j=H(T),P=u(T,"DIV",{id:!0,class:!0});var Se=f(P);Se.forEach(r),T.forEach(r),F=H(W),S=u(W,"P",{});var Ne=f(S);z=l(Ne,"The greatest common divisor of "),M=tt(Ne,!1),K=l(Ne," and "),Q=tt(Ne,!1),I=l(Ne,` is
	`),E=tt(Ne,!1),ne=l(Ne,". This is very quick to calculate."),Ne.forEach(r),R=H(W),ae.l(W),L=kr(),this.h()},h(){V(a,"class","varlabel svelte-1lqus27"),V(c,"class","numsel svelte-1lqus27"),V(c,"type","number"),V(c,"min",2),V(c,"max",p=e[0]-1),V(b,"class","slider svelte-1lqus27"),V(b,"type","range"),V(b,"min",2),V(b,"max",_=e[0]-1),V(v,"class","varlabel svelte-1lqus27"),V(A,"class","numsel svelte-1lqus27"),V(A,"type","number"),V(A,"min","1"),V(A,"max",e[7]),V(P,"id","decomp"),V(P,"class","svelte-1lqus27"),V(t,"class","cpanel svelte-1lqus27"),M.a=K,Q.a=I,E.a=ne},m(W,T){y(W,t,T),n(t,a),n(a,s),n(t,o),n(t,c),en(c,e[1]),n(t,m),n(t,b),en(b,e[1]),n(t,N),n(t,v),n(v,k),n(t,$),n(t,A),en(A,e[0]),n(t,j),n(t,P),P.innerHTML=C,y(W,F,T),y(W,S,T),n(S,z),M.m(Z,S),n(S,K),Q.m(ee,S),n(S,I),E.m(x,S),n(S,ne),y(W,R,T),ae.m(W,T),y(W,L,T),D||(oe=[w(c,"input",e[10]),w(b,"change",e[11]),w(b,"input",e[11]),$h(G=e[8].call(null,A,e[0])),w(A,"input",e[12])],D=!0)},p(W,[T]){T&1&&p!==(p=W[0]-1)&&V(c,"max",p),T&2&&na(c.value)!==W[1]&&en(c,W[1]),T&1&&_!==(_=W[0]-1)&&V(b,"max",_),T&2&&en(b,W[1]),G&&kh(G.update)&&T&1&&G.update.call(null,W[0]),T&1&&na(A.value)!==W[0]&&en(A,W[0]),T&24&&C!==(C=d(` = ${W[3]} \\cdot ${W[4]}`)+"")&&(P.innerHTML=C),T&2&&Z!==(Z=d(`a = ${W[1]}`)+"")&&M.p(Z),T&1&&ee!==(ee=d(`N = ${W[0]}`)+"")&&Q.p(ee),T&64&&x!==(x=d(`K = ${W[6]}`)+"")&&E.p(x),Pe===(Pe=te(W))&&ae?ae.p(W,T):(ae.d(1),ae=Pe(W),ae&&(ae.c(),ae.m(L.parentNode,L)))},i:Ia,o:Ia,d(W){W&&r(t),W&&r(F),W&&r(S),W&&r(R),ae.d(W),W&&r(L),D=!1,jn(oe)}}}function Rh(e,t){for(let a=1;a<t;a++){let s=e%t;for(let o=1;o<a;o++)s=s*e%t;if(s==1)return a}return 0}function Qh(e,t,a){let s,o,c,{bits:p=7}=t,m=Math.pow(2,p)-1;const b=new Set;for(let S=2;S<=m/2;S++){let z=!0;b.forEach(function(M){S%M==0&&(z=!1)}),z&&b.add(S)}let _=39,N=_,v=7,k,$;function A(S){for(const z of b)if(b.has(S/z))return a(3,k=z),a(4,$=S/z),!0;return!1}A(_);function G(S,z){return{update(M){let Z=M-N;if(Z!=0){for(;!A(M);)if(M+=Z,M<=2||M>=m)return;j(M)}}}}function j(S){a(0,_=S),N=_,a(1,v=v>=_?_-1:v)}function P(){v=na(this.value),a(1,v)}function C(){v=na(this.value),a(1,v)}function F(){_=na(this.value),a(0,_)}return e.$$set=S=>{"bits"in S&&a(9,p=S.bits)},e.$$.update=()=>{e.$$.dirty&3&&a(2,s=Rh(v,_)),e.$$.dirty&3&&a(6,o=Qr(_,v)),e.$$.dirty&6&&a(5,c=Math.pow(v,s/2))},[_,v,s,k,$,c,o,m,G,p,P,C,F]}class jh extends rn{constructor(t){super(),sn(this,t,Qh,Bh,on,{bits:9})}}function Dh(e){return e<.5?4*e*e*e:.5*Math.pow(2*e-2,3)+1}function Wh(e){const t=e-1;return t*t*t+1}function Gh(e){return--e*e*e*e*e+1}function Uh(e,{delay:t=0,duration:a=400,easing:s=Wh,start:o=0,opacity:c=0}={}){const p=getComputedStyle(e),m=+p.opacity,b=p.transform==="none"?"":p.transform,_=1-o,N=m*(1-c);return{delay:t,duration:a,easing:s,css:(v,k)=>`
			transform: ${b} scale(${1-_*k});
			opacity: ${m-N*k}
		`}}function Ko(e,{delay:t=0,speed:a,duration:s,easing:o=Dh}={}){let c=e.getTotalLength();const p=getComputedStyle(e);return p.strokeLinecap!=="butt"&&(c+=parseInt(p.strokeWidth)),s===void 0?a===void 0?s=800:s=c/a:typeof s=="function"&&(s=s(c)),{delay:t,duration:s,easing:o,css:(m,b)=>`stroke-dasharray: ${m*c} ${b*c}`}}function Zo(e){let t,a;return{c(){t=h("div"),this.h()},l(s){t=u(s,"DIV",{class:!0});var o=f(t);o.forEach(r),this.h()},h(){V(t,"class","hover-inner svelte-5qv8za")},m(s,o){y(s,t,o),t.innerHTML=e[0]},p(s,o){e=s,o&1&&(t.innerHTML=e[0])},i(s){a||wi(()=>{a=Ph(t,Uh,{duration:150,easing:Gh,opacity:0}),a.start()})},o:Ia,d(s){s&&r(t)}}}function Oh(e){let t,a,s,o;const c=e[5].default,p=Nh(c,e,e[4],null);let m=e[1]&&Zo(e);return{c(){t=h("span"),p&&p.c(),m&&m.c(),this.h()},l(b){t=u(b,"SPAN",{class:!0});var _=f(t);p&&p.l(_),m&&m.l(_),_.forEach(r),this.h()},h(){V(t,"class","hover-outer svelte-5qv8za")},m(b,_){y(b,t,_),p&&p.m(t,null),m&&m.m(t,null),a=!0,s||(o=[w(t,"mouseenter",e[2]),w(t,"mouseleave",e[3])],s=!0)},p(b,[_]){p&&p.p&&(!a||_&16)&&Eh(p,c,b,b[4],a?Mh(c,b[4],_,null):Th(b[4]),null),b[1]?m?(m.p(b,_),_&2&&fe(m,1)):(m=Zo(b),m.c(),fe(m,1),m.m(t,null)):m&&(m.d(1),m=null)},i(b){a||(fe(p,b),fe(m),a=!0)},o(b){be(p,b),a=!1},d(b){b&&r(t),p&&p.d(b),m&&m.d(),s=!1,jn(o)}}}function Kh(e,t,a){let{$$slots:s={},$$scope:o}=t,{hovertext:c}=t,p=!1;const m=()=>a(1,p=!0),b=()=>a(1,p=!1);return e.$$set=_=>{"hovertext"in _&&a(0,c=_.hovertext),"$$scope"in _&&a(4,o=_.$$scope)},[c,p,m,b,o,s]}class at extends rn{constructor(t){super(),sn(this,t,Kh,Oh,on,{hovertext:0})}}const Zh=`<a href="https://en.wikipedia.org/wiki/Semiprime"><h3 class="text-lg font-semibold">Semiprime</h3></a><p>In mathematics, a <b>semiprime</b> is a natural number that is the product of exactly two prime numbers. The two primes in the product may equal each other, so the semiprimes include the squares of prime numbers.
Because there are infinitely many prime numbers, there are also infinitely many semiprimes. Semiprimes are also called <b>biprimes</b>.</p>`,Yh='<a href="https://en.wikipedia.org/wiki/General_number_field_sieve"><h3>General number field sieve</h3></a><p>In number theory, the <b>general number field sieve</b> (<b>GNFS</b>) is the most efficient classical algorithm known for factoring integers larger than <span class="texhtml ">10<sup>100</sup></span>. Heuristically, its complexity for factoring an integer <span class="texhtml mvar" style="font-style:italic">n</span> (consisting of <span class="texhtml ">\u230Alog<sub>2</sub> <span class="texhtml mvar" style="font-style:italic">n</span>\u230B + 1</span> bits) is of the form</p><dl><dd><span class="mwe-math-element"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/fcc5450b9f039008c0a728e15b6c66f24dafbb30" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align:-2.505ex;width:57.324ex;height:6.343ex" /></span></dd></dl>',Jh='<a href="https://en.wikipedia.org/wiki/Exponential_function"><h3>Exponential function</h3></a><p>The <b>exponential function</b> is a mathematical function denoted by <span class="mwe-math-element"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/9dd9b17af32bc3cffe927507c7bccf4e2a96f585" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align:-0.838ex;width:14.207ex;height:2.843ex" /></span> or <span class="mwe-math-element"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/841c0d168e64191c45a45e54c7e447defd17ec6a" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align:-0.338ex;width:2.256ex;height:2.343ex" /></span>. Unless otherwise specified, the term generally refers to the positive-valued function of a real variable, although it can be extended to the complex numbers or generalized to other mathematical objects like matrices or Lie algebras. The exponential function originated from the notion of exponentiation, but modern definitions allow it to be rigorously extended to all real arguments, including irrational numbers. Its ubiquitous occurrence in pure and applied mathematics led mathematician Walter Rudin to opine that the exponential function is "the most important function in mathematics".</p>',Xh='<a href="https://en.wikipedia.org/wiki/Quantum_computing"><h3>Quantum computing</h3></a><p><b>Quantum computing</b> is a type of computation whose operations can harness the phenomena of quantum mechanics, such as superposition, interference, and entanglement. Devices that perform quantum computations are known as <b>quantum computers</b>. Though current quantum computers are too small to outperform usual (classical) computers for practical applications, larger realizations are believed to be capable of solving certain computational problems, such as integer factorization, substantially faster than classical computers. The study of quantum computing is a subfield of quantum information science.</p>',eu=`<a href="https://en.wikipedia.org/wiki/Cubic_function"><h3>Cubic function</h3></a><p>In mathematics, a <b>cubic function</b> is a function of the form <span class="mwe-math-element"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/9cc573924b3e958061c7436c149efc76e4098668" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align:-0.838ex;width:26.585ex;height:3.176ex" /></span>
where the coefficients <span class="texhtml mvar" style="font-style:italic">a</span>, <span class="texhtml mvar" style="font-style:italic">b</span>, <span class="texhtml mvar" style="font-style:italic">c</span>, and <span class="texhtml mvar" style="font-style:italic">d</span> are complex numbers, and the variable <span class="texhtml mvar" style="font-style:italic">x</span> takes real values, and <span class="mwe-math-element"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f455a7f96d74aa94573d8e32da3b240ab0aa294f" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align:-0.838ex;width:5.491ex;height:2.676ex" /></span>. In other words, it is both a polynomial function of degree three, and a real function. In particular, the domain and the codomain are the set of the real numbers.</p>`,tu='<a href="https://en.wikipedia.org/wiki/Computational_complexity"><h3 class="text-lg font-semibold">Computational complexity</h3></a><p>In computer science, the <b>computational complexity</b> or simply <b>complexity</b> of an algorithm is the amount of resources required to run it. Particular focus is given to time and memory requirements. The complexity of a problem is the complexity of the best algorithms that allow solving the problem.</p>',nu=`<a href="https://en.wikipedia.org/wiki/Linear_function"><h3>Linear function</h3></a><p>In mathematics, the term <b>linear function</b> refers to two distinct but related notions:</p><ul><li>In calculus and related areas, a linear function is a function whose graph is a straight line, that is, a polynomial function of degree zero or one. For distinguishing such a linear function from the other concept, the term affine function is often used.</li>
<li>In linear algebra, mathematical analysis, and functional analysis, a linear function is a linear map.</li></ul>`;function au(e){let t;return{c(){t=i("semiprime")},l(a){t=l(a,"semiprime")},m(a,s){y(a,t,s)},d(a){a&&r(t)}}}function ru(e){let t;return{c(){t=i("number field sieve")},l(a){t=l(a,"number field sieve")},m(a,s){y(a,t,s)},d(a){a&&r(t)}}}function su(e){let t;return{c(){t=i("exponentially")},l(a){t=l(a,"exponentially")},m(a,s){y(a,t,s)},d(a){a&&r(t)}}}function ou(e){let t;return{c(){t=i("quantum computer")},l(a){t=l(a,"quantum computer")},m(a,s){y(a,t,s)},d(a){a&&r(t)}}}function iu(e){let t;return{c(){t=i("cubically")},l(a){t=l(a,"cubically")},m(a,s){y(a,t,s)},d(a){a&&r(t)}}}function lu(e){let t;return{c(){t=i("Computational complexity")},l(a){t=l(a,"Computational complexity")},m(a,s){y(a,t,s)},d(a){a&&r(t)}}}function hu(e){let t;return{c(){t=i("linearly")},l(a){t=l(a,"linearly")},m(a,s){y(a,t,s)},d(a){a&&r(t)}}}function uu(e){let t,a,s,o,c,p,m=d("p, q \\in \\mathbb{P}")+"",b,_,N,v,k=d("N \\in \\mathbb{N}")+"",$,A,G=d("N = p \\cdot q")+"",j,P,C=d("15")+"",F,S,z=d("3")+"",M,Z,K=d("5")+"",Q,ee,I=d("62615533")+"",E,x,ne,R,L,D,oe,te,Pe,ae,W=d("^3")+"",T,U,J=d("100")+"",Se,Ne,Le=d("3")+"",Ie,Ae,Re=d("200")+"",Ce,rt,Qe=d("5")+"",Ee,gt,Te,We,he,Ge,dt,we,ht,de;return _=new at({props:{hovertext:Zh,$$slots:{default:[au]},$$scope:{ctx:e}}}),x=new at({props:{hovertext:Yh,$$slots:{default:[ru]},$$scope:{ctx:e}}}),R=new at({props:{hovertext:Jh,$$slots:{default:[su]},$$scope:{ctx:e}}}),D=new at({props:{hovertext:Xh,$$slots:{default:[ou]},$$scope:{ctx:e}}}),te=new at({props:{hovertext:eu,$$slots:{default:[iu]},$$scope:{ctx:e}}}),We=new at({props:{hovertext:tu,$$slots:{default:[lu]},$$scope:{ctx:e}}}),Ge=new at({props:{hovertext:nu,$$slots:{default:[hu]},$$scope:{ctx:e}}}),{c(){t=h("h2"),a=i("Description of the problem"),s=q(),o=h("p"),c=i("We would like to find the prime factors "),p=h("span"),b=i(" of a large "),ge(_.$$.fragment),N=q(),v=h("span"),$=i(" (so that "),A=h("span"),j=i("). Finding these factors for a small number, such as "),P=h("span"),F=i(", is quite easy. In fact, you may figure it out just by looking at it and recalling your grade school studies: the factors are "),S=h("span"),M=i(" and "),Z=h("span"),Q=i(". But what are the prime factors of, say, "),ee=h("span"),E=i("? It turns out that, using the best known classical (meaning non-quantum) algorithm (the so called "),ge(x.$$.fragment),ne=i("), solving the factoring problem scales "),ge(R.$$.fragment),L=i(" with the number of digits of the semiprime that we want to factor. With the help of Shor's algorithm and a sufficiently large "),ge(D.$$.fragment),oe=i(", the same problem scales roughly "),ge(te.$$.fragment),Pe=i(" with the number of digits, meaning that the number of elementary operations required is proportional to (the number of digits)"),ae=h("span"),T=i(". (In fact, the algorithm does slightly better than that, but the precise formula is a bit complicated and is beside the point.) To illustrate what this means in practical terms, imagine the following. If factoring a "),U=h("span"),Se=i("-digit number with Shor's algorithm on a quantum computer takes one second, factoring the same number with the number field sieve on a classical computer takes more than "),Ne=h("span"),Ie=i(" hours. If we now try with a "),Ae=h("span"),Ce=i("-digit number, Shor's algorithm finishes in roughly "),rt=h("span"),Ee=i(" seconds, while the classical solution would take more than a year!"),gt=q(),Te=h("p"),ge(We.$$.fragment),he=i(` refers to how the time - or number of elementary operations - required to solve a given problem algorithmically grows with the size of the input. Let's say you have to find the longest book you have ever read. One way to approach this problem is to list the books you have read one by one, label the first one as the longest, and whenever you encounter an even longer book, it takes the place of the former. This way, you only have to keep track of the largest page number so far, and the book associated with it. The "elementary operation" in this case is checking the number of pages of the next book and comparing that with the previous maximum. If you have twice or three times as many books, this procedure requires twice or three times as many elementary operations. In other words, it grows `),ge(Ge.$$.fragment),dt=i(" in the number of books. So, while the solution can be found using the same algorithm, the number of elementary operations required to carry out that algorithm depends on the size of the input. This is true for almost all algorithms that are designed to solve mathematical problems. However, how fast that growth is, makes all the difference between them.")},l(re){t=u(re,"H2",{});var _e=f(t);a=l(_e,"Description of the problem"),_e.forEach(r),s=H(re),o=u(re,"P",{});var X=f(o);c=l(X,"We would like to find the prime factors "),p=u(X,"SPAN",{});var _t=f(p);_t.forEach(r),b=l(X," of a large "),ye(_.$$.fragment,X),N=H(X),v=u(X,"SPAN",{});var st=f(v);st.forEach(r),$=l(X," (so that "),A=u(X,"SPAN",{});var Ue=f(A);Ue.forEach(r),j=l(X,"). Finding these factors for a small number, such as "),P=u(X,"SPAN",{});var bt=f(P);bt.forEach(r),F=l(X,", is quite easy. In fact, you may figure it out just by looking at it and recalling your grade school studies: the factors are "),S=u(X,"SPAN",{});var ot=f(S);ot.forEach(r),M=l(X," and "),Z=u(X,"SPAN",{});var Je=f(Z);Je.forEach(r),Q=l(X,". But what are the prime factors of, say, "),ee=u(X,"SPAN",{});var At=f(ee);At.forEach(r),E=l(X,"? It turns out that, using the best known classical (meaning non-quantum) algorithm (the so called "),ye(x.$$.fragment,X),ne=l(X,"), solving the factoring problem scales "),ye(R.$$.fragment,X),L=l(X," with the number of digits of the semiprime that we want to factor. With the help of Shor's algorithm and a sufficiently large "),ye(D.$$.fragment,X),oe=l(X,", the same problem scales roughly "),ye(te.$$.fragment,X),Pe=l(X," with the number of digits, meaning that the number of elementary operations required is proportional to (the number of digits)"),ae=u(X,"SPAN",{});var ie=f(ae);ie.forEach(r),T=l(X,". (In fact, the algorithm does slightly better than that, but the precise formula is a bit complicated and is beside the point.) To illustrate what this means in practical terms, imagine the following. If factoring a "),U=u(X,"SPAN",{});var ze=f(U);ze.forEach(r),Se=l(X,"-digit number with Shor's algorithm on a quantum computer takes one second, factoring the same number with the number field sieve on a classical computer takes more than "),Ne=u(X,"SPAN",{});var le=f(Ne);le.forEach(r),Ie=l(X," hours. If we now try with a "),Ae=u(X,"SPAN",{});var Nt=f(Ae);Nt.forEach(r),Ce=l(X,"-digit number, Shor's algorithm finishes in roughly "),rt=u(X,"SPAN",{});var vt=f(rt);vt.forEach(r),Ee=l(X," seconds, while the classical solution would take more than a year!"),X.forEach(r),gt=H(re),Te=u(re,"P",{});var Et=f(Te);ye(We.$$.fragment,Et),he=l(Et,` refers to how the time - or number of elementary operations - required to solve a given problem algorithmically grows with the size of the input. Let's say you have to find the longest book you have ever read. One way to approach this problem is to list the books you have read one by one, label the first one as the longest, and whenever you encounter an even longer book, it takes the place of the former. This way, you only have to keep track of the largest page number so far, and the book associated with it. The "elementary operation" in this case is checking the number of pages of the next book and comparing that with the previous maximum. If you have twice or three times as many books, this procedure requires twice or three times as many elementary operations. In other words, it grows `),ye(Ge.$$.fragment,Et),dt=l(Et," in the number of books. So, while the solution can be found using the same algorithm, the number of elementary operations required to carry out that algorithm depends on the size of the input. This is true for almost all algorithms that are designed to solve mathematical problems. However, how fast that growth is, makes all the difference between them."),Et.forEach(r)},m(re,_e){y(re,t,_e),n(t,a),y(re,s,_e),y(re,o,_e),n(o,c),n(o,p),p.innerHTML=m,n(o,b),$e(_,o,null),n(o,N),n(o,v),v.innerHTML=k,n(o,$),n(o,A),A.innerHTML=G,n(o,j),n(o,P),P.innerHTML=C,n(o,F),n(o,S),S.innerHTML=z,n(o,M),n(o,Z),Z.innerHTML=K,n(o,Q),n(o,ee),ee.innerHTML=I,n(o,E),$e(x,o,null),n(o,ne),$e(R,o,null),n(o,L),$e(D,o,null),n(o,oe),$e(te,o,null),n(o,Pe),n(o,ae),ae.innerHTML=W,n(o,T),n(o,U),U.innerHTML=J,n(o,Se),n(o,Ne),Ne.innerHTML=Le,n(o,Ie),n(o,Ae),Ae.innerHTML=Re,n(o,Ce),n(o,rt),rt.innerHTML=Qe,n(o,Ee),y(re,gt,_e),y(re,Te,_e),$e(We,Te,null),n(Te,he),$e(Ge,Te,null),n(Te,dt),we=!0,ht||(de=[w(p,"mouseenter",e[0]),w(v,"mouseenter",e[1]),w(A,"mouseenter",e[2]),w(P,"mouseenter",e[3]),w(S,"mouseenter",e[4]),w(Z,"mouseenter",e[5]),w(ee,"mouseenter",e[6]),w(ae,"mouseenter",e[7]),w(U,"mouseenter",e[8]),w(Ne,"mouseenter",e[9]),w(Ae,"mouseenter",e[10]),w(rt,"mouseenter",e[11])],ht=!0)},p(re,[_e]){const X={};_e&4096&&(X.$$scope={dirty:_e,ctx:re}),_.$set(X);const _t={};_e&4096&&(_t.$$scope={dirty:_e,ctx:re}),x.$set(_t);const st={};_e&4096&&(st.$$scope={dirty:_e,ctx:re}),R.$set(st);const Ue={};_e&4096&&(Ue.$$scope={dirty:_e,ctx:re}),D.$set(Ue);const bt={};_e&4096&&(bt.$$scope={dirty:_e,ctx:re}),te.$set(bt);const ot={};_e&4096&&(ot.$$scope={dirty:_e,ctx:re}),We.$set(ot);const Je={};_e&4096&&(Je.$$scope={dirty:_e,ctx:re}),Ge.$set(Je)},i(re){we||(fe(_.$$.fragment,re),fe(x.$$.fragment,re),fe(R.$$.fragment,re),fe(D.$$.fragment,re),fe(te.$$.fragment,re),fe(We.$$.fragment,re),fe(Ge.$$.fragment,re),we=!0)},o(re){be(_.$$.fragment,re),be(x.$$.fragment,re),be(R.$$.fragment,re),be(D.$$.fragment,re),be(te.$$.fragment,re),be(We.$$.fragment,re),be(Ge.$$.fragment,re),we=!1},d(re){re&&r(t),re&&r(s),re&&r(o),ke(_),ke(x),ke(R),ke(D),ke(te),re&&r(gt),re&&r(Te),ke(We),ke(Ge),ht=!1,jn(de)}}}function Hn(e){console.log(e)}function fu(e){return[()=>Hn(["q","P","p"]),()=>Hn(["N"]),()=>Hn(["q","p","N"]),()=>Hn([]),()=>Hn([]),()=>Hn([]),()=>Hn([]),()=>Hn([]),()=>Hn([]),()=>Hn([]),()=>Hn([]),()=>Hn([])]}class mu extends rn{constructor(t){super(),sn(this,t,fu,uu,on,{})}}const pu='<a href="https://en.wikipedia.org/wiki/Greatest_common_divisor"><h3>Greatest common divisor</h3></a><p>In mathematics, the <b>greatest common divisor</b> (<b>GCD</b>) of two or more integers, which are not all zero, is the largest positive integer that divides each of the integers. For two integers <i>x</i>, <i>y</i>, the greatest common divisor of <i>x</i> and <i>y</i> is denoted <span class="mwe-math-element"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/24c083a217bb5e2d3468e683c957f220a683e4d8" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align:-0.838ex;width:8.816ex;height:2.843ex" /></span>. For example, the GCD of 8 and 12 is 4, that is, <span class="mwe-math-element"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/cabed257e6ea789ef3febd9add3a7f3ef2237361" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align:-0.838ex;width:14.079ex;height:2.843ex" /></span>.</p>',cu=`<a href="https://en.wikipedia.org/wiki/Euclidean_algorithm"><h3>Euclidean algorithm</h3></a><p>In mathematics, the <b>Euclidean algorithm</b>, or <b>Euclid's algorithm</b>, is an efficient method for computing the greatest common divisor (GCD) of two integers (numbers), the largest number that divides them both without a remainder. It is named after the ancient Greek mathematician Euclid, who first described it in <span>his <i>Elements</i></span> .
It is an example of an <i>algorithm</i>, a step-by-step procedure for performing a calculation according to well-defined rules,
and is one of the oldest algorithms in common use. It can be used to reduce fractions to their simplest form, and is a part of many other number-theoretic and cryptographic calculations.</p>`;function du(e){let t;return{c(){t=i("greatest common divisor")},l(a){t=l(a,"greatest common divisor")},m(a,s){y(a,t,s)},d(a){a&&r(t)}}}function _u(e){let t;return{c(){t=i("Euclid's algorithm")},l(a){t=l(a,"Euclid's algorithm")},m(a,s){y(a,t,s)},d(a){a&&r(t)}}}function bu(e){let t,a,s,o,c,p,m,b,_,N,v,k=d("a \\in \\mathbb{N}, 1 < a < N")+"",$,A,G=d("a")+"",j,P,C=d("N")+"",F,S,z=d("\\gcd(a, N) = 1")+"",M,Z,K=d("\\gcd")+"",Q,ee,I,E,x=d("a")+"",ne,R,L=d("N")+"",D,oe,te=d("N")+"",Pe,ae,W,T,U,J,Se=d("f(r): \\mathbb{N} \\rightarrow \\mathbb{N} = a^r \\mod N")+"",Ne,Le,Ie=d("0 < \\hat{r} < N")+"",Ae,Re,Ce=d("f(\\hat{r}) = 1")+"",rt,Qe,Ee=d("\\hat{r}")+"",gt,Te,We=d("a")+"",he,Ge,dt,we,ht,de,re=d("\\hat{r}")+"",_e,X,_t=d("\\hat{r}")+"",st,Ue,bt=d("m \\in \\mathbb{N}")+"",ot,Je,At=d("a^{\\hat{r}} = m \\cdot N + 1")+"",ie,ze,le=d("b = a^{\\frac{\\hat{r}}{2}}")+"",Nt,vt,Et=d("b^2 = (a^{\\frac{\\hat{r}}{2}})^2 = a^{\\hat{r}}")+"",Oe,Tt,Kt=d("b^2 - 1 = (b + 1)(b - 1)")+"",Vt,yt,Ct=d("(b + 1)(b - 1) = m \\cdot N")+"",Mt,dn,$t,Xe,xt,wt,Ye=d("\\gcd(a^{\\frac{r}{2} - 1}, N)")+"",nt,ut,Me=d("\\gcd(a^{\\frac{r}{2} + 1}, N)")+"",Pt,ft,_n,kt,It,bn,mt,Zt,ln,Dt,Ve,se,Be,Ze=d("\\hat{r}")+"",$n,Ft,qt=d("1")+"",ra,Yt,qe=d("N")+"",Ln,Wt,me=d("N")+"",In,Gt,hn,Dn;return ee=new at({props:{hovertext:pu,$$slots:{default:[du]},$$scope:{ctx:e}}}),ft=new at({props:{hovertext:cu,$$slots:{default:[_u]},$$scope:{ctx:e}}}),{c(){t=h("h2"),a=i("Solution"),s=q(),o=h("p"),c=i("The factoring problem can be solved with the following simple, but very time-consuming algorithm:"),p=q(),m=h("ol"),b=h("li"),_=h("p"),N=i("We pick a random number "),v=h("span"),$=i(" and make sure that "),A=h("span"),j=i(" and "),P=h("span"),F=i(" are relative primes, meaning "),S=h("span"),M=i(", where "),Z=h("span"),Q=i(" stands for "),ge(ee.$$.fragment),I=i(". (In case "),E=h("span"),ne=i(" happens to be a factor of "),R=h("span"),D=i(", the entire problem is solved and no further steps are required, but that is highly unlikely if "),oe=h("span"),Pe=i(" is large.)"),ae=q(),W=h("li"),T=h("p"),U=i("Next, we construct the function "),J=h("span"),Ne=i(" and find the smallest integer "),Le=h("span"),Ae=i(" such that "),Re=h("span"),rt=i(". If "),Qe=h("span"),gt=i(" turns out to be odd, we unfortunately have to repeat the entire procedure with a different "),Te=h("span"),he=i(" parameter."),Ge=q(),dt=h("li"),we=h("p"),ht=i("If we're lucky and "),de=h("span"),_e=i(" is even, we can proceed. From the definition of "),X=h("span"),st=i(" follows that there's "),Ue=h("span"),ot=i(" such that "),Je=h("span"),ie=i(". We can then define the integer "),ze=h("span"),Nt=i(", which means "),vt=h("span"),Oe=i(". Also, we can make use of a well-known algebraic identity to write "),Tt=h("span"),Vt=i(". Putting together these three equations, we find that "),yt=h("span"),Mt=i("."),dn=q(),$t=h("li"),Xe=h("p"),xt=i("And then we're done, because the prime factors we're looking for are "),wt=h("span"),nt=i(" and "),ut=h("span"),Pt=i(", and these are very easy to compute with the help of "),ge(ft.$$.fragment),_n=i("."),kt=q(),It=h("p"),bn=i("For a more illuminating explanation, see the video "),mt=h("a"),Zt=i("Hacking at Quantum Speed with Shor's Algorithm"),ln=i(" by PBS Infinite Series."),Dt=q(),Ve=h("p"),se=i("The problem with this solution is that in order to find "),Be=h("span"),$n=i(", we might have to check all possible values between "),Ft=h("span"),ra=i(" and "),Yt=h("span"),Ln=i(" one after the other, which is an insane amount of computation if "),Wt=h("span"),In=i(" is number with several hundreds of digits. But that's only the case if we're trying with a classical computer."),this.h()},l(ue){t=u(ue,"H2",{});var pt=f(t);a=l(pt,"Solution"),pt.forEach(r),s=H(ue),o=u(ue,"P",{});var Bt=f(o);c=l(Bt,"The factoring problem can be solved with the following simple, but very time-consuming algorithm:"),Bt.forEach(r),p=H(ue),m=u(ue,"OL",{});var pe=f(m);b=u(pe,"LI",{});var vn=f(b);_=u(vn,"P",{});var He=f(_);N=l(He,"We pick a random number "),v=u(He,"SPAN",{});var Fn=f(v);Fn.forEach(r),$=l(He," and make sure that "),A=u(He,"SPAN",{});var Ut=f(A);Ut.forEach(r),j=l(He," and "),P=u(He,"SPAN",{});var Ea=f(P);Ea.forEach(r),F=l(He," are relative primes, meaning "),S=u(He,"SPAN",{});var zn=f(S);zn.forEach(r),M=l(He,", where "),Z=u(He,"SPAN",{});var tn=f(Z);tn.forEach(r),Q=l(He," stands for "),ye(ee.$$.fragment,He),I=l(He,". (In case "),E=u(He,"SPAN",{});var kn=f(E);kn.forEach(r),ne=l(He," happens to be a factor of "),R=u(He,"SPAN",{});var un=f(R);un.forEach(r),D=l(He,", the entire problem is solved and no further steps are required, but that is highly unlikely if "),oe=u(He,"SPAN",{});var St=f(oe);St.forEach(r),Pe=l(He," is large.)"),He.forEach(r),vn.forEach(r),ae=H(pe),W=u(pe,"LI",{});var Vn=f(W);T=u(Vn,"P",{});var it=f(T);U=l(it,"Next, we construct the function "),J=u(it,"SPAN",{});var Nn=f(J);Nn.forEach(r),Ne=l(it," and find the smallest integer "),Le=u(it,"SPAN",{});var Wn=f(Le);Wn.forEach(r),Ae=l(it," such that "),Re=u(it,"SPAN",{});var Ta=f(Re);Ta.forEach(r),rt=l(it,". If "),Qe=u(it,"SPAN",{});var En=f(Qe);En.forEach(r),gt=l(it," turns out to be odd, we unfortunately have to repeat the entire procedure with a different "),Te=u(it,"SPAN",{});var oa=f(Te);oa.forEach(r),he=l(it," parameter."),it.forEach(r),Vn.forEach(r),Ge=H(pe),dt=u(pe,"LI",{});var wn=f(dt);we=u(wn,"P",{});var Ke=f(we);ht=l(Ke,"If we're lucky and "),de=u(Ke,"SPAN",{});var Mr=f(de);Mr.forEach(r),_e=l(Ke," is even, we can proceed. From the definition of "),X=u(Ke,"SPAN",{});var Gn=f(X);Gn.forEach(r),st=l(Ke," follows that there's "),Ue=u(Ke,"SPAN",{});var ce=f(Ue);ce.forEach(r),ot=l(Ke," such that "),Je=u(Ke,"SPAN",{});var Ma=f(Je);Ma.forEach(r),ie=l(Ke,". We can then define the integer "),ze=u(Ke,"SPAN",{});var Tn=f(ze);Tn.forEach(r),Nt=l(Ke,", which means "),vt=u(Ke,"SPAN",{});var Un=f(vt);Un.forEach(r),Oe=l(Ke,". Also, we can make use of a well-known algebraic identity to write "),Tt=u(Ke,"SPAN",{});var Pa=f(Tt);Pa.forEach(r),Vt=l(Ke,". Putting together these three equations, we find that "),yt=u(Ke,"SPAN",{});var Mn=f(yt);Mn.forEach(r),Mt=l(Ke,"."),Ke.forEach(r),wn.forEach(r),dn=H(pe),$t=u(pe,"LI",{});var Cn=f($t);Xe=u(Cn,"P",{});var fn=f(Xe);xt=l(fn,"And then we're done, because the prime factors we're looking for are "),wt=u(fn,"SPAN",{});var Pn=f(wt);Pn.forEach(r),nt=l(fn," and "),ut=u(fn,"SPAN",{});var On=f(ut);On.forEach(r),Pt=l(fn,", and these are very easy to compute with the help of "),ye(ft.$$.fragment,fn),_n=l(fn,"."),fn.forEach(r),Cn.forEach(r),pe.forEach(r),kt=H(ue),It=u(ue,"P",{});var Kn=f(It);bn=l(Kn,"For a more illuminating explanation, see the video "),mt=u(Kn,"A",{href:!0});var gn=f(mt);Zt=l(gn,"Hacking at Quantum Speed with Shor's Algorithm"),gn.forEach(r),ln=l(Kn," by PBS Infinite Series."),Kn.forEach(r),Dt=H(ue),Ve=u(ue,"P",{});var zt=f(Ve);se=l(zt,"The problem with this solution is that in order to find "),Be=u(zt,"SPAN",{});var Sa=f(Be);Sa.forEach(r),$n=l(zt,", we might have to check all possible values between "),Ft=u(zt,"SPAN",{});var Sn=f(Ft);Sn.forEach(r),ra=l(zt," and "),Yt=u(zt,"SPAN",{});var Zn=f(Yt);Zn.forEach(r),Ln=l(zt," one after the other, which is an insane amount of computation if "),Wt=u(zt,"SPAN",{});var Aa=f(Wt);Aa.forEach(r),In=l(zt," is number with several hundreds of digits. But that's only the case if we're trying with a classical computer."),zt.forEach(r),this.h()},h(){V(mt,"href","https://www.youtube.com/watch?v=wUwZZaI5u0c&t=731s")},m(ue,pt){y(ue,t,pt),n(t,a),y(ue,s,pt),y(ue,o,pt),n(o,c),y(ue,p,pt),y(ue,m,pt),n(m,b),n(b,_),n(_,N),n(_,v),v.innerHTML=k,n(_,$),n(_,A),A.innerHTML=G,n(_,j),n(_,P),P.innerHTML=C,n(_,F),n(_,S),S.innerHTML=z,n(_,M),n(_,Z),Z.innerHTML=K,n(_,Q),$e(ee,_,null),n(_,I),n(_,E),E.innerHTML=x,n(_,ne),n(_,R),R.innerHTML=L,n(_,D),n(_,oe),oe.innerHTML=te,n(_,Pe),n(m,ae),n(m,W),n(W,T),n(T,U),n(T,J),J.innerHTML=Se,n(T,Ne),n(T,Le),Le.innerHTML=Ie,n(T,Ae),n(T,Re),Re.innerHTML=Ce,n(T,rt),n(T,Qe),Qe.innerHTML=Ee,n(T,gt),n(T,Te),Te.innerHTML=We,n(T,he),n(m,Ge),n(m,dt),n(dt,we),n(we,ht),n(we,de),de.innerHTML=re,n(we,_e),n(we,X),X.innerHTML=_t,n(we,st),n(we,Ue),Ue.innerHTML=bt,n(we,ot),n(we,Je),Je.innerHTML=At,n(we,ie),n(we,ze),ze.innerHTML=le,n(we,Nt),n(we,vt),vt.innerHTML=Et,n(we,Oe),n(we,Tt),Tt.innerHTML=Kt,n(we,Vt),n(we,yt),yt.innerHTML=Ct,n(we,Mt),n(m,dn),n(m,$t),n($t,Xe),n(Xe,xt),n(Xe,wt),wt.innerHTML=Ye,n(Xe,nt),n(Xe,ut),ut.innerHTML=Me,n(Xe,Pt),$e(ft,Xe,null),n(Xe,_n),y(ue,kt,pt),y(ue,It,pt),n(It,bn),n(It,mt),n(mt,Zt),n(It,ln),y(ue,Dt,pt),y(ue,Ve,pt),n(Ve,se),n(Ve,Be),Be.innerHTML=Ze,n(Ve,$n),n(Ve,Ft),Ft.innerHTML=qt,n(Ve,ra),n(Ve,Yt),Yt.innerHTML=qe,n(Ve,Ln),n(Ve,Wt),Wt.innerHTML=me,n(Ve,In),Gt=!0,hn||(Dn=[w(v,"mouseenter",e[0]),w(A,"mouseenter",e[1]),w(P,"mouseenter",e[2]),w(S,"mouseenter",e[3]),w(Z,"mouseenter",e[4]),w(E,"mouseenter",e[5]),w(R,"mouseenter",e[6]),w(oe,"mouseenter",e[7]),w(J,"mouseenter",e[8]),w(Le,"mouseenter",e[9]),w(Re,"mouseenter",e[10]),w(Qe,"mouseenter",e[11]),w(Te,"mouseenter",e[12]),w(de,"mouseenter",e[13]),w(X,"mouseenter",e[14]),w(Ue,"mouseenter",e[15]),w(Je,"mouseenter",e[16]),w(ze,"mouseenter",e[17]),w(vt,"mouseenter",e[18]),w(Tt,"mouseenter",e[19]),w(yt,"mouseenter",e[20]),w(wt,"mouseenter",e[21]),w(ut,"mouseenter",e[22]),w(Be,"mouseenter",e[23]),w(Ft,"mouseenter",e[24]),w(Yt,"mouseenter",e[25]),w(Wt,"mouseenter",e[26])],hn=!0)},p(ue,[pt]){const Bt={};pt&134217728&&(Bt.$$scope={dirty:pt,ctx:ue}),ee.$set(Bt);const pe={};pt&134217728&&(pe.$$scope={dirty:pt,ctx:ue}),ft.$set(pe)},i(ue){Gt||(fe(ee.$$.fragment,ue),fe(ft.$$.fragment,ue),Gt=!0)},o(ue){be(ee.$$.fragment,ue),be(ft.$$.fragment,ue),Gt=!1},d(ue){ue&&r(t),ue&&r(s),ue&&r(o),ue&&r(p),ue&&r(m),ke(ee),ke(ft),ue&&r(kt),ue&&r(It),ue&&r(Dt),ue&&r(Ve),hn=!1,jn(Dn)}}}function lt(e){console.log(e)}function vu(e){return[()=>lt(["a","N"]),()=>lt(["a"]),()=>lt(["N"]),()=>lt(["a","N"]),()=>lt([]),()=>lt(["a"]),()=>lt(["N"]),()=>lt(["N"]),()=>lt(["N","a","f","r"]),()=>lt(["N","r"]),()=>lt(["f","r"]),()=>lt(["r"]),()=>lt(["a"]),()=>lt(["r"]),()=>lt(["r"]),()=>lt(["m","N"]),()=>lt(["a","m","r","N"]),()=>lt(["a","b","r"]),()=>lt(["a","b","r"]),()=>lt(["b"]),()=>lt(["m","b","N"]),()=>lt(["a","r","N"]),()=>lt(["a","r","N"]),()=>lt(["r"]),()=>lt([]),()=>lt(["N"]),()=>lt(["N"])]}class wu extends rn{constructor(t){super(),sn(this,t,vu,bu,on,{})}}function gu(e){let t,a,s,o,c,p,m,b,_,N;return o=new mu({}),p=new wu({}),_=new jh({}),{c(){t=h("h2"),a=i("Factoring"),s=q(),ge(o.$$.fragment),c=q(),ge(p.$$.fragment),m=q(),b=h("div"),ge(_.$$.fragment),this.h()},l(v){t=u(v,"H2",{});var k=f(t);a=l(k,"Factoring"),k.forEach(r),s=H(v),ye(o.$$.fragment,v),c=H(v),ye(p.$$.fragment,v),m=H(v),b=u(v,"DIV",{class:!0});var $=f(b);ye(_.$$.fragment,$),$.forEach(r),this.h()},h(){V(b,"class","interaction")},m(v,k){y(v,t,k),n(t,a),y(v,s,k),$e(o,v,k),y(v,c,k),$e(p,v,k),y(v,m,k),y(v,b,k),$e(_,b,null),N=!0},p:Ia,i(v){N||(fe(o.$$.fragment,v),fe(p.$$.fragment,v),fe(_.$$.fragment,v),N=!0)},o(v){be(o.$$.fragment,v),be(p.$$.fragment,v),be(_.$$.fragment,v),N=!1},d(v){v&&r(t),v&&r(s),ke(o,v),v&&r(c),ke(p,v),v&&r(m),v&&r(b),ke(_)}}}class yu extends rn{constructor(t){super(),sn(this,t,null,gu,on,{})}}const $u='<a href="https://en.wikipedia.org/wiki/Binary_number"><h3>Binary number</h3></a><p>A <b>binary number</b> is a number expressed in the <b>base-2 numeral system</b> or <b>binary numeral system</b>, a method of mathematical expression which uses only two symbols: typically "0" (zero) and "1" (one).</p>',ku=`<a href="https://en.wikipedia.org/wiki/Quantum_Fourier_transform"><h3>Quantum Fourier transform</h3></a><p>In quantum computing, the <b>quantum Fourier transform (QFT)</b> is a linear transformation on quantum bits, and is the quantum analogue of the discrete Fourier transform. The quantum Fourier transform is a part of many quantum algorithms, notably Shor's algorithm for factoring and computing the discrete logarithm, the quantum phase estimation algorithm for estimating the eigenvalues of a unitary operator, and algorithms for the hidden subgroup problem. The quantum Fourier transform was discovered by Don Coppersmith.</p>`;function Nu(e){let t;return{c(){t=i("binary representations")},l(a){t=l(a,"binary representations")},m(a,s){y(a,t,s)},d(a){a&&r(t)}}}function Eu(e){let t;return{c(){t=i("quantum Fourier transform")},l(a){t=l(a,"quantum Fourier transform")},m(a,s){y(a,t,s)},d(a){a&&r(t)}}}function Tu(e){let t,a,s,o,c,p,m,b,_,N=d("n")+"",v,k,$=d("|0\\rangle")+"",A,G,j=d("|1\\rangle")+"",P,C,F=d("\\underbrace{2 \\cdot \\ldots \\cdot 2}_\\text{n times} = 2^n")+"",S,z,M=d("N := 2^n")+"",Z,K,Q,ee,I,E,x,ne=d("0")+"",R,L,D=d("N - 1")+"",oe,te,Pe=d("n = 5")+"",ae,W,T=d("|0\\rangle \\otimes |1\\rangle \\otimes |0\\rangle \\otimes |0\\rangle \\otimes |1\\rangle")+"",U,J,Se=d("01001")+"",Ne,Le,Ie=d("\\small 0 \\cdot 2^4 + 1 \\cdot 2^3 + 0 \\cdot 2^2 + 0 \\cdot 2^1 + 1 \\cdot 2^0 = 0 + 8 + 0 + 0 + 1 = 9")+"",Ae,Re,Ce,rt,Qe,Ee,gt,Te,We,he,Ge=d("x")+"",dt,we,ht=d("x = 9")+"",de,re,_e=d("k")+"",X,_t,st=d("\\frac{1}{\\sqrt{2}} \\left( |0\\rangle + e^{\\frac{2 \\pi i x}{2^k}} |1\\rangle \\right)")+"",Ue,bt,ot=d("\\alpha_k = \\frac{1}{\\sqrt{2}}")+"",Je,At,ie=d("\\beta_k = \\frac{1}{\\sqrt{2}} e^{\\frac{2 \\pi i x}{2^k}}")+"",ze,le,Nt=d("k = 1, ..., n")+"",vt,Et,Oe,Tt,Kt,Vt=d("\\alpha_k \\neq \\beta_k")+"",yt,Ct,Mt=d("\\Vert{\\alpha_k}\\Vert^2 = \\Vert{\\beta_k}\\Vert^2 = \\frac{1}{2}")+"",dn,$t,Xe=d("k = 1, ..., n")+"",xt,wt,Ye=d("e^{\\frac{2 \\pi i x}{2^k}}")+"",nt,ut,Me,Pt,ft,_n=d("|0\\rangle")+"",kt,It,bn=d("|1\\rangle")+"",mt,Zt,ln=d("n")+"",Dt,Ve,se=d("n")+"",Be,Ze,$n=d("0")+"",Ft,qt,ra=d("N - 1")+"",Yt,qe,Ln=d("\\frac{1}{2}")+"",Wt,me,In=d("n")+"",Gt,hn,Dn=d("\\underbrace{\\frac{1}{2} \\cdot \\ldots \\cdot \\frac{1}{2}}_\\text{n terms} = \\frac{1}{2^n} = \\frac{1}{N}")+"",ue,pt,Bt,pe,vn,He,Fn,Ut,Ea=d("|\\psi\\rangle")+"",zn,tn,kn,un,St=d("|\\psi\\rangle = \\underbrace{ \\frac{1}{\\sqrt{2}} \\left( |0\\rangle + e^{ \\frac{2 \\pi i x}{2^1} } |1\\rangle \\right) \\otimes \\ldots \\otimes \\frac{1}{\\sqrt{2}} \\left( |0\\rangle + e^{ \\frac{2 \\pi i x}{2^n} } |1\\rangle \\right) }_\\text{n terms}")+"",Vn,it,Nn,Wn,Ta=d("\\frac{1}{\\sqrt{2}}")+"",En,oa,wn,Ke,Mr=d("|\\psi\\rangle = \\frac{1}{\\sqrt{2^n}} \\left(\\left( |0\\rangle + e^{\\frac{2 \\pi i x}{2^1}} |1\\rangle \\right) \\otimes \\ldots \\otimes \\left( |0\\rangle + e^{\\frac{2 \\pi i x}{2^n}} |1\\rangle \\right) \\right) = \\frac{1}{\\sqrt{N}} \\left(\\left( |0\\rangle + e^{\\frac{2 \\pi i x}{2^1}} |1\\rangle \\right) \\otimes \\ldots \\otimes \\left( |0\\rangle + e^{\\frac{2 \\pi i x}{2^n}} |1\\rangle \\right) \\right)")+"",Gn,ce,Ma,Tn,Un=d("y")+"",Pa,Mn,Cn=d("n")+"",fn,Pn,On=d("y_k")+"",Kn,gn,zt=d("k")+"",Sa,Sn,Zn=d("y")+"",Aa,Yn,Fa=d("y_k = 0")+"",xa,sa,B=d("k")+"",ve,je,za=d("|0\\rangle")+"",ia,Bn,Va=d("y_k = 1")+"",la,Rn,Ca=d("|1\\rangle")+"",ha,Rt,$s=d("k = 1, \\ldots, n")+"",Pr,nn,ks=d("y")+"",Sr,ua,Ht=d("\\displaystyle{ y = \\sum_{k=1}^n y_k \\cdot 2^{n - k}}")+"",Ar,fa,Ns=d("2^n")+"",xr,ma,Es=d("k")+"",qr,pa,Ur=d("\\displaystyle{ y = 2^n \\cdot \\sum_{k=1}^n y_k \\cdot 2^{-k} = N \\cdot \\sum_{k=1}^n \\frac{y_k}{2^k}}")+"",mn,Ba,ca,yn,Ra,da,xe,Ts=d("|\\psi\\rangle = \\displaystyle{ \\frac{1}{\\sqrt{N}} \\underbrace{ \\sum_{y_1=0}^1 \\ldots \\sum_{y_{n}=0}^1}_\\text{n terms} \\overbrace{e^{\\frac{2 \\pi i x y_1}{2^1}} |y_1\\rangle \\otimes \\ldots \\otimes e^{\\frac{2 \\pi i x y_n}{2^n}}|y_n\\rangle}^\\text{n terms} }")+"",Qa,An,Hr,_a,Ms=d("k")+"",Lr,ba,Ps=d("e^{\\frac{2 \\pi i x y_k}{2^k}}|y_k\\rangle")+"",Ir,ja,Jn,Xn,va,Ai=d("e^{\\frac{2 \\pi i x \\cdot 0}{2^k}}|0\\rangle = 1 \\cdot |0\\rangle = |0\\rangle")+"",Ss,Da,xi=d("y_k = 0")+"",As,xs,wa,Wa,qi=d("e^{\\frac{2 \\pi i x \\cdot 1}{2^k}}|1\\rangle = e^{\\frac{2 \\pi i x }{2^k}}|1\\rangle")+"",qs,Ga,Hi=d("y_k = 1")+"",Hs,Or,Ua,Ls,Kr,xn,Is,Oa,Li=d("n")+"",Fs,Fr,zs,Vs,zr,Cs,Bs,Zr,ga,Rs,Vr,Qs,js,Yr,Ka,Za,Ii=d("|\\psi\\rangle = \\displaystyle{ \\frac{1}{\\sqrt{N}} \\sum_{y_1=0}^1 \\ldots \\sum_{y_{n}=0}^1 \\left( e^{\\frac{2 \\pi i x y_1}{2^1}} \\cdot \\ldots \\cdot e^{\\frac{2 \\pi i x y_n}{2^n}} \\right) \\left( |y_1\\rangle \\otimes \\ldots \\otimes |y_n\\rangle \\right)}")+"",Jr,Ya,Ja,Fi=d("|\\psi\\rangle = \\displaystyle{ = \\frac{1}{\\sqrt{N}} \\sum_{y_1=0}^1 \\ldots \\sum_{y_{n}=0}^1 \\prod_{k=1}^n e^{\\frac{2 \\pi i x y_k}{2^k}} \\left( |y_1\\rangle \\otimes \\ldots \\otimes |y_n\\rangle \\right)}")+"",Xr,Xa,Ds,es,er,tr,zi=d("|\\psi\\rangle = \\displaystyle{ = \\frac{1}{\\sqrt{N}} \\sum_{y_1=0}^1 \\ldots \\sum_{y_{n}=0}^1 e^{\\sum_{k=1}^n \\frac{2 \\pi i x y_k}{2^k}} \\left( |y_1\\rangle \\otimes \\ldots \\otimes |y_n\\rangle \\right)}")+"",ts,ea,Ws,nr,Vi=d("2 \\pi i x")+"",Gs,ar,Ci=d("k")+"",Us,ns,rr,sr,Bi=d("|\\psi\\rangle = \\displaystyle{ = \\frac{1}{\\sqrt{N}} \\sum_{y_1=0}^1 \\ldots \\sum_{y_{n}=0}^1 e^{2 \\pi i x \\sum_{k=1}^n \\frac{y_k}{2^k}} \\left( |y_1\\rangle \\otimes \\ldots \\otimes |y_n\\rangle \\right)}")+"",as,Qt,Os,or,Ri=d("\\displaystyle{ \\sum_{k=1}^n \\frac{y_k}{2^k}}")+"",Ks,ir,Qi=d("\\frac{y}{N}")+"",Zs,lr,ji=d("y_k")+"",Ys,hr,Di=d("y")+"",Js,ur,Wi=d("y")+"",Xs,fr,Gi=d("|y\\rangle = |y_1\\rangle \\otimes \\ldots \\otimes |y_n\\rangle")+"",eo,rs,mr,pr,Ui=d("|\\psi\\rangle = \\displaystyle{ \\frac{1}{\\sqrt{N}} \\sum_{y=0}^{N - 1} e^{\\frac{2 \\pi i x y}{N}} |y\\rangle}")+"",ss,cr,to,os,Jt,no,dr,Oi=d("x")+"",ao,_r,Ki=d("e^{\\frac{2 \\pi i x y}{N}}")+"",ro,br,Zi=d("y")+"",so,vr,Yi=d("x")+"",oo,wr,Ji=d("x")+"",io,is,lo,Po;return I=new at({props:{hovertext:$u,$$slots:{default:[Nu]},$$scope:{ctx:e}}}),Te=new at({props:{hovertext:ku,$$slots:{default:[Eu]},$$scope:{ctx:e}}}),{c(){t=h("h2"),a=i("Quantum Fourier transform (QFT)"),s=q(),o=h("h2"),c=i("Representing numbers with qubits"),p=q(),m=h("p"),b=i("Consider "),_=h("span"),v=i(" qubits aranged in a row, each of which are in either of the two basis states "),k=h("span"),A=i(" or "),G=h("span"),P=i(". With a little combinatorics, we can see that there are "),C=h("span"),S=i(" such combinations. For ease of notation, let "),z=h("span"),Z=i("."),K=q(),Q=h("p"),ee=i("For our purposes, we'll interpret these combinations as the "),ge(I.$$.fragment),E=i(" of the numbers from "),x=h("span"),R=i(" to "),L=h("span"),oe=i(". For example, let "),te=h("span"),ae=i(" and the qubits be in the following state: "),W=h("span"),U=i('. We can "read out" this state as the binary number '),J=h("span"),Ne=i(", which is equal to "),Le=h("span"),Ae=i("."),Re=q(),Ce=h("h2"),rt=i("QFT on the qubit level"),Qe=q(),Ee=h("p"),gt=i("The "),ge(Te.$$.fragment),We=i(" is an operation that modifies the states of qubits in a particular way. (How this is done in practice is another topic, for now we'll only look at the mathematics.) Namely, if "),he=h("span"),dt=i(" is the number represented by the qubits (in the example above, "),we=h("span"),de=i("), the QFT sets the state of the "),re=h("span"),X=i("-th qubit to "),_t=h("span"),Ue=i(". In other words, it sets "),bt=h("span"),Je=i(" and "),At=h("span"),ze=i(" for all "),le=h("span"),vt=i("."),Et=q(),Oe=h("p"),Tt=i("Notice that even though "),Kt=h("span"),yt=i(", the associated measurement probabilities "),Ct=h("span"),dn=i(" for all "),$t=h("span"),xt=i(". This is because the "),wt=h("span"),nt=i(" term - as we saw in the section about the Bloch-sphere - indicates the qubit's phase and does not affect measurement probabilities."),ut=q(),Me=h("p"),Pt=i("Just like the state of a single qubit can be the linear combination of "),ft=h("span"),kt=i(" and "),It=h("span"),mt=i(", the state of these "),Zt=h("span"),Dt=i(" qubits is essentially the linear combination of all the possible combinations of the "),Ve=h("span"),Be=i(" basis states - which, as we saw in the previous section, represent the integers from "),Ze=h("span"),Ft=i(" to "),qt=h("span"),Yt=i(". Since both basis states are measured with a probability of "),qe=h("span"),Wt=i(" for each qubit, one particular combination of the "),me=h("span"),Gt=i(" basis states is measured with a probability of "),hn=h("span"),ue=i(". What differs across these combinations is the phase, as we'll see in the next section."),pt=q(),Bt=h("h2"),pe=i("QFT on the representation level"),vn=q(),He=h("p"),Fn=i("Let's denote the state of the entire sequence of qubits with "),Ut=h("span"),zn=i(" and write it out as shown below:"),tn=q(),kn=h("p"),un=h("span"),Vn=q(),it=h("p"),Nn=i("We can factor out the "),Wn=h("span"),En=i(" term to get:"),oa=q(),wn=h("p"),Ke=h("span"),Gn=q(),ce=h("p"),Ma=i("Let "),Tn=h("span"),Pa=i(" denote the binary number represented by the "),Mn=h("span"),fn=i(" qubits in a given basis state, and "),Pn=h("span"),Kn=i(" the "),gn=h("span"),Sa=i("-th digit of "),Sn=h("span"),Aa=i(". In other words, "),Yn=h("span"),xa=i("\xA0if the "),sa=h("span"),ve=i("-th qubit is in the "),je=h("span"),ia=i(" state, and "),Bn=h("span"),la=i("\xA0if it's in the "),Rn=h("span"),ha=i(" state for all "),Rt=h("span"),Pr=i(". Recalling our knowledge of binary numbers, we can write "),nn=h("span"),Sr=i(" as the weighted sum of its digits: "),ua=h("span"),Ar=i(". Notice that the "),fa=h("span"),xr=i(" term within the sum does not depend on "),ma=h("span"),qr=i(" and so we can factor it out: "),pa=h("span"),mn=i(". Remember this step, as it is going to be important shortly!"),Ba=q(),ca=h("p"),yn=i("Using this new notation, we can write the state of the qubits in the form of a sum instead of a product:"),Ra=q(),da=h("p"),xe=h("span"),Qa=q(),An=h("p"),Hr=i("In case you're wondering how the formula above can be derived from the definition we started with, note that for all "),_a=h("span"),Lr=i(", the term "),ba=h("span"),Ir=i(" equals"),ja=q(),Jn=h("ul"),Xn=h("li"),va=h("span"),Ss=i(" if "),Da=h("span"),As=i(", and"),xs=q(),wa=h("li"),Wa=h("span"),qs=i(" if "),Ga=h("span"),Hs=i(","),Or=q(),Ua=h("p"),Ls=i("which is exactly how we defined the QFT."),Kr=q(),xn=h("p"),Is=i("The "),Oa=h("span"),Fs=i(" embedded summations might seem confusing at first, but what they actually do is iterate over all possible combinations of basis states. In the final sum, these are included with "),Fr=h("em"),zs=i("equal weight"),Vs=i(" (meaning they are measured with equal probability), but the composing basis states will have "),zr=h("em"),Cs=i("different phases"),Bs=i(" in each combination, as already mentioned at the end of the previous section."),Zr=q(),ga=h("p"),Rs=i("Let's now define the "),Vr=h("em"),Qs=i("phase of the combination"),js=i(" as the product of the phases of individual qubits within that combination, and factor it out as shown below:"),Yr=q(),Ka=h("p"),Za=h("span"),Jr=q(),Ya=h("p"),Ja=h("span"),Xr=q(),Xa=h("p"),Ds=i("After making use of the product rule for exponents..."),es=q(),er=h("p"),tr=h("span"),ts=q(),ea=h("p"),Ws=i("and factoring out the "),nr=h("span"),Gs=i(" term that does not depend on "),ar=h("span"),Us=i(", we arrive at the formula below:"),ns=q(),rr=h("p"),sr=h("span"),as=q(),Qt=h("p"),Os=i("Recall what I asked you to keep in mind a few paragraphs ago, and notice that the sum in the exponential "),or=h("span"),Ks=i(" is actually equal to "),ir=h("span"),Zs=i(". Thus, we can now replace the individual "),lr=h("span"),Ys=i(" digits with the number "),hr=h("span"),Js=i(" itself and the multiple, embedded summations with a single one that iterates over all possible values of "),ur=h("span"),Xs=i(". In addition, let's abbreviate the notation we used for the product of the basis states with "),fr=h("span"),eo=i(", to finally obtain this way more elegant formula for the QFT:"),rs=q(),mr=h("p"),pr=h("span"),ss=q(),cr=h("p"),to=i("The elegance comes from the fact that it shows what the qubits represent on a symbolic level, as opposed to the expression we started with that is a direct insight into the bit-level implementation."),os=q(),Jt=h("p"),no=i("Now let's illustrate visually what the formula above actually means. To give a proper intuition, we'll look at multiple systems with increasing number of qubits. For a chosen value of "),dr=h("span"),ao=i(", the plot below shows the "),_r=h("span"),ro=i(" terms for all possible values of "),br=h("span"),so=i(" that these systems can represent. Because this term is a complex number, the geometric representation of which would require two dimensions, the real and imaginary components are shown separately. Notice that as the number of qubits increases, the plots gradually turn into sinusoidal wave patterns. Furthermore, the number of peaks of these waves - their frequency - equals "),vr=h("span"),oo=i(", which you can verify by modifying "),wr=h("span"),io=i(" with the help of the slider.")},l(g){t=u(g,"H2",{});var Y=f(t);a=l(Y,"Quantum Fourier transform (QFT)"),Y.forEach(r),s=H(g),o=u(g,"H2",{});var Cr=f(o);c=l(Cr,"Representing numbers with qubits"),Cr.forEach(r),p=H(g),m=u(g,"P",{});var an=f(m);b=l(an,"Consider "),_=u(an,"SPAN",{});var Xi=f(_);Xi.forEach(r),v=l(an," qubits aranged in a row, each of which are in either of the two basis states "),k=u(an,"SPAN",{});var el=f(k);el.forEach(r),A=l(an," or "),G=u(an,"SPAN",{});var tl=f(G);tl.forEach(r),P=l(an,". With a little combinatorics, we can see that there are "),C=u(an,"SPAN",{});var nl=f(C);nl.forEach(r),S=l(an," such combinations. For ease of notation, let "),z=u(an,"SPAN",{});var al=f(z);al.forEach(r),Z=l(an,"."),an.forEach(r),K=H(g),Q=u(g,"P",{});var Xt=f(Q);ee=l(Xt,"For our purposes, we'll interpret these combinations as the "),ye(I.$$.fragment,Xt),E=l(Xt," of the numbers from "),x=u(Xt,"SPAN",{});var rl=f(x);rl.forEach(r),R=l(Xt," to "),L=u(Xt,"SPAN",{});var sl=f(L);sl.forEach(r),oe=l(Xt,". For example, let "),te=u(Xt,"SPAN",{});var ol=f(te);ol.forEach(r),ae=l(Xt," and the qubits be in the following state: "),W=u(Xt,"SPAN",{});var il=f(W);il.forEach(r),U=l(Xt,'. We can "read out" this state as the binary number '),J=u(Xt,"SPAN",{});var ll=f(J);ll.forEach(r),Ne=l(Xt,", which is equal to "),Le=u(Xt,"SPAN",{});var hl=f(Le);hl.forEach(r),Ae=l(Xt,"."),Xt.forEach(r),Re=H(g),Ce=u(g,"H2",{});var So=f(Ce);rt=l(So,"QFT on the qubit level"),So.forEach(r),Qe=H(g),Ee=u(g,"P",{});var jt=f(Ee);gt=l(jt,"The "),ye(Te.$$.fragment,jt),We=l(jt," is an operation that modifies the states of qubits in a particular way. (How this is done in practice is another topic, for now we'll only look at the mathematics.) Namely, if "),he=u(jt,"SPAN",{});var ul=f(he);ul.forEach(r),dt=l(jt," is the number represented by the qubits (in the example above, "),we=u(jt,"SPAN",{});var fl=f(we);fl.forEach(r),de=l(jt,"), the QFT sets the state of the "),re=u(jt,"SPAN",{});var ml=f(re);ml.forEach(r),X=l(jt,"-th qubit to "),_t=u(jt,"SPAN",{});var pl=f(_t);pl.forEach(r),Ue=l(jt,". In other words, it sets "),bt=u(jt,"SPAN",{});var cl=f(bt);cl.forEach(r),Je=l(jt," and "),At=u(jt,"SPAN",{});var dl=f(At);dl.forEach(r),ze=l(jt," for all "),le=u(jt,"SPAN",{});var _l=f(le);_l.forEach(r),vt=l(jt,"."),jt.forEach(r),Et=H(g),Oe=u(g,"P",{});var ta=f(Oe);Tt=l(ta,"Notice that even though "),Kt=u(ta,"SPAN",{});var bl=f(Kt);bl.forEach(r),yt=l(ta,", the associated measurement probabilities "),Ct=u(ta,"SPAN",{});var vl=f(Ct);vl.forEach(r),dn=l(ta," for all "),$t=u(ta,"SPAN",{});var wl=f($t);wl.forEach(r),xt=l(ta,". This is because the "),wt=u(ta,"SPAN",{});var gl=f(wt);gl.forEach(r),nt=l(ta," term - as we saw in the section about the Bloch-sphere - indicates the qubit's phase and does not affect measurement probabilities."),ta.forEach(r),ut=H(g),Me=u(g,"P",{});var Lt=f(Me);Pt=l(Lt,"Just like the state of a single qubit can be the linear combination of "),ft=u(Lt,"SPAN",{});var yl=f(ft);yl.forEach(r),kt=l(Lt," and "),It=u(Lt,"SPAN",{});var $l=f(It);$l.forEach(r),mt=l(Lt,", the state of these "),Zt=u(Lt,"SPAN",{});var kl=f(Zt);kl.forEach(r),Dt=l(Lt," qubits is essentially the linear combination of all the possible combinations of the "),Ve=u(Lt,"SPAN",{});var Nl=f(Ve);Nl.forEach(r),Be=l(Lt," basis states - which, as we saw in the previous section, represent the integers from "),Ze=u(Lt,"SPAN",{});var El=f(Ze);El.forEach(r),Ft=l(Lt," to "),qt=u(Lt,"SPAN",{});var Tl=f(qt);Tl.forEach(r),Yt=l(Lt,". Since both basis states are measured with a probability of "),qe=u(Lt,"SPAN",{});var Ml=f(qe);Ml.forEach(r),Wt=l(Lt," for each qubit, one particular combination of the "),me=u(Lt,"SPAN",{});var Pl=f(me);Pl.forEach(r),Gt=l(Lt," basis states is measured with a probability of "),hn=u(Lt,"SPAN",{});var Sl=f(hn);Sl.forEach(r),ue=l(Lt,". What differs across these combinations is the phase, as we'll see in the next section."),Lt.forEach(r),pt=H(g),Bt=u(g,"H2",{});var Ao=f(Bt);pe=l(Ao,"QFT on the representation level"),Ao.forEach(r),vn=H(g),He=u(g,"P",{});var ls=f(He);Fn=l(ls,"Let's denote the state of the entire sequence of qubits with "),Ut=u(ls,"SPAN",{});var Al=f(Ut);Al.forEach(r),zn=l(ls," and write it out as shown below:"),ls.forEach(r),tn=H(g),kn=u(g,"P",{});var xo=f(kn);un=u(xo,"SPAN",{});var xl=f(un);xl.forEach(r),xo.forEach(r),Vn=H(g),it=u(g,"P",{});var hs=f(it);Nn=l(hs,"We can factor out the "),Wn=u(hs,"SPAN",{});var ql=f(Wn);ql.forEach(r),En=l(hs," term to get:"),hs.forEach(r),oa=H(g),wn=u(g,"P",{});var qo=f(wn);Ke=u(qo,"SPAN",{});var Hl=f(Ke);Hl.forEach(r),qo.forEach(r),Gn=H(g),ce=u(g,"P",{});var De=f(ce);Ma=l(De,"Let "),Tn=u(De,"SPAN",{});var Ll=f(Tn);Ll.forEach(r),Pa=l(De," denote the binary number represented by the "),Mn=u(De,"SPAN",{});var Il=f(Mn);Il.forEach(r),fn=l(De," qubits in a given basis state, and "),Pn=u(De,"SPAN",{});var Fl=f(Pn);Fl.forEach(r),Kn=l(De," the "),gn=u(De,"SPAN",{});var zl=f(gn);zl.forEach(r),Sa=l(De,"-th digit of "),Sn=u(De,"SPAN",{});var Vl=f(Sn);Vl.forEach(r),Aa=l(De,". In other words, "),Yn=u(De,"SPAN",{});var Cl=f(Yn);Cl.forEach(r),xa=l(De,"\xA0if the "),sa=u(De,"SPAN",{});var Bl=f(sa);Bl.forEach(r),ve=l(De,"-th qubit is in the "),je=u(De,"SPAN",{});var Rl=f(je);Rl.forEach(r),ia=l(De," state, and "),Bn=u(De,"SPAN",{});var Ql=f(Bn);Ql.forEach(r),la=l(De,"\xA0if it's in the "),Rn=u(De,"SPAN",{});var jl=f(Rn);jl.forEach(r),ha=l(De," state for all "),Rt=u(De,"SPAN",{});var Dl=f(Rt);Dl.forEach(r),Pr=l(De,". Recalling our knowledge of binary numbers, we can write "),nn=u(De,"SPAN",{});var Wl=f(nn);Wl.forEach(r),Sr=l(De," as the weighted sum of its digits: "),ua=u(De,"SPAN",{});var Gl=f(ua);Gl.forEach(r),Ar=l(De,". Notice that the "),fa=u(De,"SPAN",{});var Ul=f(fa);Ul.forEach(r),xr=l(De," term within the sum does not depend on "),ma=u(De,"SPAN",{});var Ol=f(ma);Ol.forEach(r),qr=l(De," and so we can factor it out: "),pa=u(De,"SPAN",{});var Kl=f(pa);Kl.forEach(r),mn=l(De,". Remember this step, as it is going to be important shortly!"),De.forEach(r),Ba=H(g),ca=u(g,"P",{});var Ho=f(ca);yn=l(Ho,"Using this new notation, we can write the state of the qubits in the form of a sum instead of a product:"),Ho.forEach(r),Ra=H(g),da=u(g,"P",{});var Lo=f(da);xe=u(Lo,"SPAN",{});var Zl=f(xe);Zl.forEach(r),Lo.forEach(r),Qa=H(g),An=u(g,"P",{});var gr=f(An);Hr=l(gr,"In case you're wondering how the formula above can be derived from the definition we started with, note that for all "),_a=u(gr,"SPAN",{});var Yl=f(_a);Yl.forEach(r),Lr=l(gr,", the term "),ba=u(gr,"SPAN",{});var Jl=f(ba);Jl.forEach(r),Ir=l(gr," equals"),gr.forEach(r),ja=H(g),Jn=u(g,"UL",{});var us=f(Jn);Xn=u(us,"LI",{});var Br=f(Xn);va=u(Br,"SPAN",{});var Xl=f(va);Xl.forEach(r),Ss=l(Br," if "),Da=u(Br,"SPAN",{});var eh=f(Da);eh.forEach(r),As=l(Br,", and"),Br.forEach(r),xs=H(us),wa=u(us,"LI",{});var Rr=f(wa);Wa=u(Rr,"SPAN",{});var th=f(Wa);th.forEach(r),qs=l(Rr," if "),Ga=u(Rr,"SPAN",{});var nh=f(Ga);nh.forEach(r),Hs=l(Rr,","),Rr.forEach(r),us.forEach(r),Or=H(g),Ua=u(g,"P",{});var Io=f(Ua);Ls=l(Io,"which is exactly how we defined the QFT."),Io.forEach(r),Kr=H(g),xn=u(g,"P",{});var ya=f(xn);Is=l(ya,"The "),Oa=u(ya,"SPAN",{});var ah=f(Oa);ah.forEach(r),Fs=l(ya," embedded summations might seem confusing at first, but what they actually do is iterate over all possible combinations of basis states. In the final sum, these are included with "),Fr=u(ya,"EM",{});var Fo=f(Fr);zs=l(Fo,"equal weight"),Fo.forEach(r),Vs=l(ya," (meaning they are measured with equal probability), but the composing basis states will have "),zr=u(ya,"EM",{});var zo=f(zr);Cs=l(zo,"different phases"),zo.forEach(r),Bs=l(ya," in each combination, as already mentioned at the end of the previous section."),ya.forEach(r),Zr=H(g),ga=u(g,"P",{});var fs=f(ga);Rs=l(fs,"Let's now define the "),Vr=u(fs,"EM",{});var Vo=f(Vr);Qs=l(Vo,"phase of the combination"),Vo.forEach(r),js=l(fs," as the product of the phases of individual qubits within that combination, and factor it out as shown below:"),fs.forEach(r),Yr=H(g),Ka=u(g,"P",{});var Co=f(Ka);Za=u(Co,"SPAN",{});var rh=f(Za);rh.forEach(r),Co.forEach(r),Jr=H(g),Ya=u(g,"P",{});var Bo=f(Ya);Ja=u(Bo,"SPAN",{});var sh=f(Ja);sh.forEach(r),Bo.forEach(r),Xr=H(g),Xa=u(g,"P",{});var Ro=f(Xa);Ds=l(Ro,"After making use of the product rule for exponents..."),Ro.forEach(r),es=H(g),er=u(g,"P",{});var Qo=f(er);tr=u(Qo,"SPAN",{});var oh=f(tr);oh.forEach(r),Qo.forEach(r),ts=H(g),ea=u(g,"P",{});var yr=f(ea);Ws=l(yr,"and factoring out the "),nr=u(yr,"SPAN",{});var ih=f(nr);ih.forEach(r),Gs=l(yr," term that does not depend on "),ar=u(yr,"SPAN",{});var lh=f(ar);lh.forEach(r),Us=l(yr,", we arrive at the formula below:"),yr.forEach(r),ns=H(g),rr=u(g,"P",{});var jo=f(rr);sr=u(jo,"SPAN",{});var hh=f(sr);hh.forEach(r),jo.forEach(r),as=H(g),Qt=u(g,"P",{});var pn=f(Qt);Os=l(pn,"Recall what I asked you to keep in mind a few paragraphs ago, and notice that the sum in the exponential "),or=u(pn,"SPAN",{});var uh=f(or);uh.forEach(r),Ks=l(pn," is actually equal to "),ir=u(pn,"SPAN",{});var fh=f(ir);fh.forEach(r),Zs=l(pn,". Thus, we can now replace the individual "),lr=u(pn,"SPAN",{});var mh=f(lr);mh.forEach(r),Ys=l(pn," digits with the number "),hr=u(pn,"SPAN",{});var ph=f(hr);ph.forEach(r),Js=l(pn," itself and the multiple, embedded summations with a single one that iterates over all possible values of "),ur=u(pn,"SPAN",{});var ch=f(ur);ch.forEach(r),Xs=l(pn,". In addition, let's abbreviate the notation we used for the product of the basis states with "),fr=u(pn,"SPAN",{});var dh=f(fr);dh.forEach(r),eo=l(pn,", to finally obtain this way more elegant formula for the QFT:"),pn.forEach(r),rs=H(g),mr=u(g,"P",{});var Do=f(mr);pr=u(Do,"SPAN",{});var _h=f(pr);_h.forEach(r),Do.forEach(r),ss=H(g),cr=u(g,"P",{});var Wo=f(cr);to=l(Wo,"The elegance comes from the fact that it shows what the qubits represent on a symbolic level, as opposed to the expression we started with that is a direct insight into the bit-level implementation."),Wo.forEach(r),os=H(g),Jt=u(g,"P",{});var qn=f(Jt);no=l(qn,"Now let's illustrate visually what the formula above actually means. To give a proper intuition, we'll look at multiple systems with increasing number of qubits. For a chosen value of "),dr=u(qn,"SPAN",{});var bh=f(dr);bh.forEach(r),ao=l(qn,", the plot below shows the "),_r=u(qn,"SPAN",{});var vh=f(_r);vh.forEach(r),ro=l(qn," terms for all possible values of "),br=u(qn,"SPAN",{});var wh=f(br);wh.forEach(r),so=l(qn," that these systems can represent. Because this term is a complex number, the geometric representation of which would require two dimensions, the real and imaginary components are shown separately. Notice that as the number of qubits increases, the plots gradually turn into sinusoidal wave patterns. Furthermore, the number of peaks of these waves - their frequency - equals "),vr=u(qn,"SPAN",{});var gh=f(vr);gh.forEach(r),oo=l(qn,", which you can verify by modifying "),wr=u(qn,"SPAN",{});var yh=f(wr);yh.forEach(r),io=l(qn," with the help of the slider."),qn.forEach(r)},m(g,Y){y(g,t,Y),n(t,a),y(g,s,Y),y(g,o,Y),n(o,c),y(g,p,Y),y(g,m,Y),n(m,b),n(m,_),_.innerHTML=N,n(m,v),n(m,k),k.innerHTML=$,n(m,A),n(m,G),G.innerHTML=j,n(m,P),n(m,C),C.innerHTML=F,n(m,S),n(m,z),z.innerHTML=M,n(m,Z),y(g,K,Y),y(g,Q,Y),n(Q,ee),$e(I,Q,null),n(Q,E),n(Q,x),x.innerHTML=ne,n(Q,R),n(Q,L),L.innerHTML=D,n(Q,oe),n(Q,te),te.innerHTML=Pe,n(Q,ae),n(Q,W),W.innerHTML=T,n(Q,U),n(Q,J),J.innerHTML=Se,n(Q,Ne),n(Q,Le),Le.innerHTML=Ie,n(Q,Ae),y(g,Re,Y),y(g,Ce,Y),n(Ce,rt),y(g,Qe,Y),y(g,Ee,Y),n(Ee,gt),$e(Te,Ee,null),n(Ee,We),n(Ee,he),he.innerHTML=Ge,n(Ee,dt),n(Ee,we),we.innerHTML=ht,n(Ee,de),n(Ee,re),re.innerHTML=_e,n(Ee,X),n(Ee,_t),_t.innerHTML=st,n(Ee,Ue),n(Ee,bt),bt.innerHTML=ot,n(Ee,Je),n(Ee,At),At.innerHTML=ie,n(Ee,ze),n(Ee,le),le.innerHTML=Nt,n(Ee,vt),y(g,Et,Y),y(g,Oe,Y),n(Oe,Tt),n(Oe,Kt),Kt.innerHTML=Vt,n(Oe,yt),n(Oe,Ct),Ct.innerHTML=Mt,n(Oe,dn),n(Oe,$t),$t.innerHTML=Xe,n(Oe,xt),n(Oe,wt),wt.innerHTML=Ye,n(Oe,nt),y(g,ut,Y),y(g,Me,Y),n(Me,Pt),n(Me,ft),ft.innerHTML=_n,n(Me,kt),n(Me,It),It.innerHTML=bn,n(Me,mt),n(Me,Zt),Zt.innerHTML=ln,n(Me,Dt),n(Me,Ve),Ve.innerHTML=se,n(Me,Be),n(Me,Ze),Ze.innerHTML=$n,n(Me,Ft),n(Me,qt),qt.innerHTML=ra,n(Me,Yt),n(Me,qe),qe.innerHTML=Ln,n(Me,Wt),n(Me,me),me.innerHTML=In,n(Me,Gt),n(Me,hn),hn.innerHTML=Dn,n(Me,ue),y(g,pt,Y),y(g,Bt,Y),n(Bt,pe),y(g,vn,Y),y(g,He,Y),n(He,Fn),n(He,Ut),Ut.innerHTML=Ea,n(He,zn),y(g,tn,Y),y(g,kn,Y),n(kn,un),un.innerHTML=St,y(g,Vn,Y),y(g,it,Y),n(it,Nn),n(it,Wn),Wn.innerHTML=Ta,n(it,En),y(g,oa,Y),y(g,wn,Y),n(wn,Ke),Ke.innerHTML=Mr,y(g,Gn,Y),y(g,ce,Y),n(ce,Ma),n(ce,Tn),Tn.innerHTML=Un,n(ce,Pa),n(ce,Mn),Mn.innerHTML=Cn,n(ce,fn),n(ce,Pn),Pn.innerHTML=On,n(ce,Kn),n(ce,gn),gn.innerHTML=zt,n(ce,Sa),n(ce,Sn),Sn.innerHTML=Zn,n(ce,Aa),n(ce,Yn),Yn.innerHTML=Fa,n(ce,xa),n(ce,sa),sa.innerHTML=B,n(ce,ve),n(ce,je),je.innerHTML=za,n(ce,ia),n(ce,Bn),Bn.innerHTML=Va,n(ce,la),n(ce,Rn),Rn.innerHTML=Ca,n(ce,ha),n(ce,Rt),Rt.innerHTML=$s,n(ce,Pr),n(ce,nn),nn.innerHTML=ks,n(ce,Sr),n(ce,ua),ua.innerHTML=Ht,n(ce,Ar),n(ce,fa),fa.innerHTML=Ns,n(ce,xr),n(ce,ma),ma.innerHTML=Es,n(ce,qr),n(ce,pa),pa.innerHTML=Ur,n(ce,mn),y(g,Ba,Y),y(g,ca,Y),n(ca,yn),y(g,Ra,Y),y(g,da,Y),n(da,xe),xe.innerHTML=Ts,y(g,Qa,Y),y(g,An,Y),n(An,Hr),n(An,_a),_a.innerHTML=Ms,n(An,Lr),n(An,ba),ba.innerHTML=Ps,n(An,Ir),y(g,ja,Y),y(g,Jn,Y),n(Jn,Xn),n(Xn,va),va.innerHTML=Ai,n(Xn,Ss),n(Xn,Da),Da.innerHTML=xi,n(Xn,As),n(Jn,xs),n(Jn,wa),n(wa,Wa),Wa.innerHTML=qi,n(wa,qs),n(wa,Ga),Ga.innerHTML=Hi,n(wa,Hs),y(g,Or,Y),y(g,Ua,Y),n(Ua,Ls),y(g,Kr,Y),y(g,xn,Y),n(xn,Is),n(xn,Oa),Oa.innerHTML=Li,n(xn,Fs),n(xn,Fr),n(Fr,zs),n(xn,Vs),n(xn,zr),n(zr,Cs),n(xn,Bs),y(g,Zr,Y),y(g,ga,Y),n(ga,Rs),n(ga,Vr),n(Vr,Qs),n(ga,js),y(g,Yr,Y),y(g,Ka,Y),n(Ka,Za),Za.innerHTML=Ii,y(g,Jr,Y),y(g,Ya,Y),n(Ya,Ja),Ja.innerHTML=Fi,y(g,Xr,Y),y(g,Xa,Y),n(Xa,Ds),y(g,es,Y),y(g,er,Y),n(er,tr),tr.innerHTML=zi,y(g,ts,Y),y(g,ea,Y),n(ea,Ws),n(ea,nr),nr.innerHTML=Vi,n(ea,Gs),n(ea,ar),ar.innerHTML=Ci,n(ea,Us),y(g,ns,Y),y(g,rr,Y),n(rr,sr),sr.innerHTML=Bi,y(g,as,Y),y(g,Qt,Y),n(Qt,Os),n(Qt,or),or.innerHTML=Ri,n(Qt,Ks),n(Qt,ir),ir.innerHTML=Qi,n(Qt,Zs),n(Qt,lr),lr.innerHTML=ji,n(Qt,Ys),n(Qt,hr),hr.innerHTML=Di,n(Qt,Js),n(Qt,ur),ur.innerHTML=Wi,n(Qt,Xs),n(Qt,fr),fr.innerHTML=Gi,n(Qt,eo),y(g,rs,Y),y(g,mr,Y),n(mr,pr),pr.innerHTML=Ui,y(g,ss,Y),y(g,cr,Y),n(cr,to),y(g,os,Y),y(g,Jt,Y),n(Jt,no),n(Jt,dr),dr.innerHTML=Oi,n(Jt,ao),n(Jt,_r),_r.innerHTML=Ki,n(Jt,ro),n(Jt,br),br.innerHTML=Zi,n(Jt,so),n(Jt,vr),vr.innerHTML=Yi,n(Jt,oo),n(Jt,wr),wr.innerHTML=Ji,n(Jt,io),is=!0,lo||(Po=[w(_,"mouseenter",e[0]),w(k,"mouseenter",e[1]),w(G,"mouseenter",e[2]),w(C,"mouseenter",e[3]),w(z,"mouseenter",e[4]),w(x,"mouseenter",e[5]),w(L,"mouseenter",e[6]),w(te,"mouseenter",e[7]),w(W,"mouseenter",e[8]),w(J,"mouseenter",e[9]),w(Le,"mouseenter",e[10]),w(he,"mouseenter",e[11]),w(we,"mouseenter",e[12]),w(re,"mouseenter",e[13]),w(_t,"mouseenter",e[14]),w(bt,"mouseenter",e[15]),w(At,"mouseenter",e[16]),w(le,"mouseenter",e[17]),w(Kt,"mouseenter",e[18]),w(Ct,"mouseenter",e[19]),w($t,"mouseenter",e[20]),w(wt,"mouseenter",e[21]),w(ft,"mouseenter",e[22]),w(It,"mouseenter",e[23]),w(Zt,"mouseenter",e[24]),w(Ve,"mouseenter",e[25]),w(Ze,"mouseenter",e[26]),w(qt,"mouseenter",e[27]),w(qe,"mouseenter",e[28]),w(me,"mouseenter",e[29]),w(hn,"mouseenter",e[30]),w(Ut,"mouseenter",e[31]),w(un,"mouseenter",e[32]),w(Wn,"mouseenter",e[33]),w(Ke,"mouseenter",e[34]),w(Tn,"mouseenter",e[35]),w(Mn,"mouseenter",e[36]),w(Pn,"mouseenter",e[37]),w(gn,"mouseenter",e[38]),w(Sn,"mouseenter",e[39]),w(Yn,"mouseenter",e[40]),w(sa,"mouseenter",e[41]),w(je,"mouseenter",e[42]),w(Bn,"mouseenter",e[43]),w(Rn,"mouseenter",e[44]),w(Rt,"mouseenter",e[45]),w(nn,"mouseenter",e[46]),w(ua,"mouseenter",e[47]),w(fa,"mouseenter",e[48]),w(ma,"mouseenter",e[49]),w(pa,"mouseenter",e[50]),w(xe,"mouseenter",e[51]),w(_a,"mouseenter",e[52]),w(ba,"mouseenter",e[53]),w(va,"mouseenter",e[54]),w(Da,"mouseenter",e[55]),w(Wa,"mouseenter",e[56]),w(Ga,"mouseenter",e[57]),w(Oa,"mouseenter",e[58]),w(Za,"mouseenter",e[59]),w(Ja,"mouseenter",e[60]),w(tr,"mouseenter",e[61]),w(nr,"mouseenter",e[62]),w(ar,"mouseenter",e[63]),w(sr,"mouseenter",e[64]),w(or,"mouseenter",e[65]),w(ir,"mouseenter",e[66]),w(lr,"mouseenter",e[67]),w(hr,"mouseenter",e[68]),w(ur,"mouseenter",e[69]),w(fr,"mouseenter",e[70]),w(pr,"mouseenter",e[71]),w(dr,"mouseenter",e[72]),w(_r,"mouseenter",e[73]),w(br,"mouseenter",e[74]),w(vr,"mouseenter",e[75]),w(wr,"mouseenter",e[76])],lo=!0)},p(g,Y){const Cr={};Y[2]&32768&&(Cr.$$scope={dirty:Y,ctx:g}),I.$set(Cr);const an={};Y[2]&32768&&(an.$$scope={dirty:Y,ctx:g}),Te.$set(an)},i(g){is||(fe(I.$$.fragment,g),fe(Te.$$.fragment,g),is=!0)},o(g){be(I.$$.fragment,g),be(Te.$$.fragment,g),is=!1},d(g){g&&r(t),g&&r(s),g&&r(o),g&&r(p),g&&r(m),g&&r(K),g&&r(Q),ke(I),g&&r(Re),g&&r(Ce),g&&r(Qe),g&&r(Ee),ke(Te),g&&r(Et),g&&r(Oe),g&&r(ut),g&&r(Me),g&&r(pt),g&&r(Bt),g&&r(vn),g&&r(He),g&&r(tn),g&&r(kn),g&&r(Vn),g&&r(it),g&&r(oa),g&&r(wn),g&&r(Gn),g&&r(ce),g&&r(Ba),g&&r(ca),g&&r(Ra),g&&r(da),g&&r(Qa),g&&r(An),g&&r(ja),g&&r(Jn),g&&r(Or),g&&r(Ua),g&&r(Kr),g&&r(xn),g&&r(Zr),g&&r(ga),g&&r(Yr),g&&r(Ka),g&&r(Jr),g&&r(Ya),g&&r(Xr),g&&r(Xa),g&&r(es),g&&r(er),g&&r(ts),g&&r(ea),g&&r(ns),g&&r(rr),g&&r(as),g&&r(Qt),g&&r(rs),g&&r(mr),g&&r(ss),g&&r(cr),g&&r(os),g&&r(Jt),lo=!1,jn(Po)}}}function O(e){console.log(e)}function Mu(e){return[()=>O(["n"]),()=>O([]),()=>O([]),()=>O(["m","t","n","s"]),()=>O(["n","N"]),()=>O([]),()=>O(["N"]),()=>O(["n"]),()=>O([]),()=>O([]),()=>O([]),()=>O(["x"]),()=>O(["x"]),()=>O(["k"]),()=>O(["x","k"]),()=>O(["\\alpha","k"]),()=>O(["\\beta","x","k"]),()=>O(["n","k"]),()=>O(["\\beta","\\alpha","k"]),()=>O(["\\beta","\\alpha","k"]),()=>O(["n","k"]),()=>O(["x","k"]),()=>O([]),()=>O([]),()=>O(["n"]),()=>O(["n"]),()=>O([]),()=>O(["N"]),()=>O([]),()=>O(["n"]),()=>O(["m","r","s","n","t","N"]),()=>O(["\\psi"]),()=>O(["m","r","x","s","n","t","\\psi"]),()=>O([]),()=>O(["x","n","N","\\psi"]),()=>O(["y"]),()=>O(["n"]),()=>O(["k","y"]),()=>O(["k"]),()=>O(["y"]),()=>O(["k","y"]),()=>O(["k"]),()=>O([]),()=>O(["k","y"]),()=>O([]),()=>O(["n","k"]),()=>O(["y"]),()=>O(["k","n","y"]),()=>O(["n"]),()=>O(["k"]),()=>O(["N","k","n","y"]),()=>O(["m","y","r","x","s","n","t","N","\\psi"]),()=>O(["k"]),()=>O(["x","k","y"]),()=>O(["x","k"]),()=>O(["k","y"]),()=>O(["x","k"]),()=>O(["k","y"]),()=>O(["n"]),()=>O(["y","x","n","N","\\psi"]),()=>O(["y","x","n","k","N","\\psi"]),()=>O(["y","x","n","k","N","\\psi"]),()=>O(["x"]),()=>O(["k"]),()=>O(["y","x","n","k","N","\\psi"]),()=>O(["y","n","k"]),()=>O(["N","y"]),()=>O(["k","y"]),()=>O(["y"]),()=>O(["y"]),()=>O(["n","y"]),()=>O(["y","x","N","\\psi"]),()=>O(["x"]),()=>O(["N","x","y"]),()=>O(["y"]),()=>O(["x"]),()=>O(["x"])]}class Pu extends rn{constructor(t){super(),sn(this,t,Mu,Tu,on,{},null,[-1,-1,-1])}}function _s(e,t){return e==null||t==null?NaN:e<t?-1:e>t?1:e>=t?0:NaN}function Su(e,t){return e==null||t==null?NaN:t<e?-1:t>e?1:t>=e?0:NaN}function gi(e){let t,a,s;e.length!==2?(t=_s,a=(m,b)=>_s(e(m),b),s=(m,b)=>e(m)-b):(t=e===_s||e===Su?e:Au,a=e,s=e);function o(m,b,_=0,N=m.length){if(_<N){if(t(b,b)!==0)return N;do{const v=_+N>>>1;a(m[v],b)<0?_=v+1:N=v}while(_<N)}return _}function c(m,b,_=0,N=m.length){if(_<N){if(t(b,b)!==0)return N;do{const v=_+N>>>1;a(m[v],b)<=0?_=v+1:N=v}while(_<N)}return _}function p(m,b,_=0,N=m.length){const v=o(m,b,_,N-1);return v>_&&s(m[v-1],b)>-s(m[v],b)?v-1:v}return{left:o,center:p,right:c}}function Au(){return 0}function xu(e){return e===null?NaN:+e}const qu=gi(_s),Hu=qu.right;gi(xu).center;const Lu=Hu;function Yo(e,t){let a,s;if(t===void 0)for(const o of e)o!=null&&(a===void 0?o>=o&&(a=s=o):(a>o&&(a=o),s<o&&(s=o)));else{let o=-1;for(let c of e)(c=t(c,++o,e))!=null&&(a===void 0?c>=c&&(a=s=c):(a>c&&(a=c),s<c&&(s=c)))}return[a,s]}var mo=Math.sqrt(50),po=Math.sqrt(10),co=Math.sqrt(2);function Iu(e,t,a){var s,o=-1,c,p,m;if(t=+t,e=+e,a=+a,e===t&&a>0)return[e];if((s=t<e)&&(c=e,e=t,t=c),(m=yi(e,t,a))===0||!isFinite(m))return[];if(m>0){let b=Math.round(e/m),_=Math.round(t/m);for(b*m<e&&++b,_*m>t&&--_,p=new Array(c=_-b+1);++o<c;)p[o]=(b+o)*m}else{m=-m;let b=Math.round(e*m),_=Math.round(t*m);for(b/m<e&&++b,_/m>t&&--_,p=new Array(c=_-b+1);++o<c;)p[o]=(b+o)/m}return s&&p.reverse(),p}function yi(e,t,a){var s=(t-e)/Math.max(0,a),o=Math.floor(Math.log(s)/Math.LN10),c=s/Math.pow(10,o);return o>=0?(c>=mo?10:c>=po?5:c>=co?2:1)*Math.pow(10,o):-Math.pow(10,-o)/(c>=mo?10:c>=po?5:c>=co?2:1)}function Fu(e,t,a){var s=Math.abs(t-e)/Math.max(0,a),o=Math.pow(10,Math.floor(Math.log(s)/Math.LN10)),c=s/o;return c>=mo?o*=10:c>=po?o*=5:c>=co&&(o*=2),t<e?-o:o}function zu(e,t){switch(arguments.length){case 0:break;case 1:this.range(e);break;default:this.range(t).domain(e);break}return this}function No(e,t,a){e.prototype=t.prototype=a,a.constructor=e}function $i(e,t){var a=Object.create(e.prototype);for(var s in t)a[s]=t[s];return a}function Gr(){}var jr=.7,bs=1/jr,Er="\\s*([+-]?\\d+)\\s*",Dr="\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",aa="\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",Vu=/^#([0-9a-f]{3,8})$/,Cu=new RegExp(`^rgb\\(${Er},${Er},${Er}\\)$`),Bu=new RegExp(`^rgb\\(${aa},${aa},${aa}\\)$`),Ru=new RegExp(`^rgba\\(${Er},${Er},${Er},${Dr}\\)$`),Qu=new RegExp(`^rgba\\(${aa},${aa},${aa},${Dr}\\)$`),ju=new RegExp(`^hsl\\(${Dr},${aa},${aa}\\)$`),Du=new RegExp(`^hsla\\(${Dr},${aa},${aa},${Dr}\\)$`),Jo={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074};No(Gr,Wr,{copy(e){return Object.assign(new this.constructor,this,e)},displayable(){return this.rgb().displayable()},hex:Xo,formatHex:Xo,formatHex8:Wu,formatHsl:Gu,formatRgb:ei,toString:ei});function Xo(){return this.rgb().formatHex()}function Wu(){return this.rgb().formatHex8()}function Gu(){return ki(this).formatHsl()}function ei(){return this.rgb().formatRgb()}function Wr(e){var t,a;return e=(e+"").trim().toLowerCase(),(t=Vu.exec(e))?(a=t[1].length,t=parseInt(t[1],16),a===6?ti(t):a===3?new cn(t>>8&15|t>>4&240,t>>4&15|t&240,(t&15)<<4|t&15,1):a===8?ps(t>>24&255,t>>16&255,t>>8&255,(t&255)/255):a===4?ps(t>>12&15|t>>8&240,t>>8&15|t>>4&240,t>>4&15|t&240,((t&15)<<4|t&15)/255):null):(t=Cu.exec(e))?new cn(t[1],t[2],t[3],1):(t=Bu.exec(e))?new cn(t[1]*255/100,t[2]*255/100,t[3]*255/100,1):(t=Ru.exec(e))?ps(t[1],t[2],t[3],t[4]):(t=Qu.exec(e))?ps(t[1]*255/100,t[2]*255/100,t[3]*255/100,t[4]):(t=ju.exec(e))?ri(t[1],t[2]/100,t[3]/100,1):(t=Du.exec(e))?ri(t[1],t[2]/100,t[3]/100,t[4]):Jo.hasOwnProperty(e)?ti(Jo[e]):e==="transparent"?new cn(NaN,NaN,NaN,0):null}function ti(e){return new cn(e>>16&255,e>>8&255,e&255,1)}function ps(e,t,a,s){return s<=0&&(e=t=a=NaN),new cn(e,t,a,s)}function Uu(e){return e instanceof Gr||(e=Wr(e)),e?(e=e.rgb(),new cn(e.r,e.g,e.b,e.opacity)):new cn}function _o(e,t,a,s){return arguments.length===1?Uu(e):new cn(e,t,a,s==null?1:s)}function cn(e,t,a,s){this.r=+e,this.g=+t,this.b=+a,this.opacity=+s}No(cn,_o,$i(Gr,{brighter(e){return e=e==null?bs:Math.pow(bs,e),new cn(this.r*e,this.g*e,this.b*e,this.opacity)},darker(e){return e=e==null?jr:Math.pow(jr,e),new cn(this.r*e,this.g*e,this.b*e,this.opacity)},rgb(){return this},clamp(){return new cn(La(this.r),La(this.g),La(this.b),vs(this.opacity))},displayable(){return-.5<=this.r&&this.r<255.5&&-.5<=this.g&&this.g<255.5&&-.5<=this.b&&this.b<255.5&&0<=this.opacity&&this.opacity<=1},hex:ni,formatHex:ni,formatHex8:Ou,formatRgb:ai,toString:ai}));function ni(){return`#${Ha(this.r)}${Ha(this.g)}${Ha(this.b)}`}function Ou(){return`#${Ha(this.r)}${Ha(this.g)}${Ha(this.b)}${Ha((isNaN(this.opacity)?1:this.opacity)*255)}`}function ai(){const e=vs(this.opacity);return`${e===1?"rgb(":"rgba("}${La(this.r)}, ${La(this.g)}, ${La(this.b)}${e===1?")":`, ${e})`}`}function vs(e){return isNaN(e)?1:Math.max(0,Math.min(1,e))}function La(e){return Math.max(0,Math.min(255,Math.round(e)||0))}function Ha(e){return e=La(e),(e<16?"0":"")+e.toString(16)}function ri(e,t,a,s){return s<=0?e=t=a=NaN:a<=0||a>=1?e=t=NaN:t<=0&&(e=NaN),new Qn(e,t,a,s)}function ki(e){if(e instanceof Qn)return new Qn(e.h,e.s,e.l,e.opacity);if(e instanceof Gr||(e=Wr(e)),!e)return new Qn;if(e instanceof Qn)return e;e=e.rgb();var t=e.r/255,a=e.g/255,s=e.b/255,o=Math.min(t,a,s),c=Math.max(t,a,s),p=NaN,m=c-o,b=(c+o)/2;return m?(t===c?p=(a-s)/m+(a<s)*6:a===c?p=(s-t)/m+2:p=(t-a)/m+4,m/=b<.5?c+o:2-c-o,p*=60):m=b>0&&b<1?0:p,new Qn(p,m,b,e.opacity)}function Ku(e,t,a,s){return arguments.length===1?ki(e):new Qn(e,t,a,s==null?1:s)}function Qn(e,t,a,s){this.h=+e,this.s=+t,this.l=+a,this.opacity=+s}No(Qn,Ku,$i(Gr,{brighter(e){return e=e==null?bs:Math.pow(bs,e),new Qn(this.h,this.s,this.l*e,this.opacity)},darker(e){return e=e==null?jr:Math.pow(jr,e),new Qn(this.h,this.s,this.l*e,this.opacity)},rgb(){var e=this.h%360+(this.h<0)*360,t=isNaN(e)||isNaN(this.s)?0:this.s,a=this.l,s=a+(a<.5?a:1-a)*t,o=2*a-s;return new cn(ho(e>=240?e-240:e+120,o,s),ho(e,o,s),ho(e<120?e+240:e-120,o,s),this.opacity)},clamp(){return new Qn(si(this.h),cs(this.s),cs(this.l),vs(this.opacity))},displayable(){return(0<=this.s&&this.s<=1||isNaN(this.s))&&0<=this.l&&this.l<=1&&0<=this.opacity&&this.opacity<=1},formatHsl(){const e=vs(this.opacity);return`${e===1?"hsl(":"hsla("}${si(this.h)}, ${cs(this.s)*100}%, ${cs(this.l)*100}%${e===1?")":`, ${e})`}`}}));function si(e){return e=(e||0)%360,e<0?e+360:e}function cs(e){return Math.max(0,Math.min(1,e||0))}function ho(e,t,a){return(e<60?t+(a-t)*e/60:e<180?a:e<240?t+(a-t)*(240-e)/60:t)*255}const Eo=e=>()=>e;function Zu(e,t){return function(a){return e+a*t}}function Yu(e,t,a){return e=Math.pow(e,a),t=Math.pow(t,a)-e,a=1/a,function(s){return Math.pow(e+s*t,a)}}function Ju(e){return(e=+e)==1?Ni:function(t,a){return a-t?Yu(t,a,e):Eo(isNaN(t)?a:t)}}function Ni(e,t){var a=t-e;return a?Zu(e,a):Eo(isNaN(e)?t:e)}const oi=function e(t){var a=Ju(t);function s(o,c){var p=a((o=_o(o)).r,(c=_o(c)).r),m=a(o.g,c.g),b=a(o.b,c.b),_=Ni(o.opacity,c.opacity);return function(N){return o.r=p(N),o.g=m(N),o.b=b(N),o.opacity=_(N),o+""}}return s.gamma=e,s}(1);function Xu(e,t){t||(t=[]);var a=e?Math.min(t.length,e.length):0,s=t.slice(),o;return function(c){for(o=0;o<a;++o)s[o]=e[o]*(1-c)+t[o]*c;return s}}function ef(e){return ArrayBuffer.isView(e)&&!(e instanceof DataView)}function tf(e,t){var a=t?t.length:0,s=e?Math.min(a,e.length):0,o=new Array(s),c=new Array(a),p;for(p=0;p<s;++p)o[p]=To(e[p],t[p]);for(;p<a;++p)c[p]=t[p];return function(m){for(p=0;p<s;++p)c[p]=o[p](m);return c}}function nf(e,t){var a=new Date;return e=+e,t=+t,function(s){return a.setTime(e*(1-s)+t*s),a}}function ws(e,t){return e=+e,t=+t,function(a){return e*(1-a)+t*a}}function af(e,t){var a={},s={},o;(e===null||typeof e!="object")&&(e={}),(t===null||typeof t!="object")&&(t={});for(o in t)o in e?a[o]=To(e[o],t[o]):s[o]=t[o];return function(c){for(o in a)s[o]=a[o](c);return s}}var bo=/[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,uo=new RegExp(bo.source,"g");function rf(e){return function(){return e}}function sf(e){return function(t){return e(t)+""}}function of(e,t){var a=bo.lastIndex=uo.lastIndex=0,s,o,c,p=-1,m=[],b=[];for(e=e+"",t=t+"";(s=bo.exec(e))&&(o=uo.exec(t));)(c=o.index)>a&&(c=t.slice(a,c),m[p]?m[p]+=c:m[++p]=c),(s=s[0])===(o=o[0])?m[p]?m[p]+=o:m[++p]=o:(m[++p]=null,b.push({i:p,x:ws(s,o)})),a=uo.lastIndex;return a<t.length&&(c=t.slice(a),m[p]?m[p]+=c:m[++p]=c),m.length<2?b[0]?sf(b[0].x):rf(t):(t=b.length,function(_){for(var N=0,v;N<t;++N)m[(v=b[N]).i]=v.x(_);return m.join("")})}function To(e,t){var a=typeof t,s;return t==null||a==="boolean"?Eo(t):(a==="number"?ws:a==="string"?(s=Wr(t))?(t=s,oi):of:t instanceof Wr?oi:t instanceof Date?nf:ef(t)?Xu:Array.isArray(t)?tf:typeof t.valueOf!="function"&&typeof t.toString!="function"||isNaN(t)?af:ws)(e,t)}function lf(e,t){return e=+e,t=+t,function(a){return Math.round(e*(1-a)+t*a)}}function hf(e){return function(){return e}}function uf(e){return+e}var ii=[0,1];function Nr(e){return e}function vo(e,t){return(t-=e=+e)?function(a){return(a-e)/t}:hf(isNaN(t)?NaN:.5)}function ff(e,t){var a;return e>t&&(a=e,e=t,t=a),function(s){return Math.max(e,Math.min(t,s))}}function mf(e,t,a){var s=e[0],o=e[1],c=t[0],p=t[1];return o<s?(s=vo(o,s),c=a(p,c)):(s=vo(s,o),c=a(c,p)),function(m){return c(s(m))}}function pf(e,t,a){var s=Math.min(e.length,t.length)-1,o=new Array(s),c=new Array(s),p=-1;for(e[s]<e[0]&&(e=e.slice().reverse(),t=t.slice().reverse());++p<s;)o[p]=vo(e[p],e[p+1]),c[p]=a(t[p],t[p+1]);return function(m){var b=Lu(e,m,1,s)-1;return c[b](o[b](m))}}function cf(e,t){return t.domain(e.domain()).range(e.range()).interpolate(e.interpolate()).clamp(e.clamp()).unknown(e.unknown())}function df(){var e=ii,t=ii,a=To,s,o,c,p=Nr,m,b,_;function N(){var k=Math.min(e.length,t.length);return p!==Nr&&(p=ff(e[0],e[k-1])),m=k>2?pf:mf,b=_=null,v}function v(k){return k==null||isNaN(k=+k)?c:(b||(b=m(e.map(s),t,a)))(s(p(k)))}return v.invert=function(k){return p(o((_||(_=m(t,e.map(s),ws)))(k)))},v.domain=function(k){return arguments.length?(e=Array.from(k,uf),N()):e.slice()},v.range=function(k){return arguments.length?(t=Array.from(k),N()):t.slice()},v.rangeRound=function(k){return t=Array.from(k),a=lf,N()},v.clamp=function(k){return arguments.length?(p=k?!0:Nr,N()):p!==Nr},v.interpolate=function(k){return arguments.length?(a=k,N()):a},v.unknown=function(k){return arguments.length?(c=k,v):c},function(k,$){return s=k,o=$,N()}}function _f(){return df()(Nr,Nr)}function bf(e){return Math.abs(e=Math.round(e))>=1e21?e.toLocaleString("en").replace(/,/g,""):e.toString(10)}function gs(e,t){if((a=(e=t?e.toExponential(t-1):e.toExponential()).indexOf("e"))<0)return null;var a,s=e.slice(0,a);return[s.length>1?s[0]+s.slice(2):s,+e.slice(a+1)]}function Tr(e){return e=gs(Math.abs(e)),e?e[1]:NaN}function vf(e,t){return function(a,s){for(var o=a.length,c=[],p=0,m=e[0],b=0;o>0&&m>0&&(b+m+1>s&&(m=Math.max(1,s-b)),c.push(a.substring(o-=m,o+m)),!((b+=m+1)>s));)m=e[p=(p+1)%e.length];return c.reverse().join(t)}}function wf(e){return function(t){return t.replace(/[0-9]/g,function(a){return e[+a]})}}var gf=/^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;function ys(e){if(!(t=gf.exec(e)))throw new Error("invalid format: "+e);var t;return new Mo({fill:t[1],align:t[2],sign:t[3],symbol:t[4],zero:t[5],width:t[6],comma:t[7],precision:t[8]&&t[8].slice(1),trim:t[9],type:t[10]})}ys.prototype=Mo.prototype;function Mo(e){this.fill=e.fill===void 0?" ":e.fill+"",this.align=e.align===void 0?">":e.align+"",this.sign=e.sign===void 0?"-":e.sign+"",this.symbol=e.symbol===void 0?"":e.symbol+"",this.zero=!!e.zero,this.width=e.width===void 0?void 0:+e.width,this.comma=!!e.comma,this.precision=e.precision===void 0?void 0:+e.precision,this.trim=!!e.trim,this.type=e.type===void 0?"":e.type+""}Mo.prototype.toString=function(){return this.fill+this.align+this.sign+this.symbol+(this.zero?"0":"")+(this.width===void 0?"":Math.max(1,this.width|0))+(this.comma?",":"")+(this.precision===void 0?"":"."+Math.max(0,this.precision|0))+(this.trim?"~":"")+this.type};function yf(e){e:for(var t=e.length,a=1,s=-1,o;a<t;++a)switch(e[a]){case".":s=o=a;break;case"0":s===0&&(s=a),o=a;break;default:if(!+e[a])break e;s>0&&(s=0);break}return s>0?e.slice(0,s)+e.slice(o+1):e}var Ei;function $f(e,t){var a=gs(e,t);if(!a)return e+"";var s=a[0],o=a[1],c=o-(Ei=Math.max(-8,Math.min(8,Math.floor(o/3)))*3)+1,p=s.length;return c===p?s:c>p?s+new Array(c-p+1).join("0"):c>0?s.slice(0,c)+"."+s.slice(c):"0."+new Array(1-c).join("0")+gs(e,Math.max(0,t+c-1))[0]}function li(e,t){var a=gs(e,t);if(!a)return e+"";var s=a[0],o=a[1];return o<0?"0."+new Array(-o).join("0")+s:s.length>o+1?s.slice(0,o+1)+"."+s.slice(o+1):s+new Array(o-s.length+2).join("0")}const hi={"%":(e,t)=>(e*100).toFixed(t),b:e=>Math.round(e).toString(2),c:e=>e+"",d:bf,e:(e,t)=>e.toExponential(t),f:(e,t)=>e.toFixed(t),g:(e,t)=>e.toPrecision(t),o:e=>Math.round(e).toString(8),p:(e,t)=>li(e*100,t),r:li,s:$f,X:e=>Math.round(e).toString(16).toUpperCase(),x:e=>Math.round(e).toString(16)};function ui(e){return e}var fi=Array.prototype.map,mi=["y","z","a","f","p","n","\xB5","m","","k","M","G","T","P","E","Z","Y"];function kf(e){var t=e.grouping===void 0||e.thousands===void 0?ui:vf(fi.call(e.grouping,Number),e.thousands+""),a=e.currency===void 0?"":e.currency[0]+"",s=e.currency===void 0?"":e.currency[1]+"",o=e.decimal===void 0?".":e.decimal+"",c=e.numerals===void 0?ui:wf(fi.call(e.numerals,String)),p=e.percent===void 0?"%":e.percent+"",m=e.minus===void 0?"\u2212":e.minus+"",b=e.nan===void 0?"NaN":e.nan+"";function _(v){v=ys(v);var k=v.fill,$=v.align,A=v.sign,G=v.symbol,j=v.zero,P=v.width,C=v.comma,F=v.precision,S=v.trim,z=v.type;z==="n"?(C=!0,z="g"):hi[z]||(F===void 0&&(F=12),S=!0,z="g"),(j||k==="0"&&$==="=")&&(j=!0,k="0",$="=");var M=G==="$"?a:G==="#"&&/[boxX]/.test(z)?"0"+z.toLowerCase():"",Z=G==="$"?s:/[%p]/.test(z)?p:"",K=hi[z],Q=/[defgprs%]/.test(z);F=F===void 0?6:/[gprs]/.test(z)?Math.max(1,Math.min(21,F)):Math.max(0,Math.min(20,F));function ee(I){var E=M,x=Z,ne,R,L;if(z==="c")x=K(I)+x,I="";else{I=+I;var D=I<0||1/I<0;if(I=isNaN(I)?b:K(Math.abs(I),F),S&&(I=yf(I)),D&&+I==0&&A!=="+"&&(D=!1),E=(D?A==="("?A:m:A==="-"||A==="("?"":A)+E,x=(z==="s"?mi[8+Ei/3]:"")+x+(D&&A==="("?")":""),Q){for(ne=-1,R=I.length;++ne<R;)if(L=I.charCodeAt(ne),48>L||L>57){x=(L===46?o+I.slice(ne+1):I.slice(ne))+x,I=I.slice(0,ne);break}}}C&&!j&&(I=t(I,1/0));var oe=E.length+I.length+x.length,te=oe<P?new Array(P-oe+1).join(k):"";switch(C&&j&&(I=t(te+I,te.length?P-x.length:1/0),te=""),$){case"<":I=E+I+x+te;break;case"=":I=E+te+I+x;break;case"^":I=te.slice(0,oe=te.length>>1)+E+I+x+te.slice(oe);break;default:I=te+E+I+x;break}return c(I)}return ee.toString=function(){return v+""},ee}function N(v,k){var $=_((v=ys(v),v.type="f",v)),A=Math.max(-8,Math.min(8,Math.floor(Tr(k)/3)))*3,G=Math.pow(10,-A),j=mi[8+A/3];return function(P){return $(G*P)+j}}return{format:_,formatPrefix:N}}var ds,Ti,Mi;Nf({thousands:",",grouping:[3],currency:["$",""]});function Nf(e){return ds=kf(e),Ti=ds.format,Mi=ds.formatPrefix,ds}function Ef(e){return Math.max(0,-Tr(Math.abs(e)))}function Tf(e,t){return Math.max(0,Math.max(-8,Math.min(8,Math.floor(Tr(t)/3)))*3-Tr(Math.abs(e)))}function Mf(e,t){return e=Math.abs(e),t=Math.abs(t)-e,Math.max(0,Tr(t)-Tr(e))+1}function Pf(e,t,a,s){var o=Fu(e,t,a),c;switch(s=ys(s==null?",f":s),s.type){case"s":{var p=Math.max(Math.abs(e),Math.abs(t));return s.precision==null&&!isNaN(c=Tf(o,p))&&(s.precision=c),Mi(s,p)}case"":case"e":case"g":case"p":case"r":{s.precision==null&&!isNaN(c=Mf(o,Math.max(Math.abs(e),Math.abs(t))))&&(s.precision=c-(s.type==="e"));break}case"f":case"%":{s.precision==null&&!isNaN(c=Ef(o))&&(s.precision=c-(s.type==="%")*2);break}}return Ti(s)}function Sf(e){var t=e.domain;return e.ticks=function(a){var s=t();return Iu(s[0],s[s.length-1],a==null?10:a)},e.tickFormat=function(a,s){var o=t();return Pf(o[0],o[o.length-1],a==null?10:a,s)},e.nice=function(a){a==null&&(a=10);var s=t(),o=0,c=s.length-1,p=s[o],m=s[c],b,_,N=10;for(m<p&&(_=p,p=m,m=_,_=o,o=c,c=_);N-- >0;){if(_=yi(p,m,a),_===b)return s[o]=p,s[c]=m,t(s);if(_>0)p=Math.floor(p/_)*_,m=Math.ceil(m/_)*_;else if(_<0)p=Math.ceil(p*_)/_,m=Math.floor(m*_)/_;else break;b=_}return e},e}function wo(){var e=_f();return e.copy=function(){return cf(e,wo())},zu.apply(e,arguments),Sf(e)}const go=Math.PI,yo=2*go,qa=1e-6,Af=yo-qa;function $o(){this._x0=this._y0=this._x1=this._y1=null,this._=""}function Pi(){return new $o}$o.prototype=Pi.prototype={constructor:$o,moveTo:function(e,t){this._+="M"+(this._x0=this._x1=+e)+","+(this._y0=this._y1=+t)},closePath:function(){this._x1!==null&&(this._x1=this._x0,this._y1=this._y0,this._+="Z")},lineTo:function(e,t){this._+="L"+(this._x1=+e)+","+(this._y1=+t)},quadraticCurveTo:function(e,t,a,s){this._+="Q"+ +e+","+ +t+","+(this._x1=+a)+","+(this._y1=+s)},bezierCurveTo:function(e,t,a,s,o,c){this._+="C"+ +e+","+ +t+","+ +a+","+ +s+","+(this._x1=+o)+","+(this._y1=+c)},arcTo:function(e,t,a,s,o){e=+e,t=+t,a=+a,s=+s,o=+o;var c=this._x1,p=this._y1,m=a-e,b=s-t,_=c-e,N=p-t,v=_*_+N*N;if(o<0)throw new Error("negative radius: "+o);if(this._x1===null)this._+="M"+(this._x1=e)+","+(this._y1=t);else if(v>qa)if(!(Math.abs(N*m-b*_)>qa)||!o)this._+="L"+(this._x1=e)+","+(this._y1=t);else{var k=a-c,$=s-p,A=m*m+b*b,G=k*k+$*$,j=Math.sqrt(A),P=Math.sqrt(v),C=o*Math.tan((go-Math.acos((A+v-G)/(2*j*P)))/2),F=C/P,S=C/j;Math.abs(F-1)>qa&&(this._+="L"+(e+F*_)+","+(t+F*N)),this._+="A"+o+","+o+",0,0,"+ +(N*k>_*$)+","+(this._x1=e+S*m)+","+(this._y1=t+S*b)}},arc:function(e,t,a,s,o,c){e=+e,t=+t,a=+a,c=!!c;var p=a*Math.cos(s),m=a*Math.sin(s),b=e+p,_=t+m,N=1^c,v=c?s-o:o-s;if(a<0)throw new Error("negative radius: "+a);this._x1===null?this._+="M"+b+","+_:(Math.abs(this._x1-b)>qa||Math.abs(this._y1-_)>qa)&&(this._+="L"+b+","+_),a&&(v<0&&(v=v%yo+yo),v>Af?this._+="A"+a+","+a+",0,1,"+N+","+(e-p)+","+(t-m)+"A"+a+","+a+",0,1,"+N+","+(this._x1=b)+","+(this._y1=_):v>qa&&(this._+="A"+a+","+a+",0,"+ +(v>=go)+","+N+","+(this._x1=e+a*Math.cos(o))+","+(this._y1=t+a*Math.sin(o))))},rect:function(e,t,a,s){this._+="M"+(this._x0=this._x1=+e)+","+(this._y0=this._y1=+t)+"h"+ +a+"v"+ +s+"h"+-a+"Z"},toString:function(){return this._}};function $r(e){return function(){return e}}function xf(e){return typeof e=="object"&&"length"in e?e:Array.from(e)}function Si(e){this._context=e}Si.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._point=0},lineEnd:function(){(this._line||this._line!==0&&this._point===1)&&this._context.closePath(),this._line=1-this._line},point:function(e,t){switch(e=+e,t=+t,this._point){case 0:this._point=1,this._line?this._context.lineTo(e,t):this._context.moveTo(e,t);break;case 1:this._point=2;default:this._context.lineTo(e,t);break}}};function qf(e){return new Si(e)}function Hf(e){return e[0]}function Lf(e){return e[1]}function If(e,t){var a=$r(!0),s=null,o=qf,c=null;e=typeof e=="function"?e:e===void 0?Hf:$r(e),t=typeof t=="function"?t:t===void 0?Lf:$r(t);function p(m){var b,_=(m=xf(m)).length,N,v=!1,k;for(s==null&&(c=o(k=Pi())),b=0;b<=_;++b)!(b<_&&a(N=m[b],b,m))===v&&((v=!v)?c.lineStart():c.lineEnd()),v&&c.point(+e(N,b,m),+t(N,b,m));if(k)return c=null,k+""||null}return p.x=function(m){return arguments.length?(e=typeof m=="function"?m:$r(+m),p):e},p.y=function(m){return arguments.length?(t=typeof m=="function"?m:$r(+m),p):t},p.defined=function(m){return arguments.length?(a=typeof m=="function"?m:$r(!!m),p):a},p.curve=function(m){return arguments.length?(o=m,s!=null&&(c=o(s)),p):o},p.context=function(m){return arguments.length?(m==null?s=c=null:c=o(s=m),p):s},p}function pi(e,t,a){const s=e.slice();return s[10]=t[a],s}function ci(e,t,a){const s=e.slice();return s[10]=t[a],s}function di(e){let t,a,s,o=e[10]+"",c,p;return{c(){t=ka("g"),a=ka("line"),s=ka("text"),c=i(o),this.h()},l(m){t=Na(m,"g",{transform:!0});var b=f(t);a=Na(b,"line",{y2:!0,stroke:!0,class:!0}),f(a).forEach(r),s=Na(b,"text",{"font-size":!0,"text-anchor":!0,y:!0});var _=f(s);c=l(_,o),_.forEach(r),b.forEach(r),this.h()},h(){V(a,"y2","3"),V(a,"stroke","black"),V(a,"class","svelte-e941bf"),V(s,"font-size","5"),V(s,"text-anchor","middle"),V(s,"y","8"),V(t,"transform",p=`translate(${e[5](e[10]).toPrecision(3)}, 102)`)},m(m,b){y(m,t,b),n(t,a),n(t,s),n(s,c)},p(m,b){b&288&&o!==(o=m[10]+"")&&ko(c,o),b&288&&p!==(p=`translate(${m[5](m[10]).toPrecision(3)}, 102)`)&&V(t,"transform",p)},d(m){m&&r(t)}}}function _i(e){let t,a,s,o=e[10]+"",c,p;return{c(){t=ka("g"),a=ka("line"),s=ka("text"),c=i(o),this.h()},l(m){t=Na(m,"g",{transform:!0});var b=f(t);a=Na(b,"line",{x2:!0,stroke:!0,class:!0}),f(a).forEach(r),s=Na(b,"text",{"font-size":!0,"text-anchor":!0,x:!0,y:!0});var _=f(s);c=l(_,o),_.forEach(r),b.forEach(r),this.h()},h(){V(a,"x2","-3"),V(a,"stroke","black"),V(a,"class","svelte-e941bf"),V(s,"font-size","5"),V(s,"text-anchor","end"),V(s,"x","-6"),V(s,"y","1.5"),V(t,"transform",p=`translate(-2, ${e[4](e[10]).toPrecision(3)})`)},m(m,b){y(m,t,b),n(t,a),n(t,s),n(s,c)},p(m,b){b&272&&o!==(o=m[10]+"")&&ko(c,o),b&272&&p!==(p=`translate(-2, ${m[4](m[10]).toPrecision(3)})`)&&V(t,"transform",p)},d(m){m&&r(t)}}}function bi(e){let t,a,s,o;return{c(){t=ka("path"),this.h()},l(c){t=Na(c,"path",{d:!0,stroke:!0,class:!0}),f(t).forEach(r),this.h()},h(){V(t,"d",a=e[7](e[0])),V(t,"stroke",e[2]),V(t,"class","svelte-e941bf")},m(c,p){y(c,t,p),o=!0},p(c,p){(!o||p&129&&a!==(a=c[7](c[0])))&&V(t,"d",a),(!o||p&4)&&V(t,"stroke",c[2])},i(c){o||(wi(()=>{s||(s=Uo(t,Ko,{duration:2e3},!0)),s.run(1)}),o=!0)},o(c){s||(s=Uo(t,Ko,{duration:2e3},!1)),s.run(0),o=!1},d(c){c&&r(t),c&&s&&s.end()}}}function Ff(e){let t,a,s,o,c,p=e[5].ticks(ms(e[8],10)),m=[];for(let v=0;v<p.length;v+=1)m[v]=di(ci(e,p,v));let b=e[4].ticks(ms(e[8],7)),_=[];for(let v=0;v<b.length;v+=1)_[v]=_i(pi(e,b,v));let N=e[1]&&bi(e);return{c(){t=ka("svg");for(let v=0;v<m.length;v+=1)m[v].c();a=kr();for(let v=0;v<_.length;v+=1)_[v].c();s=kr(),N&&N.c(),this.h()},l(v){t=Na(v,"svg",{width:!0,height:!0,viewBox:!0});var k=f(t);for(let $=0;$<m.length;$+=1)m[$].l(k);a=kr();for(let $=0;$<_.length;$+=1)_[$].l(k);s=kr(),N&&N.l(k),k.forEach(r),this.h()},h(){V(t,"width","100%"),V(t,"height",e[3]),V(t,"viewBox",o="-15 -10 "+(e[6]+15)+" 120")},m(v,k){y(v,t,k);for(let $=0;$<m.length;$+=1)m[$].m(t,null);n(t,a);for(let $=0;$<_.length;$+=1)_[$].m(t,null);n(t,s),N&&N.m(t,null),c=!0},p(v,[k]){if(k&288){p=v[5].ticks(ms(v[8],10));let $;for($=0;$<p.length;$+=1){const A=ci(v,p,$);m[$]?m[$].p(A,k):(m[$]=di(A),m[$].c(),m[$].m(t,a))}for(;$<m.length;$+=1)m[$].d(1);m.length=p.length}if(k&272){b=v[4].ticks(ms(v[8],7));let $;for($=0;$<b.length;$+=1){const A=pi(v,b,$);_[$]?_[$].p(A,k):(_[$]=_i(A),_[$].c(),_[$].m(t,s))}for(;$<_.length;$+=1)_[$].d(1);_.length=b.length}v[1]?N?(N.p(v,k),k&2&&fe(N,1)):(N=bi(v),N.c(),fe(N,1),N.m(t,null)):N&&(Sh(),be(N,1,1,()=>{N=null}),Ah()),(!c||k&8)&&V(t,"height",v[3]),(!c||k&64&&o!==(o="-15 -10 "+(v[6]+15)+" 120"))&&V(t,"viewBox",o)},i(v){c||(fe(N),c=!0)},o(v){be(N),c=!1},d(v){v&&r(t),Go(m,v),Go(_,v),N&&N.d()}}}function zf(e,t,a){let s,o,c,p,m,{data:b}=t,{show:_}=t,{strokeColor:N="#8A2BE2"}=t,{height:v=300}=t,{aspectRatio:k=2}=t;return e.$$set=$=>{"data"in $&&a(0,b=$.data),"show"in $&&a(1,_=$.show),"strokeColor"in $&&a(2,N=$.strokeColor),"height"in $&&a(3,v=$.height),"aspectRatio"in $&&a(9,k=$.aspectRatio)},e.$$.update=()=>{e.$$.dirty&1&&a(8,s=b.length),e.$$.dirty&512&&a(6,o=k*100),e.$$.dirty&65&&a(5,c=wo().domain(Yo(b.map($=>$.x))).range([0,o])),e.$$.dirty&1&&a(4,p=wo().domain(Yo(b.map($=>$.y))).range([0,100])),e.$$.dirty&48&&a(7,m=If().x($=>c($.x)).y($=>p($.y)))},[b,_,N,v,p,c,o,m,s,k]}class vi extends rn{constructor(t){super(),sn(this,t,zf,Ff,on,{data:0,show:1,strokeColor:2,height:3,aspectRatio:9})}}function Vf(e){let t,a,s,o,c,p,m=d(`x = ${e[0]}`)+"",b,_,N,v,k,$,A,G,j,P,C,F,S,z,M,Z,K,Q,ee,I,E,x,ne,R;return t=new Pu({}),M=new vi({props:{data:e[3],show:!0,aspectRatio:3}}),E=new vi({props:{data:e[2],show:!0,aspectRatio:3,strokeColor:"#A0522D"}}),{c(){ge(t.$$.fragment),a=q(),s=h("div"),o=h("div"),c=h("div"),p=h("span"),b=q(),_=h("input"),N=q(),v=h("div"),k=h("span"),$=i(e[1]),A=i(" qubits"),G=q(),j=h("input"),P=q(),C=h("div"),F=h("p"),S=i("Real part"),z=q(),ge(M.$$.fragment),Z=q(),K=h("div"),Q=h("p"),ee=i("Imaginary part"),I=q(),ge(E.$$.fragment),this.h()},l(L){ye(t.$$.fragment,L),a=H(L),s=u(L,"DIV",{class:!0});var D=f(s);o=u(D,"DIV",{class:!0});var oe=f(o);c=u(oe,"DIV",{class:!0});var te=f(c);p=u(te,"SPAN",{class:!0});var Pe=f(p);Pe.forEach(r),b=H(te),_=u(te,"INPUT",{type:!0,min:!0,max:!0,step:!0,class:!0}),te.forEach(r),N=H(oe),v=u(oe,"DIV",{class:!0});var ae=f(v);k=u(ae,"SPAN",{class:!0});var W=f(k);$=l(W,e[1]),A=l(W," qubits"),W.forEach(r),G=H(ae),j=u(ae,"INPUT",{type:!0,min:!0,max:!0,step:!0,class:!0}),ae.forEach(r),oe.forEach(r),P=H(D),C=u(D,"DIV",{class:!0});var T=f(C);F=u(T,"P",{});var U=f(F);S=l(U,"Real part"),U.forEach(r),z=H(T),ye(M.$$.fragment,T),T.forEach(r),Z=H(D),K=u(D,"DIV",{});var J=f(K);Q=u(J,"P",{});var Se=f(Q);ee=l(Se,"Imaginary part"),Se.forEach(r),I=H(J),ye(E.$$.fragment,J),J.forEach(r),D.forEach(r),this.h()},h(){V(p,"class","label svelte-1k89lhb"),V(_,"type","range"),V(_,"min",0),V(_,"max",10),V(_,"step",1),V(_,"class","svelte-1k89lhb"),V(c,"class","col-lg-6 col-sm-12"),V(k,"class","label svelte-1k89lhb"),V(j,"type","range"),V(j,"min",3),V(j,"max",10),V(j,"step",1),V(j,"class","svelte-1k89lhb"),V(v,"class","col-lg-6 col-sm-12"),V(o,"class","row"),V(C,"class","mb-3"),V(s,"class","interaction container")},m(L,D){$e(t,L,D),y(L,a,D),y(L,s,D),n(s,o),n(o,c),n(c,p),p.innerHTML=m,n(c,b),n(c,_),en(_,e[0]),n(o,N),n(o,v),n(v,k),n(k,$),n(k,A),n(v,G),n(v,j),en(j,e[1]),n(s,P),n(s,C),n(C,F),n(F,S),n(C,z),$e(M,C,null),n(s,Z),n(s,K),n(K,Q),n(Q,ee),n(K,I),$e(E,K,null),x=!0,ne||(R=[w(_,"change",e[6]),w(_,"input",e[6]),w(j,"change",e[7]),w(j,"input",e[7])],ne=!0)},p(L,[D]){(!x||D&1)&&m!==(m=d(`x = ${L[0]}`)+"")&&(p.innerHTML=m),D&1&&en(_,L[0]),(!x||D&2)&&ko($,L[1]),D&2&&en(j,L[1]);const oe={};D&8&&(oe.data=L[3]),M.$set(oe);const te={};D&4&&(te.data=L[2]),E.$set(te)},i(L){x||(fe(t.$$.fragment,L),fe(M.$$.fragment,L),fe(E.$$.fragment,L),x=!0)},o(L){be(t.$$.fragment,L),be(M.$$.fragment,L),be(E.$$.fragment,L),x=!1},d(L){ke(t,L),L&&r(a),L&&r(s),ke(M),ke(E),ne=!1,jn(R)}}}function Cf(e,t,a){let s,o,c,p,m,b;function _(){o=na(this.value),a(0,o)}function N(){s=na(this.value),a(1,s)}return e.$$.update=()=>{e.$$.dirty&2&&a(5,c=Oo(2,s)),e.$$.dirty&33&&a(4,b=[...Array(c).keys()].map(v=>Oo(qh,Hh(2*fo*o*v/c,Lh)))),e.$$.dirty&16&&a(3,p=b.map((v,k)=>({x:k,y:v.im}))),e.$$.dirty&16&&a(2,m=b.map((v,k)=>({x:k,y:v.re})))},a(1,s=3),a(0,o=9),[o,s,m,p,b,c,_,N]}class Bf extends rn{constructor(t){super(),sn(this,t,Cf,Vf,on,{})}}const Rf='<a href="https://en.wikipedia.org/wiki/Projection_(linear_algebra)"><h3>Projection (linear algebra)</h3></a><p>In linear algebra and functional analysis, a <b>projection</b> is a linear transformation <span class="mwe-math-element"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/b4dc73bf40314945ff376bd363916a738548d40a" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align:-0.338ex;width:1.745ex;height:2.176ex" /></span> from a vector space to itself such that <span class="mwe-math-element"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/5369d895625034bc50c9f28975e3293ef6f2105b" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align:-0.338ex;width:10.529ex;height:2.176ex" /></span>. That is, whenever <span class="mwe-math-element"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/b4dc73bf40314945ff376bd363916a738548d40a" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align:-0.338ex;width:1.745ex;height:2.176ex" /></span> is applied twice to any vector, it gives the same result as if it were applied once. It leaves its image unchanged. This definition of "projection" formalizes and generalizes the idea of graphical projection. One can also consider the effect of a projection on a geometrical object by examining the effect of the projection on points in the object.</p>',Qf='<a href="https://en.wikipedia.org/wiki/Bloch_sphere"><h3>Bloch sphere</h3></a><p>In quantum mechanics and computing, the <b>Bloch sphere</b> is a geometrical representation of the pure state space of a two-level quantum mechanical system (qubit), named after the physicist Felix Bloch.</p>',jf='<a href="https://en.wikipedia.org/wiki/Degrees_of_freedom"><h3>Degrees of freedom</h3></a><p><b>Degrees of freedom</b> refers to the number of independent variables or parameters of a system. In various scientific fields, the word "freedom" is used to describe the limits to which physical movement or other physical processes are possible. This relates to the philosophical concept to the extent that people may be considered to have as much freedom as they are physically able to exercise.</p>',Df='<a href="https://en.wikipedia.org/wiki/Phase_factor"><h3>Phase factor</h3></a><p>For any complex number written in polar form, the <b>phase factor</b> is the complex exponential factor. As such, the term "phase factor" is related to the more general term phasor, which may have any magnitude. The phase factor is a unit complex number, i.e. a complex number of absolute value 1. It is commonly used in quantum mechanics.</p>';function Wf(e){let t;return{c(){t=i("projection")},l(a){t=l(a,"projection")},m(a,s){y(a,t,s)},d(a){a&&r(t)}}}function Gf(e){let t;return{c(){t=i("Bloch sphere")},l(a){t=l(a,"Bloch sphere")},m(a,s){y(a,t,s)},d(a){a&&r(t)}}}function Uf(e){let t;return{c(){t=i("degrees of freedom")},l(a){t=l(a,"degrees of freedom")},m(a,s){y(a,t,s)},d(a){a&&r(t)}}}function Of(e){let t;return{c(){t=i("phase")},l(a){t=l(a,"phase")},m(a,s){y(a,t,s)},d(a){a&&r(t)}}}function Kf(e){let t,a,s,o,c,p,m=d("\\alpha")+"",b,_,N=d("\\beta")+"",v,k,$=d("\\alpha = \\Vert{\\alpha}\\Vert \\cdot e^{i \\phi_{\\alpha}}")+"",A,G,j=d("\\beta = \\Vert{\\beta}\\Vert \\cdot e^{i \\phi_{\\beta}}")+"",P,C,F=d("\\Vert{\\alpha}\\Vert \\cdot e^{i \\phi_{\\alpha}} |0\\rangle + \\Vert{\\beta}\\Vert \\cdot e^{i \\phi_{\\beta}} |1\\rangle")+"",S,z,M,Z,K,Q=d("e^{i \\phi_{\\alpha}}")+"",ee,I,E=d("\\Vert{e^{i \\phi_{\\alpha}}}\\Vert^2")+"",x,ne,R=d("1")+"",L,D,oe=d("\\phi_{\\alpha}")+"",te,Pe,ae=d("\\phi_{\\beta}")+"",W,T,U=d("e^{i \\phi_{\\alpha}}")+"",J,Se,Ne=d("\\Vert{\\alpha}\\Vert \\cdot |0\\rangle + \\Vert{\\beta}\\Vert \\cdot \\frac{e^{i \\phi_{\\beta}}}{e^{i \\phi_{\\alpha}}} |1\\rangle")+"",Le,Ie,Ae=d("\\frac{e^{i \\phi_{\\beta}}}{e^{i \\phi_{\\alpha}}} = e^{i (\\phi_{\\beta} - \\phi_{\\alpha})}")+"",Re,Ce,rt=d("\\phi = \\phi_{\\beta} - \\phi_{\\alpha}")+"",Qe,Ee,gt=d("\\Vert{\\alpha}\\Vert \\cdot |0\\rangle + \\Vert{\\beta}\\Vert \\cdot e^{i \\phi} |1\\rangle")+"",Te,We,he,Ge,dt,we=d("\\Vert{\\alpha}\\Vert^2 + \\Vert{\\beta}\\Vert^2 = 1")+"",ht,de,re=d("\\theta")+"",_e,X,_t=d("\\cos{(\\frac{\\theta}{2})} \\cdot |0 \\rangle + \\sin{(\\frac{\\theta}{2})} \\cdot e^{i \\phi} |1 \\rangle")+"",st,Ue,bt=d("\\theta")+"",ot,Je,At=d("\\phi")+"",ie,ze,le=d("\\theta")+"",Nt,vt,Et=d("z")+"",Oe,Tt,Kt=d("\\phi")+"",Vt,yt,Ct,Mt,dn=d("x-y")+"",$t,Xe,xt,wt,Ye,nt,ut,Me,Pt,ft=d("\\theta")+"",_n,kt,It=d("\\phi")+"",bn,mt,Zt,ln,Dt,Ve;return yt=new at({props:{hovertext:Rf,$$slots:{default:[Wf]},$$scope:{ctx:e}}}),Xe=new at({props:{hovertext:Qf,$$slots:{default:[Gf]},$$scope:{ctx:e}}}),ut=new at({props:{hovertext:jf,$$slots:{default:[Uf]},$$scope:{ctx:e}}}),mt=new at({props:{hovertext:Df,$$slots:{default:[Of]},$$scope:{ctx:e}}}),{c(){t=h("h2"),a=i("The Bloch-sphere"),s=q(),o=h("p"),c=i("As the coefficients "),p=h("span"),b=i(" and "),_=h("span"),v=i(" are complex numbers, they can be expressed in the form "),k=h("span"),A=i(" and "),G=h("span"),P=i(". Thus, the state of the qubit can be rewritten as "),C=h("span"),S=i("."),z=q(),M=h("p"),Z=i("Remember that "),K=h("span"),ee=i(" is a unit vector rotated around the origin, and therefore the square of its norm "),I=h("span"),x=i(" also equals to "),ne=h("span"),L=i(". This means that we can modify the angles "),D=h("span"),te=i(" and "),Pe=h("span"),W=i(" freely without affecting the measurement probabilities. Therefore, we can do an algebraic trick to simplify the expression above. Namely, let's divide the state by "),T=h("span"),J=i(" to obtain "),Se=h("span"),Le=i(". By the rules of exponentiation, "),Ie=h("span"),Re=i(". Next, let's introduce a new variable "),Ce=h("span"),Qe=i(", with the help of which the state can be further simplified to "),Ee=h("span"),Te=i("."),We=q(),he=h("p"),Ge=i("We know that "),dt=h("span"),ht=i(". Consequently, these two numbers can also be represented geometrically as vector of unit length rotated around the origin by some angle, the double of which we'll denote as "),de=h("span"),_e=i(". Using trigonometry, we can now rewrite the state as "),X=h("span"),st=i(". Notice that we now only need two variables to express the state of the qubit: the angles "),Ue=h("span"),ot=i(" and "),Je=h("span"),ie=i(". Geometrically, this can be represented as a vector pointing to the surface of 3-dimensional sphere with unit radius, where "),ze=h("span"),Nt=i(" is the angle of the vector and the "),vt=h("span"),Oe=i(" axis, and "),Tt=h("span"),Vt=i(" is the angle of the vertical "),ge(yt.$$.fragment),Ct=i(" of the vector on the "),Mt=h("span"),$t=i(" plane. This representation of qubit states is called the "),ge(Xe.$$.fragment),xt=i("."),wt=q(),Ye=h("p"),nt=i("It's important to note that of the two "),ge(ut.$$.fragment),Me=i(" on the Bloch sphere, only the angle "),Pt=h("span"),_n=i(" is related to measurement probabilities. "),kt=h("span"),bn=i(" is an inherently quantum property called the "),ge(mt.$$.fragment),Zt=i(" that does not have physical manifestation directly observable to us. Because of this, it's hard to find any intuitive analogy from everyday life that could help us understand what exactly the phase is. The most useful approach in this context is to look at the phase as a matematical property of quantum objects that we can leverage to design clever algorithms.")},l(se){t=u(se,"H2",{});var Be=f(t);a=l(Be,"The Bloch-sphere"),Be.forEach(r),s=H(se),o=u(se,"P",{});var Ze=f(o);c=l(Ze,"As the coefficients "),p=u(Ze,"SPAN",{});var $n=f(p);$n.forEach(r),b=l(Ze," and "),_=u(Ze,"SPAN",{});var Ft=f(_);Ft.forEach(r),v=l(Ze," are complex numbers, they can be expressed in the form "),k=u(Ze,"SPAN",{});var qt=f(k);qt.forEach(r),A=l(Ze," and "),G=u(Ze,"SPAN",{});var ra=f(G);ra.forEach(r),P=l(Ze,". Thus, the state of the qubit can be rewritten as "),C=u(Ze,"SPAN",{});var Yt=f(C);Yt.forEach(r),S=l(Ze,"."),Ze.forEach(r),z=H(se),M=u(se,"P",{});var qe=f(M);Z=l(qe,"Remember that "),K=u(qe,"SPAN",{});var Ln=f(K);Ln.forEach(r),ee=l(qe," is a unit vector rotated around the origin, and therefore the square of its norm "),I=u(qe,"SPAN",{});var Wt=f(I);Wt.forEach(r),x=l(qe," also equals to "),ne=u(qe,"SPAN",{});var me=f(ne);me.forEach(r),L=l(qe,". This means that we can modify the angles "),D=u(qe,"SPAN",{});var In=f(D);In.forEach(r),te=l(qe," and "),Pe=u(qe,"SPAN",{});var Gt=f(Pe);Gt.forEach(r),W=l(qe," freely without affecting the measurement probabilities. Therefore, we can do an algebraic trick to simplify the expression above. Namely, let's divide the state by "),T=u(qe,"SPAN",{});var hn=f(T);hn.forEach(r),J=l(qe," to obtain "),Se=u(qe,"SPAN",{});var Dn=f(Se);Dn.forEach(r),Le=l(qe,". By the rules of exponentiation, "),Ie=u(qe,"SPAN",{});var ue=f(Ie);ue.forEach(r),Re=l(qe,". Next, let's introduce a new variable "),Ce=u(qe,"SPAN",{});var pt=f(Ce);pt.forEach(r),Qe=l(qe,", with the help of which the state can be further simplified to "),Ee=u(qe,"SPAN",{});var Bt=f(Ee);Bt.forEach(r),Te=l(qe,"."),qe.forEach(r),We=H(se),he=u(se,"P",{});var pe=f(he);Ge=l(pe,"We know that "),dt=u(pe,"SPAN",{});var vn=f(dt);vn.forEach(r),ht=l(pe,". Consequently, these two numbers can also be represented geometrically as vector of unit length rotated around the origin by some angle, the double of which we'll denote as "),de=u(pe,"SPAN",{});var He=f(de);He.forEach(r),_e=l(pe,". Using trigonometry, we can now rewrite the state as "),X=u(pe,"SPAN",{});var Fn=f(X);Fn.forEach(r),st=l(pe,". Notice that we now only need two variables to express the state of the qubit: the angles "),Ue=u(pe,"SPAN",{});var Ut=f(Ue);Ut.forEach(r),ot=l(pe," and "),Je=u(pe,"SPAN",{});var Ea=f(Je);Ea.forEach(r),ie=l(pe,". Geometrically, this can be represented as a vector pointing to the surface of 3-dimensional sphere with unit radius, where "),ze=u(pe,"SPAN",{});var zn=f(ze);zn.forEach(r),Nt=l(pe," is the angle of the vector and the "),vt=u(pe,"SPAN",{});var tn=f(vt);tn.forEach(r),Oe=l(pe," axis, and "),Tt=u(pe,"SPAN",{});var kn=f(Tt);kn.forEach(r),Vt=l(pe," is the angle of the vertical "),ye(yt.$$.fragment,pe),Ct=l(pe," of the vector on the "),Mt=u(pe,"SPAN",{});var un=f(Mt);un.forEach(r),$t=l(pe," plane. This representation of qubit states is called the "),ye(Xe.$$.fragment,pe),xt=l(pe,"."),pe.forEach(r),wt=H(se),Ye=u(se,"P",{});var St=f(Ye);nt=l(St,"It's important to note that of the two "),ye(ut.$$.fragment,St),Me=l(St," on the Bloch sphere, only the angle "),Pt=u(St,"SPAN",{});var Vn=f(Pt);Vn.forEach(r),_n=l(St," is related to measurement probabilities. "),kt=u(St,"SPAN",{});var it=f(kt);it.forEach(r),bn=l(St," is an inherently quantum property called the "),ye(mt.$$.fragment,St),Zt=l(St," that does not have physical manifestation directly observable to us. Because of this, it's hard to find any intuitive analogy from everyday life that could help us understand what exactly the phase is. The most useful approach in this context is to look at the phase as a matematical property of quantum objects that we can leverage to design clever algorithms."),St.forEach(r)},m(se,Be){y(se,t,Be),n(t,a),y(se,s,Be),y(se,o,Be),n(o,c),n(o,p),p.innerHTML=m,n(o,b),n(o,_),_.innerHTML=N,n(o,v),n(o,k),k.innerHTML=$,n(o,A),n(o,G),G.innerHTML=j,n(o,P),n(o,C),C.innerHTML=F,n(o,S),y(se,z,Be),y(se,M,Be),n(M,Z),n(M,K),K.innerHTML=Q,n(M,ee),n(M,I),I.innerHTML=E,n(M,x),n(M,ne),ne.innerHTML=R,n(M,L),n(M,D),D.innerHTML=oe,n(M,te),n(M,Pe),Pe.innerHTML=ae,n(M,W),n(M,T),T.innerHTML=U,n(M,J),n(M,Se),Se.innerHTML=Ne,n(M,Le),n(M,Ie),Ie.innerHTML=Ae,n(M,Re),n(M,Ce),Ce.innerHTML=rt,n(M,Qe),n(M,Ee),Ee.innerHTML=gt,n(M,Te),y(se,We,Be),y(se,he,Be),n(he,Ge),n(he,dt),dt.innerHTML=we,n(he,ht),n(he,de),de.innerHTML=re,n(he,_e),n(he,X),X.innerHTML=_t,n(he,st),n(he,Ue),Ue.innerHTML=bt,n(he,ot),n(he,Je),Je.innerHTML=At,n(he,ie),n(he,ze),ze.innerHTML=le,n(he,Nt),n(he,vt),vt.innerHTML=Et,n(he,Oe),n(he,Tt),Tt.innerHTML=Kt,n(he,Vt),$e(yt,he,null),n(he,Ct),n(he,Mt),Mt.innerHTML=dn,n(he,$t),$e(Xe,he,null),n(he,xt),y(se,wt,Be),y(se,Ye,Be),n(Ye,nt),$e(ut,Ye,null),n(Ye,Me),n(Ye,Pt),Pt.innerHTML=ft,n(Ye,_n),n(Ye,kt),kt.innerHTML=It,n(Ye,bn),$e(mt,Ye,null),n(Ye,Zt),ln=!0,Dt||(Ve=[w(p,"mouseenter",e[0]),w(_,"mouseenter",e[1]),w(k,"mouseenter",e[2]),w(G,"mouseenter",e[3]),w(C,"mouseenter",e[4]),w(K,"mouseenter",e[5]),w(I,"mouseenter",e[6]),w(ne,"mouseenter",e[7]),w(D,"mouseenter",e[8]),w(Pe,"mouseenter",e[9]),w(T,"mouseenter",e[10]),w(Se,"mouseenter",e[11]),w(Ie,"mouseenter",e[12]),w(Ce,"mouseenter",e[13]),w(Ee,"mouseenter",e[14]),w(dt,"mouseenter",e[15]),w(de,"mouseenter",e[16]),w(X,"mouseenter",e[17]),w(Ue,"mouseenter",e[18]),w(Je,"mouseenter",e[19]),w(ze,"mouseenter",e[20]),w(vt,"mouseenter",e[21]),w(Tt,"mouseenter",e[22]),w(Mt,"mouseenter",e[23]),w(Pt,"mouseenter",e[24]),w(kt,"mouseenter",e[25])],Dt=!0)},p(se,[Be]){const Ze={};Be&67108864&&(Ze.$$scope={dirty:Be,ctx:se}),yt.$set(Ze);const $n={};Be&67108864&&($n.$$scope={dirty:Be,ctx:se}),Xe.$set($n);const Ft={};Be&67108864&&(Ft.$$scope={dirty:Be,ctx:se}),ut.$set(Ft);const qt={};Be&67108864&&(qt.$$scope={dirty:Be,ctx:se}),mt.$set(qt)},i(se){ln||(fe(yt.$$.fragment,se),fe(Xe.$$.fragment,se),fe(ut.$$.fragment,se),fe(mt.$$.fragment,se),ln=!0)},o(se){be(yt.$$.fragment,se),be(Xe.$$.fragment,se),be(ut.$$.fragment,se),be(mt.$$.fragment,se),ln=!1},d(se){se&&r(t),se&&r(s),se&&r(o),se&&r(z),se&&r(M),se&&r(We),se&&r(he),ke(yt),ke(Xe),se&&r(wt),se&&r(Ye),ke(ut),ke(mt),Dt=!1,jn(Ve)}}}function ct(e){console.log(e)}function Zf(e){return[()=>ct(["\\alpha"]),()=>ct(["\\beta"]),()=>ct(["\\alpha","\\phi"]),()=>ct(["\\beta","\\phi"]),()=>ct(["\\beta","\\alpha","\\phi"]),()=>ct(["\\alpha","\\phi"]),()=>ct(["\\alpha","\\phi"]),()=>ct([]),()=>ct(["\\alpha","\\phi"]),()=>ct(["\\beta","\\phi"]),()=>ct(["\\alpha","\\phi"]),()=>ct(["\\beta","\\alpha","\\phi"]),()=>ct(["\\beta","\\alpha","\\phi"]),()=>ct(["\\beta","\\alpha","\\phi"]),()=>ct(["\\beta","\\alpha","\\phi"]),()=>ct(["\\beta","\\alpha"]),()=>ct(["\\theta"]),()=>ct(["\\theta","\\phi"]),()=>ct(["\\theta"]),()=>ct(["\\phi"]),()=>ct(["\\theta"]),()=>ct(["z"]),()=>ct(["\\phi"]),()=>ct(["x","y"]),()=>ct(["\\theta"]),()=>ct(["\\phi"])]}class Yf extends rn{constructor(t){super(),sn(this,t,Zf,Kf,on,{})}}const Jf='<a href="https://en.wikipedia.org/wiki/Complex_number"><h3 class="text-lg font-semibold">Complex number</h3></a><p>In mathematics, a <b>complex number</b> is an element of a number system that extends the real numbers with a specific element denoted <span class="texhtml mvar" style="font-style:italic">i</span>, called the imaginary unit and satisfying the equation <span class="texhtml "><i>i</i><sup>2</sup> = \u22121</span>; every complex number can be expressed in the form <span class="texhtml "><i>a</i> + <i>bi</i></span>, where <span class="texhtml mvar" style="font-style:italic">a</span> and <span class="texhtml mvar" style="font-style:italic">b</span> are real numbers. Because no real number satisfies the above equation, <span class="texhtml mvar" style="font-style:italic">i</span> was called an imaginary number by Ren\xE9 Descartes. For the complex number <span class="texhtml "><i>a</i> + <i>bi</i></span>, <span class="texhtml mvar" style="font-style:italic">a</span> is called the <b><span class="vanchor"><span class="vanchor-text">real part</span></span></b> and <span class="texhtml mvar" style="font-style:italic">b</span> is called the <b><span class="vanchor"><span class="vanchor-text">imaginary part</span></span></b>. The set of complex numbers is denoted by either of the symbols <span class="mwe-math-element"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f9add4085095b9b6d28d045fd9c92c2c09f549a7" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align:-0.338ex;width:1.678ex;height:2.176ex" /></span> or <span class="texhtml "><b>C</b></span>. Despite the historical nomenclature "imaginary", complex numbers are regarded in the mathematical sciences as just as "real" as the real numbers and are fundamental in many aspects of the scientific description of the natural world.</p>',Xf='<a href="https://en.wikipedia.org/wiki/Imaginary_number"><h3>Imaginary number</h3></a><p>An <b>imaginary number</b> is a real number multiplied by the imaginary unit <span class="texhtml mvar" style="font-style:italic">i</span>, which is defined by its property <span class="texhtml "><i>i</i><sup>2</sup> = \u22121</span>. The square of an imaginary number <span class="texhtml mvar" style="font-style:italic">bi</span> is <span class="texhtml ">\u2212<i>b</i><sup>2</sup></span>. For example, <span class="texhtml ">5<i>i</i></span> is an imaginary number, and its square is <span class="texhtml ">\u221225</span>. By definition, zero is considered to be both real and imaginary.</p>',em='<a href="https://en.wikipedia.org/wiki/Real_number"><h3>Real number</h3></a><p>In mathematics, a <b>real number</b> is a value of a continuous quantity that can represent a distance along a line. The adjective <i>real</i> in this context was introduced in the 17th century by Ren\xE9 Descartes, who distinguished between real and imaginary roots of polynomials. The real numbers include all the rational numbers, such as the integer \u22125 and the fraction 4/3, and all the irrational numbers, such as <span class="mwe-math-element"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/b4afc1e27d418021bf10898eb44a7f5f315735ff" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align:-0.671ex;width:3.098ex;height:3.009ex" /></span>. Included within the irrationals are the real transcendental numbers, such as <span><span class="texhtml mvar" style="font-style:italic">\u03C0</span></span> (3.14159265...). In addition to measuring distance, real numbers can be used to measure quantities such as time, mass, energy, velocity, and many more. The set of real numbers is denoted using the symbol <b>R</b> or <span class="mwe-math-element"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/786849c765da7a84dbc3cce43e96aad58a5868dc" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align:-0.338ex;width:1.678ex;height:2.176ex" /></span> and is sometimes called "the reals".</p>',tm='<a href="https://en.wikipedia.org/wiki/Complex_plane"><h3>Complex plane</h3></a><p>In mathematics, the <b>complex plane</b> is the plane formed by the complex numbers, with a Cartesian coordinate system such that the <span class="texhtml mvar" style="font-style:italic">x</span>-axis, called <b>real axis</b>, is formed by the real numbers, and the <span class="texhtml mvar" style="font-style:italic">y</span>-axis, called <b>imaginary axis</b>, is formed by the imaginary numbers.</p>',nm='<a href="https://en.wikipedia.org/wiki/Bit"><h3 class="text-lg font-semibold">Bit</h3></a><p>The <b>bit</b> is the most basic unit of information in computing and digital communications. The name is a portmanteau of <b>binary digit</b>. The bit represents a logical state with one of two possible values. These values are most commonly represented as either <span class="nowrap">"<span class="monospaced">1</span>" or "<span class="monospaced">0</span>"</span>, but other representations such as <i>true</i>/<i>false</i>, <i>yes</i>/<i>no</i>, <i>on</i>/<i>off</i>, or <i>+</i>/<i>\u2212</i> are also commonly used.</p>',am='<a href="https://en.wikipedia.org/wiki/Information_theory"><h3>Information theory</h3></a><p><b>Information theory</b> is the scientific study of the quantification, storage, and communication of digital information. The field was fundamentally established by the works of Harry Nyquist and Ralph Hartley, in the 1920s, and Claude Shannon in the 1940s. The field is at the intersection of probability theory, statistics, computer science, statistical mechanics, information engineering, and electrical engineering.</p>',rm='<a href="https://en.wikipedia.org/wiki/Qubit"><h3 class="text-lg font-semibold">Qubit</h3></a><p>In quantum computing, a <b>qubit</b> or <b>quantum bit</b> is a basic unit of quantum information\u2014the quantum version of the classic binary bit physically realized with a two-state device. A qubit is a two-state quantum-mechanical system, one of the simplest quantum systems displaying the peculiarity of quantum mechanics. Examples include the spin of the electron in which the two levels can be taken as spin up and spin down; or the polarization of a single photon in which the two states can be taken to be the vertical polarization and the horizontal polarization. In a classical system, a bit would have to be in one state or the other. However, quantum mechanics allows the qubit to be in a coherent superposition of both states simultaneously, a property that is fundamental to quantum mechanics and quantum computing.</p>',sm='<a href="https://en.wikipedia.org/wiki/Measurement_in_quantum_mechanics"><h3>Measurement in quantum mechanics</h3></a><p>In quantum physics, a <b>measurement</b> is the testing or manipulation of a physical system to yield a numerical result. The predictions that quantum physics makes are in general probabilistic. The mathematical tools for making predictions about what measurement outcomes may occur were developed during the 20th century and make use of linear algebra and functional analysis.</p>',om=`<a href="https://en.wikipedia.org/wiki/Quantum_state"><h3>Quantum state</h3></a><p>In quantum physics, a <b>quantum state</b> is a mathematical entity that provides a probability distribution for the outcomes of each possible measurement on a system. Knowledge of the quantum state together with the rules for the system's evolution in time exhausts all that can be predicted about the system's behavior. A mixture of quantum states is again a quantum state. Quantum states that cannot be written as a mixture of other states are called <b>pure quantum states</b>, while all other states are called <b>mixed quantum states</b>. A pure quantum state can be represented by a ray in a Hilbert space over the complex numbers, while mixed states are represented by density matrices, which are positive semidefinite operators that act on Hilbert spaces.</p>`,im=`<a href="https://en.wikipedia.org/wiki/Linear_combination"><h3>Linear combination</h3></a><p>In mathematics, a <b>linear combination</b> is an expression constructed from a set of terms by multiplying each term by a constant and adding the results. The concept of linear combinations is central to linear algebra and related fields of mathematics.
Most of this article deals with linear combinations in the context of a vector space over a field, with some generalizations given at the end of the article.</p>`;function lm(e){let t;return{c(){t=i("complex number")},l(a){t=l(a,"complex number")},m(a,s){y(a,t,s)},d(a){a&&r(t)}}}function hm(e){let t;return{c(){t=i("imaginary")},l(a){t=l(a,"imaginary")},m(a,s){y(a,t,s)},d(a){a&&r(t)}}}function um(e){let t;return{c(){t=i("real")},l(a){t=l(a,"real")},m(a,s){y(a,t,s)},d(a){a&&r(t)}}}function fm(e){let t;return{c(){t=i("complex plane")},l(a){t=l(a,"complex plane")},m(a,s){y(a,t,s)},d(a){a&&r(t)}}}function mm(e){let t;return{c(){t=i("bits")},l(a){t=l(a,"bits")},m(a,s){y(a,t,s)},d(a){a&&r(t)}}}function pm(e){let t;return{c(){t=i("bit of information")},l(a){t=l(a,"bit of information")},m(a,s){y(a,t,s)},d(a){a&&r(t)}}}function cm(e){let t;return{c(){t=i("Qubits")},l(a){t=l(a,"Qubits")},m(a,s){y(a,t,s)},d(a){a&&r(t)}}}function dm(e){let t;return{c(){t=i("measured")},l(a){t=l(a,"measured")},m(a,s){y(a,t,s)},d(a){a&&r(t)}}}function _m(e){let t;return{c(){t=i("state")},l(a){t=l(a,"state")},m(a,s){y(a,t,s)},d(a){a&&r(t)}}}function bm(e){let t;return{c(){t=i("linear combination")},l(a){t=l(a,"linear combination")},m(a,s){y(a,t,s)},d(a){a&&r(t)}}}function vm(e){let t,a,s,o,c,p,m,b,_=d("z \\in \\mathbb{C}")+"",N,v,k=d("z = a i + b")+"",$,A,G=d("a, b \\in \\mathbb{R}")+"",j,P,C=d("i = \\sqrt{-1}")+"",F,S,z=d("a")+"",M,Z,K,Q,ee=d("b")+"",I,E,x,ne,R=d("z")+"",L,D,oe=d("a=0")+"",te,Pe,ae,W,T,U,J,Se=d("x")+"",Ne,Le,Ie=d("y")+"",Ae,Re,Ce,rt,Qe,Ee=d("\\Vert{z}\\Vert = \\sqrt{a^2 + b^2}")+"",gt,Te,We=d("z")+"",he,Ge,dt=d("\\Vert{z}\\Vert^2 = a^2 + b^2")+"",we,ht,de,re,_e,X=d("z")+"",_t,st,Ue=d("\\Vert{z}\\Vert \\cdot e^{i \\phi_z}")+"",bt,ot,Je=d("\\phi_z \\in [0, 2\\pi]")+"",At,ie,ze=d("e^{i \\phi_z}")+"",le,Nt,vt=d("\\phi_z")+"",Et,Oe,Tt=d("2\\pi")+"",Kt,Vt,yt=d("z")+"",Ct,Mt,dn=d("\\Vert{z}\\Vert")+"",$t,Xe,xt,wt,Ye,nt,ut,Me,Pt,ft,_n,kt,It=d("0")+"",bn,mt,Zt=d("1")+"",ln,Dt,Ve,se,Be,Ze,$n=d("0")+"",Ft,qt,ra=d("1")+"",Yt,qe,Ln,Wt,me,In,Gt,hn=d("|0\\rangle")+"",Dn,ue,pt=d("|1\\rangle")+"",Bt,pe,vn,He,Fn,Ut,Ea=d("\\alpha |0\\rangle + \\beta |1\\rangle")+"",zn,tn,kn=d("\\alpha")+"",un,St,Vn=d("\\beta")+"",it,Nn,Wn=d("|0\\rangle")+"",Ta,En,oa=d("\\Vert{\\alpha}\\Vert^2")+"",wn,Ke,Mr=d("|1\\rangle")+"",Gn,ce,Ma=d("\\Vert{\\beta}\\Vert^2")+"",Tn,Un,Pa=d("|0\\rangle")+"",Mn,Cn,fn=d("|1\\rangle")+"",Pn,On,Kn=d("\\Vert{\\alpha}\\Vert^2 + \\Vert{\\beta}\\Vert^2 = 1")+"",gn,zt,Sa=d("\\Vert{\\alpha}\\Vert^2")+"",Sn,Zn,Aa=d("\\Vert{\\beta}\\Vert^2")+"",Yn,Fa,xa,sa;return p=new at({props:{hovertext:Jf,$$slots:{default:[lm]},$$scope:{ctx:e}}}),Z=new at({props:{hovertext:Xf,$$slots:{default:[hm]},$$scope:{ctx:e}}}),E=new at({props:{hovertext:em,$$slots:{default:[um]},$$scope:{ctx:e}}}),T=new at({props:{hovertext:tm,$$slots:{default:[fm]},$$scope:{ctx:e}}}),Me=new at({props:{hovertext:nm,$$slots:{default:[mm]},$$scope:{ctx:e}}}),ft=new at({props:{hovertext:am,$$slots:{default:[pm]},$$scope:{ctx:e}}}),se=new at({props:{hovertext:rm,$$slots:{default:[cm]},$$scope:{ctx:e}}}),qe=new at({props:{hovertext:sm,$$slots:{default:[dm]},$$scope:{ctx:e}}}),pe=new at({props:{hovertext:om,$$slots:{default:[_m]},$$scope:{ctx:e}}}),He=new at({props:{hovertext:im,$$slots:{default:[bm]},$$scope:{ctx:e}}}),{c(){t=h("h2"),a=i("Important properties of complex numbers"),s=q(),o=h("p"),c=i("The general form of a "),ge(p.$$.fragment),m=q(),b=h("span"),N=i(" is the following: "),v=h("span"),$=i(", where "),A=h("span"),j=i(" and "),P=h("span"),F=i(". "),S=h("span"),M=i(" is called the "),ge(Z.$$.fragment),K=i(" and "),Q=h("span"),I=i(" the "),ge(E.$$.fragment),x=i(" component of "),ne=h("span"),L=i(". In fact, all real numbers are complex numbers, the imaginary component of which is zero ("),D=h("span"),te=i(")."),Pe=q(),ae=h("p"),W=i("Complex numbers can be represented geometrically as two-dimensional vectors in the so called "),ge(T.$$.fragment),U=i(", where the "),J=h("span"),Ne=i("-axis stands for the real, and the "),Le=h("span"),Ae=i("-axis for the imaginary component."),Re=q(),Ce=h("p"),rt=i("Let "),Qe=h("span"),gt=i(" denote the Euclidean norm of the vector associated with the complex number "),Te=h("span"),he=i(". Consequently, "),Ge=h("span"),we=i(" is the square of this norm, and it's going to play an important role in what follows."),ht=q(),de=h("p"),re=i("Another important thing to note is that each 2-dimensional vector is uniquely defined by two properties: its length and angle of rotation. Consequently, a complex number "),_e=h("span"),_t=i(" can be expressed as "),st=h("span"),bt=i(", where "),ot=h("span"),At=i(". Here, "),ie=h("span"),le=i(" is a vector of unit length in the complex plane, rotated around the origin by an angle of "),Nt=h("span"),Et=i(" ("),Oe=h("span"),Kt=i(" corresponds to a full rotation). All we have to do to get back "),Vt=h("span"),Ct=i(", then, is multiply this rotated unit vector by "),Mt=h("span"),$t=i(" to adjust its norm."),Xe=q(),xt=h("h2"),wt=i("Qubit states"),Ye=q(),nt=h("p"),ut=i("The elementary units of information in classical computing are "),ge(Me.$$.fragment),Pt=i(". As their name suggests, bits represent one single "),ge(ft.$$.fragment),_n=i(", which means they can take on either of two values "),kt=h("span"),bn=i(" and "),mt=h("span"),ln=i(" at a time."),Dt=q(),Ve=h("p"),ge(se.$$.fragment),Be=i(" are the quantum computing equivalent of bits. They differ from classical bits - among other things - in that they can take on a multitude of values instead of just "),Ze=h("span"),Ft=i(" and "),qt=h("span"),Yt=i(", until that value is "),ge(qe.$$.fragment),Ln=i(", at which point they behave just like classical bits. To explain what this means exactly, we'll need to introduce some further concepts."),Wt=q(),me=h("p"),In=i("Let "),Gt=h("span"),Dn=i(" and "),ue=h("span"),Bt=i(" denote the so called basis states of a qubit that are the quantum-equivalent of classical bit states. If you look at a qubit directly to learn it's value, you'll see one of these basis states. But while you're not looking - due to it's quantum nature - the "),ge(pe.$$.fragment),vn=i(" of a qubit may be something more intricate. Generally, it can be expressed as the "),ge(He.$$.fragment),Fn=i(" of the two basis states: "),Ut=h("span"),zn=i(". Here, "),tn=h("span"),un=i(" and "),St=h("span"),it=i(" are complex numbers that indicate the relative weight, with which the two basis states are present in this combination. More precisely, if we now look at the qubit, we'll see the basis state "),Nn=h("span"),Ta=i(" with a probability of "),En=h("span"),wn=i(", and the basis state "),Ke=h("span"),Gn=i(" with a probability of "),ce=h("span"),Tn=i(". Because these probabilities must add up to one - as "),Un=h("span"),Mn=i(" and "),Cn=h("span"),Pn=i(" are the only possible outcomes - the equation "),On=h("span"),gn=i(" must hold for all possible qubit states. Let's call "),zt=h("span"),Sn=i(" and "),Zn=h("span"),Yn=i(" the measurement probabilities of the basis states.")},l(B){t=u(B,"H2",{});var ve=f(t);a=l(ve,"Important properties of complex numbers"),ve.forEach(r),s=H(B),o=u(B,"P",{});var je=f(o);c=l(je,"The general form of a "),ye(p.$$.fragment,je),m=H(je),b=u(je,"SPAN",{});var za=f(b);za.forEach(r),N=l(je," is the following: "),v=u(je,"SPAN",{});var ia=f(v);ia.forEach(r),$=l(je,", where "),A=u(je,"SPAN",{});var Bn=f(A);Bn.forEach(r),j=l(je," and "),P=u(je,"SPAN",{});var Va=f(P);Va.forEach(r),F=l(je,". "),S=u(je,"SPAN",{});var la=f(S);la.forEach(r),M=l(je," is called the "),ye(Z.$$.fragment,je),K=l(je," and "),Q=u(je,"SPAN",{});var Rn=f(Q);Rn.forEach(r),I=l(je," the "),ye(E.$$.fragment,je),x=l(je," component of "),ne=u(je,"SPAN",{});var Ca=f(ne);Ca.forEach(r),L=l(je,". In fact, all real numbers are complex numbers, the imaginary component of which is zero ("),D=u(je,"SPAN",{});var ha=f(D);ha.forEach(r),te=l(je,")."),je.forEach(r),Pe=H(B),ae=u(B,"P",{});var Rt=f(ae);W=l(Rt,"Complex numbers can be represented geometrically as two-dimensional vectors in the so called "),ye(T.$$.fragment,Rt),U=l(Rt,", where the "),J=u(Rt,"SPAN",{});var $s=f(J);$s.forEach(r),Ne=l(Rt,"-axis stands for the real, and the "),Le=u(Rt,"SPAN",{});var Pr=f(Le);Pr.forEach(r),Ae=l(Rt,"-axis for the imaginary component."),Rt.forEach(r),Re=H(B),Ce=u(B,"P",{});var nn=f(Ce);rt=l(nn,"Let "),Qe=u(nn,"SPAN",{});var ks=f(Qe);ks.forEach(r),gt=l(nn," denote the Euclidean norm of the vector associated with the complex number "),Te=u(nn,"SPAN",{});var Sr=f(Te);Sr.forEach(r),he=l(nn,". Consequently, "),Ge=u(nn,"SPAN",{});var ua=f(Ge);ua.forEach(r),we=l(nn," is the square of this norm, and it's going to play an important role in what follows."),nn.forEach(r),ht=H(B),de=u(B,"P",{});var Ht=f(de);re=l(Ht,"Another important thing to note is that each 2-dimensional vector is uniquely defined by two properties: its length and angle of rotation. Consequently, a complex number "),_e=u(Ht,"SPAN",{});var Ar=f(_e);Ar.forEach(r),_t=l(Ht," can be expressed as "),st=u(Ht,"SPAN",{});var fa=f(st);fa.forEach(r),bt=l(Ht,", where "),ot=u(Ht,"SPAN",{});var Ns=f(ot);Ns.forEach(r),At=l(Ht,". Here, "),ie=u(Ht,"SPAN",{});var xr=f(ie);xr.forEach(r),le=l(Ht," is a vector of unit length in the complex plane, rotated around the origin by an angle of "),Nt=u(Ht,"SPAN",{});var ma=f(Nt);ma.forEach(r),Et=l(Ht," ("),Oe=u(Ht,"SPAN",{});var Es=f(Oe);Es.forEach(r),Kt=l(Ht," corresponds to a full rotation). All we have to do to get back "),Vt=u(Ht,"SPAN",{});var qr=f(Vt);qr.forEach(r),Ct=l(Ht,", then, is multiply this rotated unit vector by "),Mt=u(Ht,"SPAN",{});var pa=f(Mt);pa.forEach(r),$t=l(Ht," to adjust its norm."),Ht.forEach(r),Xe=H(B),xt=u(B,"H2",{});var Ur=f(xt);wt=l(Ur,"Qubit states"),Ur.forEach(r),Ye=H(B),nt=u(B,"P",{});var mn=f(nt);ut=l(mn,"The elementary units of information in classical computing are "),ye(Me.$$.fragment,mn),Pt=l(mn,". As their name suggests, bits represent one single "),ye(ft.$$.fragment,mn),_n=l(mn,", which means they can take on either of two values "),kt=u(mn,"SPAN",{});var Ba=f(kt);Ba.forEach(r),bn=l(mn," and "),mt=u(mn,"SPAN",{});var ca=f(mt);ca.forEach(r),ln=l(mn," at a time."),mn.forEach(r),Dt=H(B),Ve=u(B,"P",{});var yn=f(Ve);ye(se.$$.fragment,yn),Be=l(yn," are the quantum computing equivalent of bits. They differ from classical bits - among other things - in that they can take on a multitude of values instead of just "),Ze=u(yn,"SPAN",{});var Ra=f(Ze);Ra.forEach(r),Ft=l(yn," and "),qt=u(yn,"SPAN",{});var da=f(qt);da.forEach(r),Yt=l(yn,", until that value is "),ye(qe.$$.fragment,yn),Ln=l(yn,", at which point they behave just like classical bits. To explain what this means exactly, we'll need to introduce some further concepts."),yn.forEach(r),Wt=H(B),me=u(B,"P",{});var xe=f(me);In=l(xe,"Let "),Gt=u(xe,"SPAN",{});var Ts=f(Gt);Ts.forEach(r),Dn=l(xe," and "),ue=u(xe,"SPAN",{});var Qa=f(ue);Qa.forEach(r),Bt=l(xe," denote the so called basis states of a qubit that are the quantum-equivalent of classical bit states. If you look at a qubit directly to learn it's value, you'll see one of these basis states. But while you're not looking - due to it's quantum nature - the "),ye(pe.$$.fragment,xe),vn=l(xe," of a qubit may be something more intricate. Generally, it can be expressed as the "),ye(He.$$.fragment,xe),Fn=l(xe," of the two basis states: "),Ut=u(xe,"SPAN",{});var An=f(Ut);An.forEach(r),zn=l(xe,". Here, "),tn=u(xe,"SPAN",{});var Hr=f(tn);Hr.forEach(r),un=l(xe," and "),St=u(xe,"SPAN",{});var _a=f(St);_a.forEach(r),it=l(xe," are complex numbers that indicate the relative weight, with which the two basis states are present in this combination. More precisely, if we now look at the qubit, we'll see the basis state "),Nn=u(xe,"SPAN",{});var Ms=f(Nn);Ms.forEach(r),Ta=l(xe," with a probability of "),En=u(xe,"SPAN",{});var Lr=f(En);Lr.forEach(r),wn=l(xe,", and the basis state "),Ke=u(xe,"SPAN",{});var ba=f(Ke);ba.forEach(r),Gn=l(xe," with a probability of "),ce=u(xe,"SPAN",{});var Ps=f(ce);Ps.forEach(r),Tn=l(xe,". Because these probabilities must add up to one - as "),Un=u(xe,"SPAN",{});var Ir=f(Un);Ir.forEach(r),Mn=l(xe," and "),Cn=u(xe,"SPAN",{});var ja=f(Cn);ja.forEach(r),Pn=l(xe," are the only possible outcomes - the equation "),On=u(xe,"SPAN",{});var Jn=f(On);Jn.forEach(r),gn=l(xe," must hold for all possible qubit states. Let's call "),zt=u(xe,"SPAN",{});var Xn=f(zt);Xn.forEach(r),Sn=l(xe," and "),Zn=u(xe,"SPAN",{});var va=f(Zn);va.forEach(r),Yn=l(xe," the measurement probabilities of the basis states."),xe.forEach(r)},m(B,ve){y(B,t,ve),n(t,a),y(B,s,ve),y(B,o,ve),n(o,c),$e(p,o,null),n(o,m),n(o,b),b.innerHTML=_,n(o,N),n(o,v),v.innerHTML=k,n(o,$),n(o,A),A.innerHTML=G,n(o,j),n(o,P),P.innerHTML=C,n(o,F),n(o,S),S.innerHTML=z,n(o,M),$e(Z,o,null),n(o,K),n(o,Q),Q.innerHTML=ee,n(o,I),$e(E,o,null),n(o,x),n(o,ne),ne.innerHTML=R,n(o,L),n(o,D),D.innerHTML=oe,n(o,te),y(B,Pe,ve),y(B,ae,ve),n(ae,W),$e(T,ae,null),n(ae,U),n(ae,J),J.innerHTML=Se,n(ae,Ne),n(ae,Le),Le.innerHTML=Ie,n(ae,Ae),y(B,Re,ve),y(B,Ce,ve),n(Ce,rt),n(Ce,Qe),Qe.innerHTML=Ee,n(Ce,gt),n(Ce,Te),Te.innerHTML=We,n(Ce,he),n(Ce,Ge),Ge.innerHTML=dt,n(Ce,we),y(B,ht,ve),y(B,de,ve),n(de,re),n(de,_e),_e.innerHTML=X,n(de,_t),n(de,st),st.innerHTML=Ue,n(de,bt),n(de,ot),ot.innerHTML=Je,n(de,At),n(de,ie),ie.innerHTML=ze,n(de,le),n(de,Nt),Nt.innerHTML=vt,n(de,Et),n(de,Oe),Oe.innerHTML=Tt,n(de,Kt),n(de,Vt),Vt.innerHTML=yt,n(de,Ct),n(de,Mt),Mt.innerHTML=dn,n(de,$t),y(B,Xe,ve),y(B,xt,ve),n(xt,wt),y(B,Ye,ve),y(B,nt,ve),n(nt,ut),$e(Me,nt,null),n(nt,Pt),$e(ft,nt,null),n(nt,_n),n(nt,kt),kt.innerHTML=It,n(nt,bn),n(nt,mt),mt.innerHTML=Zt,n(nt,ln),y(B,Dt,ve),y(B,Ve,ve),$e(se,Ve,null),n(Ve,Be),n(Ve,Ze),Ze.innerHTML=$n,n(Ve,Ft),n(Ve,qt),qt.innerHTML=ra,n(Ve,Yt),$e(qe,Ve,null),n(Ve,Ln),y(B,Wt,ve),y(B,me,ve),n(me,In),n(me,Gt),Gt.innerHTML=hn,n(me,Dn),n(me,ue),ue.innerHTML=pt,n(me,Bt),$e(pe,me,null),n(me,vn),$e(He,me,null),n(me,Fn),n(me,Ut),Ut.innerHTML=Ea,n(me,zn),n(me,tn),tn.innerHTML=kn,n(me,un),n(me,St),St.innerHTML=Vn,n(me,it),n(me,Nn),Nn.innerHTML=Wn,n(me,Ta),n(me,En),En.innerHTML=oa,n(me,wn),n(me,Ke),Ke.innerHTML=Mr,n(me,Gn),n(me,ce),ce.innerHTML=Ma,n(me,Tn),n(me,Un),Un.innerHTML=Pa,n(me,Mn),n(me,Cn),Cn.innerHTML=fn,n(me,Pn),n(me,On),On.innerHTML=Kn,n(me,gn),n(me,zt),zt.innerHTML=Sa,n(me,Sn),n(me,Zn),Zn.innerHTML=Aa,n(me,Yn),Fa=!0,xa||(sa=[w(b,"mouseenter",e[0]),w(v,"mouseenter",e[1]),w(A,"mouseenter",e[2]),w(P,"mouseenter",e[3]),w(S,"mouseenter",e[4]),w(Q,"mouseenter",e[5]),w(ne,"mouseenter",e[6]),w(D,"mouseenter",e[7]),w(J,"mouseenter",e[8]),w(Le,"mouseenter",e[9]),w(Qe,"mouseenter",e[10]),w(Te,"mouseenter",e[11]),w(Ge,"mouseenter",e[12]),w(_e,"mouseenter",e[13]),w(st,"mouseenter",e[14]),w(ot,"mouseenter",e[15]),w(ie,"mouseenter",e[16]),w(Nt,"mouseenter",e[17]),w(Oe,"mouseenter",e[18]),w(Vt,"mouseenter",e[19]),w(Mt,"mouseenter",e[20]),w(kt,"mouseenter",e[21]),w(mt,"mouseenter",e[22]),w(Ze,"mouseenter",e[23]),w(qt,"mouseenter",e[24]),w(Gt,"mouseenter",e[25]),w(ue,"mouseenter",e[26]),w(Ut,"mouseenter",e[27]),w(tn,"mouseenter",e[28]),w(St,"mouseenter",e[29]),w(Nn,"mouseenter",e[30]),w(En,"mouseenter",e[31]),w(Ke,"mouseenter",e[32]),w(ce,"mouseenter",e[33]),w(Un,"mouseenter",e[34]),w(Cn,"mouseenter",e[35]),w(On,"mouseenter",e[36]),w(zt,"mouseenter",e[37]),w(Zn,"mouseenter",e[38])],xa=!0)},p(B,ve){const je={};ve[1]&256&&(je.$$scope={dirty:ve,ctx:B}),p.$set(je);const za={};ve[1]&256&&(za.$$scope={dirty:ve,ctx:B}),Z.$set(za);const ia={};ve[1]&256&&(ia.$$scope={dirty:ve,ctx:B}),E.$set(ia);const Bn={};ve[1]&256&&(Bn.$$scope={dirty:ve,ctx:B}),T.$set(Bn);const Va={};ve[1]&256&&(Va.$$scope={dirty:ve,ctx:B}),Me.$set(Va);const la={};ve[1]&256&&(la.$$scope={dirty:ve,ctx:B}),ft.$set(la);const Rn={};ve[1]&256&&(Rn.$$scope={dirty:ve,ctx:B}),se.$set(Rn);const Ca={};ve[1]&256&&(Ca.$$scope={dirty:ve,ctx:B}),qe.$set(Ca);const ha={};ve[1]&256&&(ha.$$scope={dirty:ve,ctx:B}),pe.$set(ha);const Rt={};ve[1]&256&&(Rt.$$scope={dirty:ve,ctx:B}),He.$set(Rt)},i(B){Fa||(fe(p.$$.fragment,B),fe(Z.$$.fragment,B),fe(E.$$.fragment,B),fe(T.$$.fragment,B),fe(Me.$$.fragment,B),fe(ft.$$.fragment,B),fe(se.$$.fragment,B),fe(qe.$$.fragment,B),fe(pe.$$.fragment,B),fe(He.$$.fragment,B),Fa=!0)},o(B){be(p.$$.fragment,B),be(Z.$$.fragment,B),be(E.$$.fragment,B),be(T.$$.fragment,B),be(Me.$$.fragment,B),be(ft.$$.fragment,B),be(se.$$.fragment,B),be(qe.$$.fragment,B),be(pe.$$.fragment,B),be(He.$$.fragment,B),Fa=!1},d(B){B&&r(t),B&&r(s),B&&r(o),ke(p),ke(Z),ke(E),B&&r(Pe),B&&r(ae),ke(T),B&&r(Re),B&&r(Ce),B&&r(ht),B&&r(de),B&&r(Xe),B&&r(xt),B&&r(Ye),B&&r(nt),ke(Me),ke(ft),B&&r(Dt),B&&r(Ve),ke(se),ke(qe),B&&r(Wt),B&&r(me),ke(pe),ke(He),xa=!1,jn(sa)}}}function Fe(e){console.log(e)}function wm(e){return[()=>Fe(["C","z"]),()=>Fe(["a","b","z"]),()=>Fe(["a","R","b"]),()=>Fe([]),()=>Fe(["a"]),()=>Fe(["b"]),()=>Fe(["z"]),()=>Fe(["a"]),()=>Fe(["x"]),()=>Fe(["y"]),()=>Fe(["a","b","z"]),()=>Fe(["z"]),()=>Fe(["a","b","z"]),()=>Fe(["z"]),()=>Fe(["z","\\phi"]),()=>Fe(["z","\\phi"]),()=>Fe(["z","\\phi"]),()=>Fe(["z","\\phi"]),()=>Fe([]),()=>Fe(["z"]),()=>Fe(["z"]),()=>Fe([]),()=>Fe([]),()=>Fe([]),()=>Fe([]),()=>Fe([]),()=>Fe([]),()=>Fe(["\\beta","\\alpha"]),()=>Fe(["\\alpha"]),()=>Fe(["\\beta"]),()=>Fe([]),()=>Fe(["\\alpha"]),()=>Fe([]),()=>Fe(["\\beta"]),()=>Fe([]),()=>Fe([]),()=>Fe(["\\beta","\\alpha"]),()=>Fe(["\\alpha"]),()=>Fe(["\\beta"])]}class gm extends rn{constructor(t){super(),sn(this,t,wm,vm,on,{},null,[-1,-1])}}const ym='<a href="https://en.wikipedia.org/wiki/Separable_state"><h3>Separable state</h3></a><p>In quantum mechanics, <b>separable states</b> are quantum states belonging to a composite space that can be factored into individual states belonging to separate subspaces. A state is said to be entangled if it is not separable. In general, determining if a state is separable is not straightforward and the problem is classed as NP-hard.</p>',$m='<a href="https://en.wikipedia.org/wiki/Quantum_entanglement"><h3>Quantum entanglement</h3></a><p><b>Quantum entanglement</b> is the physical phenomenon that occurs when a group of particles are generated, interact, or share spatial proximity in a way such that the quantum state of each particle of the group cannot be described independently of the state of the others, including when the particles are separated by a large distance. The topic of quantum entanglement is at the heart of the disparity between classical and quantum physics: entanglement is a primary feature of quantum mechanics lacking in classical mechanics.</p>';function km(e){let t;return{c(){t=i("separable")},l(a){t=l(a,"separable")},m(a,s){y(a,t,s)},d(a){a&&r(t)}}}function Nm(e){let t;return{c(){t=i("entaglement")},l(a){t=l(a,"entaglement")},m(a,s){y(a,t,s)},d(a){a&&r(t)}}}function Em(e){let t,a,s,o,c,p,m,b,_,N,v=d("|0\\rangle")+"",k,$,A=d("|1\\rangle")+"",G,j,P,C,F,S=d("|\\psi\\rangle")+"",z,M,Z=d("n")+"",K,Q,ee=d("|\\psi\\rangle = \\left( \\alpha_1 |0\\rangle + \\beta_1 |1\\rangle \\right) \\otimes ... \\otimes \\left( \\alpha_n |0\\rangle + \\beta_n |1\\rangle \\right)")+"",I,E,x=d("\\alpha_k, \\beta_k")+"",ne,R,L=d("k")+"",D,oe,te=d("\\otimes")+"",Pe,ae,W,T;return p=new at({props:{hovertext:ym,$$slots:{default:[km]},$$scope:{ctx:e}}}),b=new at({props:{hovertext:$m,$$slots:{default:[Nm]},$$scope:{ctx:e}}}),{c(){t=h("h2"),a=i("Multiple qubits"),s=q(),o=h("p"),c=i("Most quantum algorithms require not only one, but several qubits. The states of these qubits may be "),ge(p.$$.fragment),m=i(", meaning they each contain one independent unit of information. However, it is possible for multiple qubits to share some information with each other, in which case they no longer have states of their own, but only one joint state. This is called "),ge(b.$$.fragment),_=i(", and it is another fundamental difference between classical and quantum computing. As an example, two qubits can be entangled in a way that, if we look at one of them and find it's in the basis state "),N=h("span"),k=i(", we learn immediately that the other one must be in the basis state "),$=h("span"),G=i(", and vice versa."),j=q(),P=h("p"),C=i("Let "),F=h("span"),z=i(" denote the state of a sequence of "),M=h("span"),K=i(" qubits. If the qubits are separable, the state can be written as "),Q=h("span"),I=i(", where "),E=h("span"),ne=i(" are the coefficients associated with the state of the "),R=h("span"),D=i("-th qubit as described above, and the operator "),oe=h("span"),Pe=i(" indicates that none of the qubits are entagled with each other.")},l(U){t=u(U,"H2",{});var J=f(t);a=l(J,"Multiple qubits"),J.forEach(r),s=H(U),o=u(U,"P",{});var Se=f(o);c=l(Se,"Most quantum algorithms require not only one, but several qubits. The states of these qubits may be "),ye(p.$$.fragment,Se),m=l(Se,", meaning they each contain one independent unit of information. However, it is possible for multiple qubits to share some information with each other, in which case they no longer have states of their own, but only one joint state. This is called "),ye(b.$$.fragment,Se),_=l(Se,", and it is another fundamental difference between classical and quantum computing. As an example, two qubits can be entangled in a way that, if we look at one of them and find it's in the basis state "),N=u(Se,"SPAN",{});var Ne=f(N);Ne.forEach(r),k=l(Se,", we learn immediately that the other one must be in the basis state "),$=u(Se,"SPAN",{});var Le=f($);Le.forEach(r),G=l(Se,", and vice versa."),Se.forEach(r),j=H(U),P=u(U,"P",{});var Ie=f(P);C=l(Ie,"Let "),F=u(Ie,"SPAN",{});var Ae=f(F);Ae.forEach(r),z=l(Ie," denote the state of a sequence of "),M=u(Ie,"SPAN",{});var Re=f(M);Re.forEach(r),K=l(Ie," qubits. If the qubits are separable, the state can be written as "),Q=u(Ie,"SPAN",{});var Ce=f(Q);Ce.forEach(r),I=l(Ie,", where "),E=u(Ie,"SPAN",{});var rt=f(E);rt.forEach(r),ne=l(Ie," are the coefficients associated with the state of the "),R=u(Ie,"SPAN",{});var Qe=f(R);Qe.forEach(r),D=l(Ie,"-th qubit as described above, and the operator "),oe=u(Ie,"SPAN",{});var Ee=f(oe);Ee.forEach(r),Pe=l(Ie," indicates that none of the qubits are entagled with each other."),Ie.forEach(r)},m(U,J){y(U,t,J),n(t,a),y(U,s,J),y(U,o,J),n(o,c),$e(p,o,null),n(o,m),$e(b,o,null),n(o,_),n(o,N),N.innerHTML=v,n(o,k),n(o,$),$.innerHTML=A,n(o,G),y(U,j,J),y(U,P,J),n(P,C),n(P,F),F.innerHTML=S,n(P,z),n(P,M),M.innerHTML=Z,n(P,K),n(P,Q),Q.innerHTML=ee,n(P,I),n(P,E),E.innerHTML=x,n(P,ne),n(P,R),R.innerHTML=L,n(P,D),n(P,oe),oe.innerHTML=te,n(P,Pe),ae=!0,W||(T=[w(N,"mouseenter",e[0]),w($,"mouseenter",e[1]),w(F,"mouseenter",e[2]),w(M,"mouseenter",e[3]),w(Q,"mouseenter",e[4]),w(E,"mouseenter",e[5]),w(R,"mouseenter",e[6]),w(oe,"mouseenter",e[7])],W=!0)},p(U,[J]){const Se={};J&256&&(Se.$$scope={dirty:J,ctx:U}),p.$set(Se);const Ne={};J&256&&(Ne.$$scope={dirty:J,ctx:U}),b.$set(Ne)},i(U){ae||(fe(p.$$.fragment,U),fe(b.$$.fragment,U),ae=!0)},o(U){be(p.$$.fragment,U),be(b.$$.fragment,U),ae=!1},d(U){U&&r(t),U&&r(s),U&&r(o),ke(p),ke(b),U&&r(j),U&&r(P),W=!1,jn(T)}}}function $a(e){console.log(e)}function Tm(e){return[()=>$a([]),()=>$a([]),()=>$a(["\\psi"]),()=>$a(["n"]),()=>$a(["\\beta","\\alpha","n","\\psi"]),()=>$a(["\\beta","\\alpha","k"]),()=>$a(["k"]),()=>$a([])]}class Mm extends rn{constructor(t){super(),sn(this,t,Tm,Em,on,{})}}function Pm(e){let t,a,s,o,c,p,m,b,_,N,v,k,$,A,G=d("\\phi_\\alpha")+"",j,P,C,F=d("\\phi_\\beta")+"",S,z,M,Z=d("r_\\alpha")+"",K,Q,ee,I,E,x,ne,R,L,D,oe,te,Pe,ae,W;return o=new gm({}),R=new Ih({props:{displayBloch:e[2],phiAlpha:e[4],phiBeta:e[3],rAlpha:e[5],blochClass:"col-lg-4 col-sm-12",vectorClass:"col-lg-4 col-sm-12"}}),D=new Yf({}),te=new Mm({}),{c(){t=h("h2"),a=i("Quantum Basics"),s=q(),ge(o.$$.fragment),c=q(),p=h("div"),m=h("div"),b=h("div"),_=h("p"),N=i(`Play around with 2 representations of a single qubit. You adjust the view of the 3D Bloch
				sphere by clicking on the image and dragging.`),v=q(),k=h("div"),$=h("div"),A=new et(!1),j=h("input"),P=q(),C=new et(!1),S=h("input"),z=q(),M=new et(!1),K=h("input"),Q=q(),ee=h("b"),I=i("Display Bloch sphere"),E=q(),x=h("input"),ne=q(),ge(R.$$.fragment),L=q(),ge(D.$$.fragment),oe=q(),ge(te.$$.fragment),this.h()},l(T){t=u(T,"H2",{});var U=f(t);a=l(U,"Quantum Basics"),U.forEach(r),s=H(T),ye(o.$$.fragment,T),c=H(T),p=u(T,"DIV",{class:!0});var J=f(p);m=u(J,"DIV",{class:!0});var Se=f(m);b=u(Se,"DIV",{class:!0});var Ne=f(b);_=u(Ne,"P",{});var Le=f(_);N=l(Le,`Play around with 2 representations of a single qubit. You adjust the view of the 3D Bloch
				sphere by clicking on the image and dragging.`),Le.forEach(r),Ne.forEach(r),Se.forEach(r),v=H(J),k=u(J,"DIV",{class:!0});var Ie=f(k);$=u(Ie,"DIV",{class:!0});var Ae=f($);A=tt(Ae,!1),j=u(Ae,"INPUT",{type:!0,min:!0,max:!0,step:!0,class:!0}),P=H(Ae),C=tt(Ae,!1),S=u(Ae,"INPUT",{type:!0,min:!0,max:!0,step:!0,class:!0}),z=H(Ae),M=tt(Ae,!1),K=u(Ae,"INPUT",{type:!0,min:!0,max:!0,step:!0,class:!0}),Q=H(Ae),ee=u(Ae,"B",{});var Re=f(ee);I=l(Re,"Display Bloch sphere"),Re.forEach(r),E=H(Ae),x=u(Ae,"INPUT",{type:!0,style:!0,class:!0}),Ae.forEach(r),ne=H(Ie),ye(R.$$.fragment,Ie),Ie.forEach(r),J.forEach(r),L=H(T),ye(D.$$.fragment,T),oe=H(T),ye(te.$$.fragment,T),this.h()},h(){V(b,"class","col-12"),V(m,"class","row mb-4"),A.a=j,V(j,"type","range"),V(j,"min",0),V(j,"max",360),V(j,"step",1),V(j,"class","svelte-unwbto"),C.a=S,V(S,"type","range"),V(S,"min",0),V(S,"max",360),V(S,"step",1),V(S,"class","svelte-unwbto"),M.a=K,V(K,"type","range"),V(K,"min",0),V(K,"max",1),V(K,"step",.01),V(K,"class","svelte-unwbto"),V(x,"type","checkbox"),xh(x,"width","auto"),V(x,"class","svelte-unwbto"),V($,"class","col-lg-4 col-sm-12"),V(k,"class","row"),V(p,"class","interaction container")},m(T,U){y(T,t,U),n(t,a),y(T,s,U),$e(o,T,U),y(T,c,U),y(T,p,U),n(p,m),n(m,b),n(b,_),n(_,N),n(p,v),n(p,k),n(k,$),A.m(G,$),n($,j),en(j,e[1]),n($,P),C.m(F,$),n($,S),en(S,e[0]),n($,z),M.m(Z,$),n($,K),en(K,e[5]),n($,Q),n($,ee),n(ee,I),n($,E),n($,x),x.checked=e[2],n(k,ne),$e(R,k,null),y(T,L,U),$e(D,T,U),y(T,oe,U),$e(te,T,U),Pe=!0,ae||(W=[w(j,"change",e[6]),w(j,"input",e[6]),w(S,"change",e[7]),w(S,"input",e[7]),w(K,"change",e[8]),w(K,"input",e[8]),w(x,"change",e[9])],ae=!0)},p(T,[U]){U&2&&en(j,T[1]),U&1&&en(S,T[0]),U&32&&en(K,T[5]),U&4&&(x.checked=T[2]);const J={};U&4&&(J.displayBloch=T[2]),U&16&&(J.phiAlpha=T[4]),U&8&&(J.phiBeta=T[3]),U&32&&(J.rAlpha=T[5]),R.$set(J)},i(T){Pe||(fe(o.$$.fragment,T),fe(R.$$.fragment,T),fe(D.$$.fragment,T),fe(te.$$.fragment,T),Pe=!0)},o(T){be(o.$$.fragment,T),be(R.$$.fragment,T),be(D.$$.fragment,T),be(te.$$.fragment,T),Pe=!1},d(T){T&&r(t),T&&r(s),ke(o,T),T&&r(c),T&&r(p),ke(R),T&&r(L),ke(D,T),T&&r(oe),ke(te,T),ae=!1,jn(W)}}}function Sm(e,t,a){let s,o,c,p,m,b=!0;function _(){s=na(this.value),a(1,s)}function N(){o=na(this.value),a(0,o)}function v(){c=na(this.value),a(5,c)}function k(){b=this.checked,a(2,b)}return e.$$.update=()=>{e.$$.dirty&2&&a(4,p=s/180*fo),e.$$.dirty&1&&a(3,m=o/180*fo)},a(1,s=15),a(0,o=310),a(5,c=.9),[o,s,b,m,p,c,_,N,v,k]}class Am extends rn{constructor(t){super(),sn(this,t,Sm,Pm,on,{})}}const xm='<a href="https://en.wikipedia.org/wiki/Periodic_function"><h3 class="text-lg font-semibold">Periodic function</h3></a><p>A <b>periodic function</b> is a function that repeats its values at regular intervals. For example, the trigonometric functions, which repeat at intervals of <span class="mwe-math-element"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/73efd1f6493490b058097060a572606d2c550a06" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align:-0.338ex;width:2.494ex;height:2.176ex" /></span> radians, are periodic functions. Periodic functions are used throughout science to describe oscillations, waves, and other phenomena that exhibit periodicity. Any function that is not periodic is called <b>aperiodic</b>.</p>';function qm(e){let t;return{c(){t=i("periodic")},l(a){t=l(a,"periodic")},m(a,s){y(a,t,s)},d(a){a&&r(t)}}}function Hm(e){let t,a,s,o,c,p,m=d("N")+"",b,_,N=d("1 < \\hat{r} < N")+"",v,k,$=d("f(\\hat{r}) = a^{\\hat{r}} \\mod N = 1")+"",A,G,j=d("f")+"",P,C,F,S,z=d("\\hat{r}")+"",M,Z,K=d("f")+"",Q,ee,I=d("0 < p")+"",E,x,ne=d("f(r) = f(r + p)")+"",R,L,D=d("r")+"",oe,te,Pe=d("f(0) = a^{0} \\mod N = 1 \\mod N = 1")+"",ae,W,T=d("f(0) = f(0 + p) = f(p) = 1")+"",U,J,Se=d("p")+"",Ne,Le,Ie=d("f")+"",Ae,Re,Ce=d("1")+"",rt,Qe,Ee=d("\\hat{r}")+"",gt,Te,We,he,Ge,dt=d("\\hat{r}")+"",we,ht,de=d("f")+"",re,_e,X,_t,st,Ue,bt,ot,Je,At;return C=new at({props:{hovertext:xm,$$slots:{default:[qm]},$$scope:{ctx:e}}}),{c(){t=h("h2"),a=i("The period-finding problem"),s=q(),o=h("p"),c=i("Recall the steps for computing the prime factors of a large integer "),p=h("span"),b=i(", the hard part of which was finding the smallest "),_=h("span"),v=i(" such that "),k=h("span"),A=i(". It turns out that "),G=h("span"),P=i(" is a "),ge(C.$$.fragment),F=i(" function, and the integer "),S=h("span"),M=i(" we're looking for is its period. This is because the period of "),Z=h("span"),Q=i(" is defined as the smallest integer "),ee=h("span"),E=i(", for which "),x=h("span"),R=i(" for all "),L=h("span"),oe=i(". We know for sure that "),te=h("span"),ae=i(", from which follows that "),W=h("span"),U=i(". Thus, the period "),J=h("span"),Ne=i(" is the smallest positive integer, at which the value of "),Le=h("span"),Ae=i(" is "),Re=h("span"),rt=i(", and this is exactly how we originally defined "),Qe=h("span"),gt=i("."),Te=q(),We=h("p"),he=i("Thus, finding "),Ge=h("span"),we=i(" can be reformulated as finding the period of the function "),ht=h("span"),re=i(", which is where the quantum Fourier transform will prove extremely useful."),_e=q(),X=h("h2"),_t=i("Finding the period with the help of interference"),st=q(),Ue=h("p"),bt=i("...")},l(ie){t=u(ie,"H2",{});var ze=f(t);a=l(ze,"The period-finding problem"),ze.forEach(r),s=H(ie),o=u(ie,"P",{});var le=f(o);c=l(le,"Recall the steps for computing the prime factors of a large integer "),p=u(le,"SPAN",{});var Nt=f(p);Nt.forEach(r),b=l(le,", the hard part of which was finding the smallest "),_=u(le,"SPAN",{});var vt=f(_);vt.forEach(r),v=l(le," such that "),k=u(le,"SPAN",{});var Et=f(k);Et.forEach(r),A=l(le,". It turns out that "),G=u(le,"SPAN",{});var Oe=f(G);Oe.forEach(r),P=l(le," is a "),ye(C.$$.fragment,le),F=l(le," function, and the integer "),S=u(le,"SPAN",{});var Tt=f(S);Tt.forEach(r),M=l(le," we're looking for is its period. This is because the period of "),Z=u(le,"SPAN",{});var Kt=f(Z);Kt.forEach(r),Q=l(le," is defined as the smallest integer "),ee=u(le,"SPAN",{});var Vt=f(ee);Vt.forEach(r),E=l(le,", for which "),x=u(le,"SPAN",{});var yt=f(x);yt.forEach(r),R=l(le," for all "),L=u(le,"SPAN",{});var Ct=f(L);Ct.forEach(r),oe=l(le,". We know for sure that "),te=u(le,"SPAN",{});var Mt=f(te);Mt.forEach(r),ae=l(le,", from which follows that "),W=u(le,"SPAN",{});var dn=f(W);dn.forEach(r),U=l(le,". Thus, the period "),J=u(le,"SPAN",{});var $t=f(J);$t.forEach(r),Ne=l(le," is the smallest positive integer, at which the value of "),Le=u(le,"SPAN",{});var Xe=f(Le);Xe.forEach(r),Ae=l(le," is "),Re=u(le,"SPAN",{});var xt=f(Re);xt.forEach(r),rt=l(le,", and this is exactly how we originally defined "),Qe=u(le,"SPAN",{});var wt=f(Qe);wt.forEach(r),gt=l(le,"."),le.forEach(r),Te=H(ie),We=u(ie,"P",{});var Ye=f(We);he=l(Ye,"Thus, finding "),Ge=u(Ye,"SPAN",{});var nt=f(Ge);nt.forEach(r),we=l(Ye," can be reformulated as finding the period of the function "),ht=u(Ye,"SPAN",{});var ut=f(ht);ut.forEach(r),re=l(Ye,", which is where the quantum Fourier transform will prove extremely useful."),Ye.forEach(r),_e=H(ie),X=u(ie,"H2",{});var Me=f(X);_t=l(Me,"Finding the period with the help of interference"),Me.forEach(r),st=H(ie),Ue=u(ie,"P",{});var Pt=f(Ue);bt=l(Pt,"..."),Pt.forEach(r)},m(ie,ze){y(ie,t,ze),n(t,a),y(ie,s,ze),y(ie,o,ze),n(o,c),n(o,p),p.innerHTML=m,n(o,b),n(o,_),_.innerHTML=N,n(o,v),n(o,k),k.innerHTML=$,n(o,A),n(o,G),G.innerHTML=j,n(o,P),$e(C,o,null),n(o,F),n(o,S),S.innerHTML=z,n(o,M),n(o,Z),Z.innerHTML=K,n(o,Q),n(o,ee),ee.innerHTML=I,n(o,E),n(o,x),x.innerHTML=ne,n(o,R),n(o,L),L.innerHTML=D,n(o,oe),n(o,te),te.innerHTML=Pe,n(o,ae),n(o,W),W.innerHTML=T,n(o,U),n(o,J),J.innerHTML=Se,n(o,Ne),n(o,Le),Le.innerHTML=Ie,n(o,Ae),n(o,Re),Re.innerHTML=Ce,n(o,rt),n(o,Qe),Qe.innerHTML=Ee,n(o,gt),y(ie,Te,ze),y(ie,We,ze),n(We,he),n(We,Ge),Ge.innerHTML=dt,n(We,we),n(We,ht),ht.innerHTML=de,n(We,re),y(ie,_e,ze),y(ie,X,ze),n(X,_t),y(ie,st,ze),y(ie,Ue,ze),n(Ue,bt),ot=!0,Je||(At=[w(p,"mouseenter",e[0]),w(_,"mouseenter",e[1]),w(k,"mouseenter",e[2]),w(G,"mouseenter",e[3]),w(S,"mouseenter",e[4]),w(Z,"mouseenter",e[5]),w(ee,"mouseenter",e[6]),w(x,"mouseenter",e[7]),w(L,"mouseenter",e[8]),w(te,"mouseenter",e[9]),w(W,"mouseenter",e[10]),w(J,"mouseenter",e[11]),w(Le,"mouseenter",e[12]),w(Re,"mouseenter",e[13]),w(Qe,"mouseenter",e[14]),w(Ge,"mouseenter",e[15]),w(ht,"mouseenter",e[16])],Je=!0)},p(ie,[ze]){const le={};ze&131072&&(le.$$scope={dirty:ze,ctx:ie}),C.$set(le)},i(ie){ot||(fe(C.$$.fragment,ie),ot=!0)},o(ie){be(C.$$.fragment,ie),ot=!1},d(ie){ie&&r(t),ie&&r(s),ie&&r(o),ke(C),ie&&r(Te),ie&&r(We),ie&&r(_e),ie&&r(X),ie&&r(st),ie&&r(Ue),Je=!1,jn(At)}}}function Ot(e){console.log(e)}function Lm(e){return[()=>Ot(["N"]),()=>Ot(["N","r"]),()=>Ot(["a","f","r","N"]),()=>Ot(["f"]),()=>Ot(["r"]),()=>Ot(["f"]),()=>Ot(["p"]),()=>Ot(["f","p","r"]),()=>Ot(["r"]),()=>Ot(["a","f","N"]),()=>Ot(["f","p"]),()=>Ot(["p"]),()=>Ot(["f"]),()=>Ot([]),()=>Ot(["r"]),()=>Ot(["r"]),()=>Ot(["f"])]}class Im extends rn{constructor(t){super(),sn(this,t,Lm,Hm,on,{})}}function Fm(e){let t,a,s,o,c;return o=new Im({}),{c(){t=h("h2"),a=i("Shor's Algorithm"),s=q(),ge(o.$$.fragment)},l(p){t=u(p,"H2",{});var m=f(t);a=l(m,"Shor's Algorithm"),m.forEach(r),s=H(p),ye(o.$$.fragment,p)},m(p,m){y(p,t,m),n(t,a),y(p,s,m),$e(o,p,m),c=!0},p:Ia,i(p){c||(fe(o.$$.fragment,p),c=!0)},o(p){be(o.$$.fragment,p),c=!1},d(p){p&&r(t),p&&r(s),ke(o,p)}}}class zm extends rn{constructor(t){super(),sn(this,t,null,Fm,on,{})}}function Vm(e){let t,a,s,o,c,p,m,b,_,N,v,k,$,A,G,j,P,C,F,S;return $=new yu({}),G=new Am({}),P=new Bf({}),F=new zm({}),{c(){t=h("div"),a=q(),s=h("main"),o=h("h1"),c=i("Interactive Quantum Computing"),p=q(),m=h("p"),b=i("This page intends to introduce concepts, connect them and derive a practical use case"),_=q(),N=h("h2"),v=i("Clickable Table of Contents"),k=q(),ge($.$$.fragment),A=q(),ge(G.$$.fragment),j=q(),ge(P.$$.fragment),C=q(),ge(F.$$.fragment),this.h()},l(z){t=u(z,"DIV",{class:!0}),f(t).forEach(r),a=H(z),s=u(z,"MAIN",{});var M=f(s);o=u(M,"H1",{});var Z=f(o);c=l(Z,"Interactive Quantum Computing"),Z.forEach(r),p=H(M),m=u(M,"P",{});var K=f(m);b=l(K,"This page intends to introduce concepts, connect them and derive a practical use case"),K.forEach(r),_=H(M),N=u(M,"H2",{});var Q=f(N);v=l(Q,"Clickable Table of Contents"),Q.forEach(r),k=H(M),ye($.$$.fragment,M),A=H(M),ye(G.$$.fragment,M),j=H(M),ye(P.$$.fragment,M),C=H(M),ye(F.$$.fragment,M),M.forEach(r),this.h()},h(){V(t,"class","sidebar")},m(z,M){y(z,t,M),y(z,a,M),y(z,s,M),n(s,o),n(o,c),n(s,p),n(s,m),n(m,b),n(s,_),n(s,N),n(N,v),n(s,k),$e($,s,null),n(s,A),$e(G,s,null),n(s,j),$e(P,s,null),n(s,C),$e(F,s,null),S=!0},p:Ia,i(z){S||(fe($.$$.fragment,z),fe(G.$$.fragment,z),fe(P.$$.fragment,z),fe(F.$$.fragment,z),S=!0)},o(z){be($.$$.fragment,z),be(G.$$.fragment,z),be(P.$$.fragment,z),be(F.$$.fragment,z),S=!1},d(z){z&&r(t),z&&r(a),z&&r(s),ke($),ke(G),ke(P),ke(F)}}}const Rm=!0;class Qm extends rn{constructor(t){super(),sn(this,t,null,Vm,on,{})}}export{Qm as default,Rm as prerender};
