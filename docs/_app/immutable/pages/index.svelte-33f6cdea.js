import{S as Mt,i as Nt,s as xt,l as r,u as h,a as I,x as pe,m as i,p as l,v as c,h as s,c as M,y as fe,q as _,b as D,H as t,z as de,L as v,f as ne,t as oe,C as _e,M as Lt,N as Zt,O as Ut,n as Qt,P as Wt,Q as Jt,R as zt,T as Bt,U as _t,V as gt,W as Ot,r as Rt,X as Ce,d as Kt,Y as Vt,Z as Gt,g as ea,_ as bt}from"../chunks/index-ca49edcf.js";import{Q as Dt}from"../chunks/Qubit-bb2ae073.js";import{H as pt,Q as ta,a as aa,s as Yt}from"../chunks/QuantumQubit-3771066f.js";import{m as P,a as ct,d as na,s as sa,b as ra,c as St,p as It}from"../chunks/index-ba7e8b36.js";import{s as vt}from"../chunks/qgates-46947dcc.js";const ia='<a href="https://en.wikipedia.org/wiki/Operator_(physics)"><h3>Operator (physics)</h3></a><p>In physics, an <b>operator</b> is a function over a space of physical states onto another space of physical states. The simplest example of the utility of operators is the study of symmetry. Because of this, they are very useful tools in classical mechanics. Operators are even more important in quantum mechanics, where they form an intrinsic part of the formulation of the theory.</p>',la=`<a href="https://en.wikipedia.org/wiki/Quantum_circuit"><h3>Quantum circuit</h3></a><p>In quantum information theory, a <b>quantum circuit</b> is a model for quantum computation, similar to classical circuits, in which a computation is a sequence of quantum gates, measurements, initializations of qubits to known values, and possibly other actions. The minimum set of actions that a circuit needs to be able to perform on the qubits to enable quantum computation is known as DiVincenzo's criteria.</p>`,oa='<a href="https://en.wikipedia.org/wiki/Quantum_logic_gate"><h3>Quantum logic gate</h3></a><p>In quantum computing and specifically the quantum circuit model of computation, a <b>quantum logic gate</b> is a basic quantum circuit operating on a small number of qubits. They are the building blocks of quantum circuits, like classical logic gates are for conventional digital circuits.</p>';function ua(a){let e;return{c(){e=h("Quantum operators")},l(n){e=c(n,"Quantum operators")},m(n,u){D(n,e,u)},d(n){n&&s(e)}}}function ma(a){let e;return{c(){e=h("quantum circuit")},l(n){e=c(n,"quantum circuit")},m(n,u){D(n,e,u)},d(n){n&&s(e)}}}function ha(a){let e;return{c(){e=h("quantum logic gates")},l(n){e=c(n,"quantum logic gates")},m(n,u){D(n,e,u)},d(n){n&&s(e)}}}function ca(a){let e,n,u,f,p,y,q,x,d,b,H,o,T,L,Y=P("\\begin{bmatrix}\\alpha\\\\\\beta\\end{bmatrix}")+"",se,K,ee=P("U")+"",F,k,ke=P("|\\psi\\rangle")+"",Ae,S,He=P("U|\\psi\\rangle")+"",te,$e,O=P("\\displaystyle H = \\frac{1}{\\sqrt{2}} \\cdot \\begin{bmatrix}1&1 \\\\ 1&-1\\end{bmatrix}")+"",X,ge,Fe=P("\\begin{bmatrix}1+0i\\\\0+0i\\end{bmatrix}")+"",U,Q,Se=P("\\begin{bmatrix}\\frac{1}{\\sqrt{2}}+0i\\\\\\frac{1}{\\sqrt{2}}+0i\\end{bmatrix}")+"",re,he,j,Ue,ae,ce,qe;return p=new pt({props:{hovertext:ia,$$slots:{default:[ua]},$$scope:{ctx:a}}}),q=new pt({props:{hovertext:la,$$slots:{default:[ma]},$$scope:{ctx:a}}}),d=new pt({props:{hovertext:oa,$$slots:{default:[ha]},$$scope:{ctx:a}}}),{c(){e=r("h2"),n=h("Quantum gates"),u=I(),f=r("p"),pe(p.$$.fragment),y=h(" are functions that act on the state of a quantum system. Quantum algorithms are sequences of specific quantum operators that modify the state of single or multiple qubits. The physical device that implements quantum algorithms is called a "),pe(q.$$.fragment),x=h(", the building blocks of which are "),pe(d.$$.fragment),b=h(" that correspond to the individual operators in the sequence."),H=I(),o=r("p"),T=h("For each quantum operator, there's a corresponding matrix and the state of the qubit can be written as a vector, "),L=r("span"),se=h(" so the algebraic representation of an operator "),K=r("span"),F=h(" acting on the state "),k=r("span"),Ae=h(" is essentially the matrix multiplication "),S=r("span"),te=h(". For example, the Hadamard gate is represented by the "),$e=r("span"),X=h(" matrix, which means it can transform a qubit from a state of "),ge=r("span"),U=h(" to "),Q=r("span"),re=h(". This is a slightly more complicated case of "),he=r("a"),j=h("thinking of matrices as linear transformations"),Ue=h(" - as complex numbers are involved - but the basic principles remain the same, and hopefully one can gather a decent understanding by tinkering with the Bloch sphere and its transformations below."),this.h()},l(E){e=i(E,"H2",{});var N=l(e);n=c(N,"Quantum gates"),N.forEach(s),u=M(E),f=i(E,"P",{});var z=l(f);fe(p.$$.fragment,z),y=c(z," are functions that act on the state of a quantum system. Quantum algorithms are sequences of specific quantum operators that modify the state of single or multiple qubits. The physical device that implements quantum algorithms is called a "),fe(q.$$.fragment,z),x=c(z,", the building blocks of which are "),fe(d.$$.fragment,z),b=c(z," that correspond to the individual operators in the sequence."),z.forEach(s),H=M(E),o=i(E,"P",{});var A=l(o);T=c(A,"For each quantum operator, there's a corresponding matrix and the state of the qubit can be written as a vector, "),L=i(A,"SPAN",{});var W=l(L);W.forEach(s),se=c(A," so the algebraic representation of an operator "),K=i(A,"SPAN",{});var Le=l(K);Le.forEach(s),F=c(A," acting on the state "),k=i(A,"SPAN",{});var Ie=l(k);Ie.forEach(s),Ae=c(A," is essentially the matrix multiplication "),S=i(A,"SPAN",{});var Te=l(S);Te.forEach(s),te=c(A,". For example, the Hadamard gate is represented by the "),$e=i(A,"SPAN",{});var Ze=l($e);Ze.forEach(s),X=c(A," matrix, which means it can transform a qubit from a state of "),ge=i(A,"SPAN",{});var ie=l(ge);ie.forEach(s),U=c(A," to "),Q=i(A,"SPAN",{});var B=l(Q);B.forEach(s),re=c(A,". This is a slightly more complicated case of "),he=i(A,"A",{href:!0});var Oe=l(he);j=c(Oe,"thinking of matrices as linear transformations"),Oe.forEach(s),Ue=c(A," - as complex numbers are involved - but the basic principles remain the same, and hopefully one can gather a decent understanding by tinkering with the Bloch sphere and its transformations below."),A.forEach(s),this.h()},h(){_(he,"href","https://www.youtube.com/watch?v=kYB8IZa5AuE")},m(E,N){D(E,e,N),t(e,n),D(E,u,N),D(E,f,N),de(p,f,null),t(f,y),de(q,f,null),t(f,x),de(d,f,null),t(f,b),D(E,H,N),D(E,o,N),t(o,T),t(o,L),L.innerHTML=Y,t(o,se),t(o,K),K.innerHTML=ee,t(o,F),t(o,k),k.innerHTML=ke,t(o,Ae),t(o,S),S.innerHTML=He,t(o,te),t(o,$e),$e.innerHTML=O,t(o,X),t(o,ge),ge.innerHTML=Fe,t(o,U),t(o,Q),Q.innerHTML=Se,t(o,re),t(o,he),t(he,j),t(o,Ue),ae=!0,ce||(qe=[v(L,"mouseenter",a[0]),v(K,"mouseenter",a[1]),v(k,"mouseenter",a[2]),v(S,"mouseenter",a[3]),v($e,"mouseenter",a[4]),v(ge,"mouseenter",a[5]),v(Q,"mouseenter",a[6])],ce=!0)},p(E,[N]){const z={};N&128&&(z.$$scope={dirty:N,ctx:E}),p.$set(z);const A={};N&128&&(A.$$scope={dirty:N,ctx:E}),q.$set(A);const W={};N&128&&(W.$$scope={dirty:N,ctx:E}),d.$set(W)},i(E){ae||(ne(p.$$.fragment,E),ne(q.$$.fragment,E),ne(d.$$.fragment,E),ae=!0)},o(E){oe(p.$$.fragment,E),oe(q.$$.fragment,E),oe(d.$$.fragment,E),ae=!1},d(E){E&&s(e),E&&s(u),E&&s(f),_e(p),_e(q),_e(d),E&&s(H),E&&s(o),ce=!1,Lt(qe)}}}function ut(a){console.log(a)}function pa(a){return[()=>ut(["m","b","x","t","\\alpha","\\beta","r","a"]),()=>ut(["U"]),()=>ut(["\\psi"]),()=>ut(["\\psi","U"]),()=>ut(["m","b","H","x","t","r","a"]),()=>ut(["m","b","x","t","r","a"]),()=>ut(["m","b","x","t","r","a"])]}class fa extends Mt{constructor(e){super(),Nt(this,e,pa,ca,xt,{})}}const da='<a href="https://en.wikipedia.org/wiki/Imaginary_number"><h3>Imaginary number</h3></a><p>An <b>imaginary number</b> is a real number multiplied by the imaginary unit <span class="texhtml mvar" style="font-style:italic">i</span>, which is defined by its property <span class="texhtml "><i>i</i><sup>2</sup> = \u22121</span>. The square of an imaginary number <span class="texhtml mvar" style="font-style:italic">bi</span> is <span class="texhtml ">\u2212<i>b</i><sup>2</sup></span>. For example, <span class="texhtml ">5<i>i</i></span> is an imaginary number, and its square is <span class="texhtml ">\u221225</span>. By definition, zero is considered to be both real and imaginary.</p>',_a='<a href="https://en.wikipedia.org/wiki/Real_number"><h3>Real number</h3></a><p>In mathematics, a <b>real number</b> is a value of a continuous quantity that can represent a distance along a line. The adjective <i>real</i> in this context was introduced in the 17th century by Ren\xE9 Descartes, who distinguished between real and imaginary roots of polynomials. The real numbers include all the rational numbers, such as the integer \u22125 and the fraction 4/3, and all the irrational numbers, such as <span class="mwe-math-element"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/b4afc1e27d418021bf10898eb44a7f5f315735ff" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align:-0.671ex;width:3.098ex;height:3.009ex" /></span>. Included within the irrationals are the real transcendental numbers, such as <span><span class="texhtml mvar" style="font-style:italic">\u03C0</span></span> (3.14159265...). In addition to measuring distance, real numbers can be used to measure quantities such as time, mass, energy, velocity, and many more. The set of real numbers is denoted using the symbol <b>R</b> or <span class="mwe-math-element"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/786849c765da7a84dbc3cce43e96aad58a5868dc" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align:-0.338ex;width:1.678ex;height:2.176ex" /></span> and is sometimes called "the reals".</p>',ga='<a href="https://en.wikipedia.org/wiki/Complex_plane"><h3>Complex plane</h3></a><p>In mathematics, the <b>complex plane</b> is the plane formed by the complex numbers, with a Cartesian coordinate system such that the <span class="texhtml mvar" style="font-style:italic">x</span>-axis, called <b>real axis</b>, is formed by the real numbers, and the <span class="texhtml mvar" style="font-style:italic">y</span>-axis, called <b>imaginary axis</b>, is formed by the imaginary numbers.</p>';function ba(a){let e;return{c(){e=h("imaginary")},l(n){e=c(n,"imaginary")},m(n,u){D(n,e,u)},d(n){n&&s(e)}}}function va(a){let e;return{c(){e=h("real")},l(n){e=c(n,"real")},m(n,u){D(n,e,u)},d(n){n&&s(e)}}}function ya(a){let e;return{c(){e=h("complex plane")},l(n){e=c(n,"complex plane")},m(n,u){D(n,e,u)},d(n){n&&s(e)}}}function wa(a){let e,n,u,f=P("z \\in \\mathbb{C}")+"",p,y,q=P("z = a i + b,")+"",x,d,b=P("a, b \\in \\mathbb{R}")+"",H,o,T=P("i = \\sqrt{-1}.")+"",L,Y,se=P("a")+"",K,ee,F,k,ke=P("b")+"",Ae,S,He,te,$e=P("z.")+"",O,X,ge=P("a=0")+"",Fe,U,Q,Se,re,he,j,Ue=P("x")+"",ae,ce,qe=P("y")+"",E,N,z,A,W,Le=P("\\Vert{z}\\Vert = \\sqrt{a^2 + b^2}")+"",Ie,Te,Ze=P("z.")+"",ie,B,Oe=P("\\Vert{z}\\Vert^2 = a^2 + b^2")+"",ft,J,V,Re,Ge,ue=P("z")+"",We,Ee,dt=P("\\Vert{z}\\Vert \\cdot e^{i \\phi_z},")+"",Je,Pe,Me=P("\\phi_z \\in [0, 2\\pi].")+"",Ke,ze,et=P("e^{i \\phi_z}")+"",tt,Be,Ne=P("\\phi_z")+"",at,be,xe=P("2\\pi")+"",nt,Ve,Ye=P("z,")+"",ve,De,st=P("\\Vert{z}\\Vert")+"",rt,it,C,yt;return ee=new pt({props:{hovertext:da,$$slots:{default:[ba]},$$scope:{ctx:a}}}),S=new pt({props:{hovertext:_a,$$slots:{default:[va]},$$scope:{ctx:a}}}),re=new pt({props:{hovertext:ga,$$slots:{default:[ya]},$$scope:{ctx:a}}}),{c(){e=r("p"),n=h("The general form of a complex number "),u=r("span"),p=h(" is the following: "),y=r("span"),x=h(" where "),d=r("span"),H=h(" and "),o=r("span"),L=I(),Y=r("span"),K=h(" is called the "),pe(ee.$$.fragment),F=h(" and "),k=r("span"),Ae=h(" the "),pe(S.$$.fragment),He=h(" component of "),te=r("span"),O=h(" In fact, all real numbers are complex numbers, the imaginary component of which is zero ("),X=r("span"),Fe=h(")."),U=I(),Q=r("p"),Se=h("Complex numbers can be represented geometrically as two-dimensional vectors in the so called "),pe(re.$$.fragment),he=h(", where the "),j=r("span"),ae=h("-axis stands for the real, and the "),ce=r("span"),E=h("-axis for the imaginary component."),N=I(),z=r("p"),A=h("Let "),W=r("span"),Ie=h(" denote the Euclidean norm of the vector associated with the complex number "),Te=r("span"),ie=h(" Consequently, "),B=r("span"),ft=h(" is the square of this norm, and it's going to play an important role in what follows."),J=I(),V=r("p"),Re=h("Another important thing to note is that each 2-dimensional vector is uniquely defined by two properties: its length and angle of rotation. Consequently, a complex number "),Ge=r("span"),We=h(" can be expressed as "),Ee=r("span"),Je=h(" where "),Pe=r("span"),Ke=h(" Here, "),ze=r("span"),tt=h(" is a vector of unit length in the complex plane, rotated around the origin by an angle of "),Be=r("span"),at=h(" ("),be=r("span"),nt=h(" corresponds to a full rotation). All we have to do to get back "),Ve=r("span"),ve=h(" then, is multiply this rotated unit vector by "),De=r("span"),rt=h(" to adjust its norm.")},l($){e=i($,"P",{});var w=l(e);n=c(w,"The general form of a complex number "),u=i(w,"SPAN",{});var lt=l(u);lt.forEach(s),p=c(w," is the following: "),y=i(w,"SPAN",{});var mt=l(y);mt.forEach(s),x=c(w," where "),d=i(w,"SPAN",{});var ot=l(d);ot.forEach(s),H=c(w," and "),o=i(w,"SPAN",{});var m=l(o);m.forEach(s),L=M(w),Y=i(w,"SPAN",{});var g=l(Y);g.forEach(s),K=c(w," is called the "),fe(ee.$$.fragment,w),F=c(w," and "),k=i(w,"SPAN",{});var Qe=l(k);Qe.forEach(s),Ae=c(w," the "),fe(S.$$.fragment,w),He=c(w," component of "),te=i(w,"SPAN",{});var Xe=l(te);Xe.forEach(s),O=c(w," In fact, all real numbers are complex numbers, the imaginary component of which is zero ("),X=i(w,"SPAN",{});var ye=l(X);ye.forEach(s),Fe=c(w,")."),w.forEach(s),U=M($),Q=i($,"P",{});var Z=l(Q);Se=c(Z,"Complex numbers can be represented geometrically as two-dimensional vectors in the so called "),fe(re.$$.fragment,Z),he=c(Z,", where the "),j=i(Z,"SPAN",{});var wt=l(j);wt.forEach(s),ae=c(Z,"-axis stands for the real, and the "),ce=i(Z,"SPAN",{});var $t=l(ce);$t.forEach(s),E=c(Z,"-axis for the imaginary component."),Z.forEach(s),N=M($),z=i($,"P",{});var we=l(z);A=c(we,"Let "),W=i(we,"SPAN",{});var me=l(W);me.forEach(s),Ie=c(we," denote the Euclidean norm of the vector associated with the complex number "),Te=i(we,"SPAN",{});var qt=l(Te);qt.forEach(s),ie=c(we," Consequently, "),B=i(we,"SPAN",{});var ht=l(B);ht.forEach(s),ft=c(we," is the square of this norm, and it's going to play an important role in what follows."),we.forEach(s),J=M($),V=i($,"P",{});var R=l(V);Re=c(R,"Another important thing to note is that each 2-dimensional vector is uniquely defined by two properties: its length and angle of rotation. Consequently, a complex number "),Ge=i(R,"SPAN",{});var Tt=l(Ge);Tt.forEach(s),We=c(R," can be expressed as "),Ee=i(R,"SPAN",{});var Et=l(Ee);Et.forEach(s),Je=c(R," where "),Pe=i(R,"SPAN",{});var je=l(Pe);je.forEach(s),Ke=c(R," Here, "),ze=i(R,"SPAN",{});var le=l(ze);le.forEach(s),tt=c(R," is a vector of unit length in the complex plane, rotated around the origin by an angle of "),Be=i(R,"SPAN",{});var Pt=l(Be);Pt.forEach(s),at=c(R," ("),be=i(R,"SPAN",{});var kt=l(be);kt.forEach(s),nt=c(R," corresponds to a full rotation). All we have to do to get back "),Ve=i(R,"SPAN",{});var At=l(Ve);At.forEach(s),ve=c(R," then, is multiply this rotated unit vector by "),De=i(R,"SPAN",{});var Ht=l(De);Ht.forEach(s),rt=c(R," to adjust its norm."),R.forEach(s)},m($,w){D($,e,w),t(e,n),t(e,u),u.innerHTML=f,t(e,p),t(e,y),y.innerHTML=q,t(e,x),t(e,d),d.innerHTML=b,t(e,H),t(e,o),o.innerHTML=T,t(e,L),t(e,Y),Y.innerHTML=se,t(e,K),de(ee,e,null),t(e,F),t(e,k),k.innerHTML=ke,t(e,Ae),de(S,e,null),t(e,He),t(e,te),te.innerHTML=$e,t(e,O),t(e,X),X.innerHTML=ge,t(e,Fe),D($,U,w),D($,Q,w),t(Q,Se),de(re,Q,null),t(Q,he),t(Q,j),j.innerHTML=Ue,t(Q,ae),t(Q,ce),ce.innerHTML=qe,t(Q,E),D($,N,w),D($,z,w),t(z,A),t(z,W),W.innerHTML=Le,t(z,Ie),t(z,Te),Te.innerHTML=Ze,t(z,ie),t(z,B),B.innerHTML=Oe,t(z,ft),D($,J,w),D($,V,w),t(V,Re),t(V,Ge),Ge.innerHTML=ue,t(V,We),t(V,Ee),Ee.innerHTML=dt,t(V,Je),t(V,Pe),Pe.innerHTML=Me,t(V,Ke),t(V,ze),ze.innerHTML=et,t(V,tt),t(V,Be),Be.innerHTML=Ne,t(V,at),t(V,be),be.innerHTML=xe,t(V,nt),t(V,Ve),Ve.innerHTML=Ye,t(V,ve),t(V,De),De.innerHTML=st,t(V,rt),it=!0,C||(yt=[v(u,"mouseenter",a[0]),v(y,"mouseenter",a[1]),v(d,"mouseenter",a[2]),v(o,"mouseenter",a[3]),v(Y,"mouseenter",a[4]),v(k,"mouseenter",a[5]),v(te,"mouseenter",a[6]),v(X,"mouseenter",a[7]),v(j,"mouseenter",a[8]),v(ce,"mouseenter",a[9]),v(W,"mouseenter",a[10]),v(Te,"mouseenter",a[11]),v(B,"mouseenter",a[12]),v(Ge,"mouseenter",a[13]),v(Ee,"mouseenter",a[14]),v(Pe,"mouseenter",a[15]),v(ze,"mouseenter",a[16]),v(Be,"mouseenter",a[17]),v(be,"mouseenter",a[18]),v(Ve,"mouseenter",a[19]),v(De,"mouseenter",a[20])],C=!0)},p($,[w]){const lt={};w&2097152&&(lt.$$scope={dirty:w,ctx:$}),ee.$set(lt);const mt={};w&2097152&&(mt.$$scope={dirty:w,ctx:$}),S.$set(mt);const ot={};w&2097152&&(ot.$$scope={dirty:w,ctx:$}),re.$set(ot)},i($){it||(ne(ee.$$.fragment,$),ne(S.$$.fragment,$),ne(re.$$.fragment,$),it=!0)},o($){oe(ee.$$.fragment,$),oe(S.$$.fragment,$),oe(re.$$.fragment,$),it=!1},d($){$&&s(e),_e(ee),_e(S),$&&s(U),$&&s(Q),_e(re),$&&s(N),$&&s(z),$&&s(J),$&&s(V),C=!1,Lt(yt)}}}function G(a){console.log(a)}function $a(a){return[()=>G(["z","C"]),()=>G(["z","b","a"]),()=>G(["R","b","a"]),()=>G([]),()=>G(["a"]),()=>G(["b"]),()=>G(["z"]),()=>G(["a"]),()=>G(["x"]),()=>G(["y"]),()=>G(["z","b","a"]),()=>G(["z"]),()=>G(["z","b","a"]),()=>G(["z"]),()=>G(["z","\\phi"]),()=>G(["\\phi","z"]),()=>G(["\\phi","z"]),()=>G(["\\phi","z"]),()=>G([]),()=>G(["z"]),()=>G(["z"])]}class qa extends Mt{constructor(e){super(),Nt(this,e,$a,wa,xt,{})}}function Xt(a,e,n){const u=a.slice();return u[10]=e[n],u}function jt(a){let e,n=a[10].name+"",u,f;return{c(){e=r("option"),u=h(n),f=I(),this.h()},l(p){e=i(p,"OPTION",{});var y=l(e);u=c(y,n),f=M(y),y.forEach(s),this.h()},h(){e.__value=a[10],e.value=e.__value},m(p,y){D(p,e,y),t(e,u),t(e,f)},p:Qt,d(p){p&&s(e)}}}function Ta(a){let e,n,u,f,p=P(a[1])+"",y,q,x=a[2],d=[];for(let b=0;b<x.length;b+=1)d[b]=jt(Xt(a,x,b));return{c(){e=r("div"),n=r("select");for(let b=0;b<d.length;b+=1)d[b].c();u=I(),f=r("div"),this.h()},l(b){e=i(b,"DIV",{class:!0});var H=l(e);n=i(H,"SELECT",{});var o=l(n);for(let L=0;L<d.length;L+=1)d[L].l(o);o.forEach(s),H.forEach(s),u=M(b),f=i(b,"DIV",{class:!0});var T=l(f);T.forEach(s),this.h()},h(){a[0]===void 0&&Zt(()=>a[7].call(n)),_(e,"class","pt-4"),_(f,"class","pt-4")},m(b,H){D(b,e,H),t(e,n);for(let o=0;o<d.length;o+=1)d[o].m(n,null);Ut(n,a[0]),D(b,u,H),D(b,f,H),f.innerHTML=p,y||(q=[v(n,"change",a[7]),v(n,"change",a[3])],y=!0)},p(b,[H]){if(H&4){x=b[2];let o;for(o=0;o<x.length;o+=1){const T=Xt(b,x,o);d[o]?d[o].p(T,H):(d[o]=jt(T),d[o].c(),d[o].m(n,null))}for(;o<d.length;o+=1)d[o].d(1);d.length=x.length}H&5&&Ut(n,b[0]),H&2&&p!==(p=P(b[1])+"")&&(f.innerHTML=p)},i:Qt,o:Qt,d(b){b&&s(e),Wt(d,b),b&&s(u),b&&s(f),y=!1,Lt(q)}}}function Ea(a,e,n){let u=[{name:"Identity Gate",matrix:ct([[1,0],[0,1]]),display:"{\\displaystyle I={\\begin{bmatrix}1&0\\\\0&1\\end{bmatrix}}}"},{name:"Hadamard Gate",matrix:vt.H,display:"{\\displaystyle H={\\frac {1}{\\sqrt {2}}}{\\begin{bmatrix}1&1 \\\\ 1&-1\\end{bmatrix}}}"},{name:"Pauli-X",matrix:ct(vt.X),display:"{\\displaystyle X=\\sigma _{x}=\\operatorname {NOT} ={\\begin{bmatrix}0&1\\\\1&0\\end{bmatrix}}}"},{name:"Pauli-Y",matrix:ct(vt.Y),display:"{\\displaystyle Y=\\sigma _{y}={\\begin{bmatrix}0&-i\\\\i&0\\end{bmatrix}}}"},{name:"Pauli-Z",matrix:ct(vt.Z),display:"{\\displaystyle Z=\\sigma _{z}={\\begin{bmatrix}1&0\\\\0&-1\\end{bmatrix}}}"},{name:"\u221ANOT",matrix:vt.sqrtX,display:"{\\displaystyle {\\sqrt {X}}={\\sqrt {\\text{NOT}}}={\\frac{1}{2}}{\\begin{bmatrix}1+i&1-i\\\\1-i&1+i \\end{bmatrix}}}"}],{gate:f=u[0]}=e,{transitionTime:p=800}=e,{transitionSteps:y=20}=e,{currentMatrix:q=u[0].matrix}=e,x,d="";function b(){x=na(sa(f.matrix,q),y),H(0),n(1,d=f.display)}function H(T){setTimeout(()=>{n(4,q=ra(q,x)),T>=y-1?n(4,q=f.matrix):H(T+1)},p/y)}function o(){f=Jt(this),n(0,f),n(2,u)}return a.$$set=T=>{"gate"in T&&n(0,f=T.gate),"transitionTime"in T&&n(5,p=T.transitionTime),"transitionSteps"in T&&n(6,y=T.transitionSteps),"currentMatrix"in T&&n(4,q=T.currentMatrix)},[f,d,u,b,q,p,y,o]}class Pa extends Mt{constructor(e){super(),Nt(this,e,Ea,Ta,xt,{gate:0,transitionTime:5,transitionSteps:6,currentMatrix:4})}}function Ft(a){let e,n,u,f;return n=new qa({}),{c(){e=r("div"),pe(n.$$.fragment)},l(p){e=i(p,"DIV",{});var y=l(e);fe(n.$$.fragment,y),y.forEach(s)},m(p,y){D(p,e,y),de(n,e,null),f=!0},i(p){f||(ne(n.$$.fragment,p),Zt(()=>{u||(u=Gt(e,Yt,{duration:400},!0)),u.run(1)}),f=!0)},o(p){oe(n.$$.fragment,p),u||(u=Gt(e,Yt,{duration:400},!1)),u.run(0),f=!1},d(p){p&&s(e),_e(n),p&&u&&u.end()}}}function ka(a){let e,n,u,f,p,y,q,x,d,b,H,o,T,L,Y,se,K,ee,F,k,ke,Ae=P("\\phi_\\alpha")+"",S,He,te,$e=P("\\phi_\\beta")+"",O,X,ge,Fe=P("r_\\alpha")+"",U,Q,Se,re,he,j,Ue,ae,ce,qe,E,N,z,A,W,Le,Ie,Te,Ze,ie,B,Oe,ft=P("\\theta")+"",J,V,Re,Ge=P("\\phi")+"",ue,We,Ee,dt,Je,Pe,Me,Ke,ze,et,tt,Be,Ne,at,be,xe,nt,Ve,Ye,ve,De,st,rt,it;p=new ta({});let C=a[9]&&Ft();ae=new Dt({props:{displayBloch:a[6],phiAlpha:a[13],phiBeta:a[12],rAlpha:a[5],blochClass:"col-lg-4 col-md-12",vectorClass:"col-lg-4 col-md-12"}}),qe=new aa({}),N=new fa({});function yt(m){a[21](m)}let $={};a[8]!==void 0&&($.currentMatrix=a[8]),Me=new Pa({props:$}),zt.push(()=>Bt(Me,"currentMatrix",yt));function w(m){a[23](m)}let lt={displayBloch:a[7],displayVectors:!a[7],phiBeta:-a[10],rAlpha:St(a[11]/2)};a[4]!==void 0&&(lt.cameraPosition=a[4]),xe=new Dt({props:lt}),zt.push(()=>Bt(xe,"cameraPosition",w));function mt(m){a[24](m)}let ot={displayBloch:a[7],displayVectors:!a[7],phiBeta:-a[10],rAlpha:St(a[11]/2),quantumGates:[a[8]]};return a[4]!==void 0&&(ot.cameraPosition=a[4]),ve=new Dt({props:ot}),zt.push(()=>Bt(ve,"cameraPosition",mt)),{c(){e=r("init"),n=r("h1"),u=h("Quantum Tinkering"),f=I(),pe(p.$$.fragment),y=I(),q=r("h2"),x=h("Important properties of complex numbers "),d=r("span"),H=I(),C&&C.c(),o=I(),T=r("div"),L=r("div"),Y=r("div"),se=r("p"),K=h(`Play around with 2 representations of a single qubit. You adjust the view of the 3D Bloch
					sphere by clicking on the image and dragging.`),ee=I(),F=r("div"),k=r("div"),ke=new _t(!1),S=r("input"),He=I(),te=new _t(!1),O=r("input"),X=I(),ge=new _t(!1),U=r("input"),Q=I(),Se=r("b"),re=h("Display Bloch sphere"),he=I(),j=r("input"),Ue=I(),pe(ae.$$.fragment),ce=I(),pe(qe.$$.fragment),E=I(),pe(N.$$.fragment),z=I(),A=r("div"),W=r("div"),Le=r("div"),Ie=r("p"),Te=h("Look at the how a quantum gate - expressed as a unitary matrix - transforms a Bloch sphere"),Ze=I(),ie=r("div"),B=r("div"),Oe=new _t(!1),J=r("input"),V=I(),Re=new _t(!1),ue=r("input"),We=I(),Ee=r("span"),dt=h("Select quantum gate"),Je=I(),Pe=r("div"),pe(Me.$$.fragment),ze=I(),et=r("b"),tt=h("Toggle Bloch/vectors"),Be=I(),Ne=r("input"),at=I(),be=r("div"),pe(xe.$$.fragment),Ve=I(),Ye=r("div"),pe(ve.$$.fragment),this.h()},l(m){e=i(m,"INIT",{class:!0});var g=l(e);n=i(g,"H1",{});var Qe=l(n);u=c(Qe,"Quantum Tinkering"),Qe.forEach(s),f=M(g),fe(p.$$.fragment,g),y=M(g),q=i(g,"H2",{type:!0});var Xe=l(q);x=c(Xe,"Important properties of complex numbers "),d=i(Xe,"SPAN",{class:!0}),l(d).forEach(s),Xe.forEach(s),H=M(g),C&&C.l(g),o=M(g),T=i(g,"DIV",{class:!0});var ye=l(T);L=i(ye,"DIV",{class:!0});var Z=l(L);Y=i(Z,"DIV",{class:!0});var wt=l(Y);se=i(wt,"P",{});var $t=l(se);K=c($t,`Play around with 2 representations of a single qubit. You adjust the view of the 3D Bloch
					sphere by clicking on the image and dragging.`),$t.forEach(s),wt.forEach(s),Z.forEach(s),ee=M(ye),F=i(ye,"DIV",{class:!0});var we=l(F);k=i(we,"DIV",{class:!0});var me=l(k);ke=gt(me,!1),S=i(me,"INPUT",{type:!0,min:!0,max:!0,step:!0,class:!0}),He=M(me),te=gt(me,!1),O=i(me,"INPUT",{type:!0,min:!0,max:!0,step:!0,class:!0}),X=M(me),ge=gt(me,!1),U=i(me,"INPUT",{type:!0,min:!0,max:!0,step:!0,class:!0}),Q=M(me),Se=i(me,"B",{});var qt=l(Se);re=c(qt,"Display Bloch sphere"),qt.forEach(s),he=M(me),j=i(me,"INPUT",{type:!0,style:!0,class:!0}),me.forEach(s),Ue=M(we),fe(ae.$$.fragment,we),we.forEach(s),ye.forEach(s),ce=M(g),fe(qe.$$.fragment,g),E=M(g),fe(N.$$.fragment,g),z=M(g),A=i(g,"DIV",{class:!0});var ht=l(A);W=i(ht,"DIV",{class:!0});var R=l(W);Le=i(R,"DIV",{class:!0});var Tt=l(Le);Ie=i(Tt,"P",{});var Et=l(Ie);Te=c(Et,"Look at the how a quantum gate - expressed as a unitary matrix - transforms a Bloch sphere"),Et.forEach(s),Tt.forEach(s),R.forEach(s),Ze=M(ht),ie=i(ht,"DIV",{class:!0});var je=l(ie);B=i(je,"DIV",{class:!0});var le=l(B);Oe=gt(le,!1),J=i(le,"INPUT",{type:!0,min:!0,max:!0,step:!0,class:!0}),V=M(le),Re=gt(le,!1),ue=i(le,"INPUT",{type:!0,min:!0,max:!0,step:!0,class:!0}),We=M(le),Ee=i(le,"SPAN",{});var Pt=l(Ee);dt=c(Pt,"Select quantum gate"),Pt.forEach(s),Je=M(le),Pe=i(le,"DIV",{});var kt=l(Pe);fe(Me.$$.fragment,kt),kt.forEach(s),ze=M(le),et=i(le,"B",{});var At=l(et);tt=c(At,"Toggle Bloch/vectors"),At.forEach(s),Be=M(le),Ne=i(le,"INPUT",{type:!0,style:!0,class:!0}),le.forEach(s),at=M(je),be=i(je,"DIV",{class:!0});var Ht=l(be);fe(xe.$$.fragment,Ht),Ht.forEach(s),Ve=M(je),Ye=i(je,"DIV",{class:!0});var Ct=l(Ye);fe(ve.$$.fragment,Ct),Ct.forEach(s),je.forEach(s),ht.forEach(s),g.forEach(s),this.h()},h(){_(d,"class",b=Ot(`arrow ${a[9]?"down":""}`)+" svelte-1cvfsm5"),_(q,"type","button"),_(Y,"class","col-12"),_(L,"class","row mb-4"),ke.a=S,_(S,"type","range"),_(S,"min",0),_(S,"max",360),_(S,"step",1),_(S,"class","svelte-1cvfsm5"),te.a=O,_(O,"type","range"),_(O,"min",0),_(O,"max",360),_(O,"step",1),_(O,"class","svelte-1cvfsm5"),ge.a=U,_(U,"type","range"),_(U,"min",0),_(U,"max",1),_(U,"step",.01),_(U,"class","svelte-1cvfsm5"),_(j,"type","checkbox"),Rt(j,"width","auto"),_(j,"class","svelte-1cvfsm5"),_(k,"class","col-lg-4 col-md-12"),_(F,"class","row"),_(T,"class","interaction container mt-3"),_(Le,"class","col-12"),_(W,"class","row mb-4"),Oe.a=J,_(J,"type","range"),_(J,"min",0),_(J,"max",180),_(J,"step",1),_(J,"class","svelte-1cvfsm5"),Re.a=ue,_(ue,"type","range"),_(ue,"min",0),_(ue,"max",360),_(ue,"step",1),_(ue,"class","svelte-1cvfsm5"),_(Ne,"type","checkbox"),Rt(Ne,"width","auto"),_(Ne,"class","svelte-1cvfsm5"),_(B,"class","col-lg-4 col-md-12"),_(be,"class","col-lg-4 col-md-12"),_(Ye,"class","col-lg-4 col-md-12"),_(ie,"class","row"),_(A,"class","interaction container"),_(e,"class","svelte-1cvfsm5")},m(m,g){D(m,e,g),t(e,n),t(n,u),t(e,f),de(p,e,null),t(e,y),t(e,q),t(q,x),t(q,d),t(e,H),C&&C.m(e,null),t(e,o),t(e,T),t(T,L),t(L,Y),t(Y,se),t(se,K),t(T,ee),t(T,F),t(F,k),ke.m(Ae,k),t(k,S),Ce(S,a[0]),t(k,He),te.m($e,k),t(k,O),Ce(O,a[1]),t(k,X),ge.m(Fe,k),t(k,U),Ce(U,a[5]),t(k,Q),t(k,Se),t(Se,re),t(k,he),t(k,j),j.checked=a[6],t(F,Ue),de(ae,F,null),t(e,ce),de(qe,e,null),t(e,E),de(N,e,null),t(e,z),t(e,A),t(A,W),t(W,Le),t(Le,Ie),t(Ie,Te),t(A,Ze),t(A,ie),t(ie,B),Oe.m(ft,B),t(B,J),Ce(J,a[2]),t(B,V),Re.m(Ge,B),t(B,ue),Ce(ue,a[3]),t(B,We),t(B,Ee),t(Ee,dt),t(B,Je),t(B,Pe),de(Me,Pe,null),t(B,ze),t(B,et),t(et,tt),t(B,Be),t(B,Ne),Ne.checked=a[7],t(ie,at),t(ie,be),de(xe,be,null),t(ie,Ve),t(ie,Ye),de(ve,Ye,null),st=!0,rt||(it=[v(q,"click",a[14]),v(S,"change",a[15]),v(S,"input",a[15]),v(O,"change",a[16]),v(O,"input",a[16]),v(U,"change",a[17]),v(U,"input",a[17]),v(j,"change",a[18]),v(J,"change",a[19]),v(J,"input",a[19]),v(ue,"change",a[20]),v(ue,"input",a[20]),v(Ne,"change",a[22])],rt=!0)},p(m,[g]){(!st||g&512&&b!==(b=Ot(`arrow ${m[9]?"down":""}`)+" svelte-1cvfsm5"))&&_(d,"class",b),m[9]?C?g&512&&ne(C,1):(C=Ft(),C.c(),ne(C,1),C.m(e,o)):C&&(ea(),oe(C,1,1,()=>{C=null}),Kt()),g&1&&Ce(S,m[0]),g&2&&Ce(O,m[1]),g&32&&Ce(U,m[5]),g&64&&(j.checked=m[6]);const Qe={};g&64&&(Qe.displayBloch=m[6]),g&8192&&(Qe.phiAlpha=m[13]),g&4096&&(Qe.phiBeta=m[12]),g&32&&(Qe.rAlpha=m[5]),ae.$set(Qe),g&4&&Ce(J,m[2]),g&8&&Ce(ue,m[3]);const Xe={};!Ke&&g&256&&(Ke=!0,Xe.currentMatrix=m[8],Vt(()=>Ke=!1)),Me.$set(Xe),g&128&&(Ne.checked=m[7]);const ye={};g&128&&(ye.displayBloch=m[7]),g&128&&(ye.displayVectors=!m[7]),g&1024&&(ye.phiBeta=-m[10]),g&2048&&(ye.rAlpha=St(m[11]/2)),!nt&&g&16&&(nt=!0,ye.cameraPosition=m[4],Vt(()=>nt=!1)),xe.$set(ye);const Z={};g&128&&(Z.displayBloch=m[7]),g&128&&(Z.displayVectors=!m[7]),g&1024&&(Z.phiBeta=-m[10]),g&2048&&(Z.rAlpha=St(m[11]/2)),g&256&&(Z.quantumGates=[m[8]]),!De&&g&16&&(De=!0,Z.cameraPosition=m[4],Vt(()=>De=!1)),ve.$set(Z)},i(m){st||(ne(p.$$.fragment,m),ne(C),ne(ae.$$.fragment,m),ne(qe.$$.fragment,m),ne(N.$$.fragment,m),ne(Me.$$.fragment,m),ne(xe.$$.fragment,m),ne(ve.$$.fragment,m),st=!0)},o(m){oe(p.$$.fragment,m),oe(C),oe(ae.$$.fragment,m),oe(qe.$$.fragment,m),oe(N.$$.fragment,m),oe(Me.$$.fragment,m),oe(xe.$$.fragment,m),oe(ve.$$.fragment,m),st=!1},d(m){m&&s(e),_e(p),C&&C.d(),_e(ae),_e(qe),_e(N),_e(Me),_e(xe),_e(ve),rt=!1,Lt(it)}}}function Aa(a,e,n){let u,f,p,y,q={x:4,y:.3,z:.5},x=15,d=310,b=.9,H=!1,o=!0,T=30,L=50;ct([[1,0],[0,1]]);let Y=ct([[1,0],[0,1]]),se=!1;const K=()=>n(9,se=!se);function ee(){x=bt(this.value),n(0,x)}function F(){d=bt(this.value),n(1,d)}function k(){b=bt(this.value),n(5,b)}function ke(){H=this.checked,n(6,H)}function Ae(){T=bt(this.value),n(2,T)}function S(){L=bt(this.value),n(3,L)}function He(X){Y=X,n(8,Y)}function te(){o=this.checked,n(7,o)}function $e(X){q=X,n(4,q)}function O(X){q=X,n(4,q)}return a.$$.update=()=>{a.$$.dirty&1&&n(13,u=x/180*It),a.$$.dirty&2&&n(12,f=d/180*It),a.$$.dirty&4&&n(11,p=T/180*It),a.$$.dirty&8&&n(10,y=L/180*It)},[x,d,T,L,q,b,H,o,Y,se,y,p,f,u,K,ee,F,k,ke,Ae,S,He,te,$e,O]}class xa extends Mt{constructor(e){super(),Nt(this,e,Aa,ka,xt,{})}}export{xa as default};
