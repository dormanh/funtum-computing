import{S as jt,i as Dt,s as Rt,l as r,u as a,a as q,L as Ce,e as Io,m as o,p as l,v as s,h as t,c as I,M as We,q as de,b as _,H as e,N as on,O as m,P as Nh,Q as Qn,R as Th,n as vt,T as mn,F as Ph,I as $h,J as Sh,K as kh,f as Je,t as ht,U as Ah,V as Mh,x as ft,y as _t,z as dt,C as ct,W as ho,X as uo,Y as mo,Z as Fo}from"../chunks/index-bb217d03.js";import{m as h,g as gs,Q as Vo,C as Hh,p as Bo}from"../chunks/CameraControl-d03be3a0.js";function Lh(n){let i,f,d,u=h(`K = ${n[6]}`)+"",y,v,c=h("r")+"",g,b,B=h("a^r \\mod N = 1")+"",N,L,z,A,V,ee=h("r")+"",Q,S,C=h(`${n[1]}^{${n[2]}} \\mod ${n[0]} = 1`)+"",k,O,P=h("m")+"",j,M,W=h(`${n[1]}^{${n[2]}} = m \\cdot ${n[0]} + 1`)+"",U,G;function ne(T,D){return T[2]%2==0?Fh:Ih}let E=ne(n),F=E(n);return{c(){i=r("p"),f=a("As "),d=new Ce(!1),y=a(", the value of "),v=new Ce(!1),g=a(" in "),b=new Ce(!1),N=a(` will
		be informative.`),L=q(),z=r("p"),A=a(`As these are all relatively small numbers, we can try all relevant possible values for
		`),V=new Ce(!1),Q=a(" rather quickly and find that "),S=new Ce(!1),k=a(` which means
		that there is an `),O=new Ce(!1),j=a(" for which "),M=new Ce(!1),U=q(),G=r("p"),F.c(),this.h()},l(T){i=o(T,"P",{});var D=l(i);f=s(D,"As "),d=We(D,!1),y=s(D,", the value of "),v=We(D,!1),g=s(D," in "),b=We(D,!1),N=s(D,` will
		be informative.`),D.forEach(t),L=I(T),z=o(T,"P",{});var Y=l(z);A=s(Y,`As these are all relatively small numbers, we can try all relevant possible values for
		`),V=We(Y,!1),Q=s(Y," rather quickly and find that "),S=We(Y,!1),k=s(Y,` which means
		that there is an `),O=We(Y,!1),j=s(Y," for which "),M=We(Y,!1),Y.forEach(t),U=I(T),G=o(T,"P",{});var _e=l(G);F.l(_e),_e.forEach(t),this.h()},h(){d.a=y,v.a=g,b.a=N,V.a=Q,S.a=k,O.a=j,M.a=null},m(T,D){_(T,i,D),e(i,f),d.m(u,i),e(i,y),v.m(c,i),e(i,g),b.m(B,i),e(i,N),_(T,L,D),_(T,z,D),e(z,A),V.m(ee,z),e(z,Q),S.m(C,z),e(z,k),O.m(P,z),e(z,j),M.m(W,z),_(T,U,D),_(T,G,D),F.m(G,null)},p(T,D){D&64&&u!==(u=h(`K = ${T[6]}`)+"")&&d.p(u),D&7&&C!==(C=h(`${T[1]}^{${T[2]}} \\mod ${T[0]} = 1`)+"")&&S.p(C),D&7&&W!==(W=h(`${T[1]}^{${T[2]}} = m \\cdot ${T[0]} + 1`)+"")&&M.p(W),E===(E=ne(T))&&F?F.p(T,D):(F.d(1),F=E(T),F&&(F.c(),F.m(G,null)))},d(T){T&&t(i),T&&t(L),T&&t(z),T&&t(U),T&&t(G),F.d()}}}function qh(n){let i,f,d,u=h("K \\neq 1")+"",y,v,c=h("a")+"",g,b,B=h("N")+"",N,L,z=h(`K=${n[6]}`)+"",A,V,ee=h("a")+"",Q;return{c(){i=r("p"),f=a("As in this case "),d=new Ce(!1),y=a(", a new "),v=new Ce(!1),g=a(` is needed. Or to put a more positive
		spin on it, we instantly can found a prime factor for `),b=new Ce(!1),N=a(`, which in fact
		`),L=new Ce(!1),A=a(` is. However, in order to see the whole algorithm in action, we should choose
		a new `),V=new Ce(!1),Q=a("."),this.h()},l(S){i=o(S,"P",{});var C=l(i);f=s(C,"As in this case "),d=We(C,!1),y=s(C,", a new "),v=We(C,!1),g=s(C,` is needed. Or to put a more positive
		spin on it, we instantly can found a prime factor for `),b=We(C,!1),N=s(C,`, which in fact
		`),L=We(C,!1),A=s(C,` is. However, in order to see the whole algorithm in action, we should choose
		a new `),V=We(C,!1),Q=s(C,"."),C.forEach(t),this.h()},h(){d.a=y,v.a=g,b.a=N,L.a=A,V.a=Q},m(S,C){_(S,i,C),e(i,f),d.m(u,i),e(i,y),v.m(c,i),e(i,g),b.m(B,i),e(i,N),L.m(z,i),e(i,A),V.m(ee,i),e(i,Q)},p(S,C){C&64&&z!==(z=h(`K=${S[6]}`)+"")&&L.p(z)},d(S){S&&t(i)}}}function Ih(n){let i,f=h("r")+"",d,u,y=h("a")+"",v;return{c(){i=new Ce(!1),d=a(" is odd, we need a new "),u=new Ce(!1),v=a("."),this.h()},l(c){i=We(c,!1),d=s(c," is odd, we need a new "),u=We(c,!1),v=s(c,"."),this.h()},h(){i.a=d,u.a=v},m(c,g){i.m(f,c,g),_(c,d,g),u.m(y,c,g),_(c,v,g)},p:vt,d(c){c&&i.d(),c&&t(d),c&&u.d(),c&&t(v)}}}function Fh(n){let i,f,d=h("r")+"",u,y,v=h("b = a^{\\frac{r}{2}}")+"",c,g,b=h("a^r = m \\cdot N + 1 \\Rightarrow b^2-1 = (b + 1)(b - 1) = m \\cdot N")+"",B,N,L=h(`b = ${n[5]}`)+"",z,A,V=h("N")+"",ee,Q,S=h("b-1")+"",C,k,O=h("b+1")+"",P,j,M=h(`${gs(n[0],n[5]-1)}`)+"",W,U,G=h(`${gs(n[0],n[5]+1)}`)+"",ne;return{c(){i=a("As "),f=new Ce(!1),u=a(" is even, so we can create "),y=new Ce(!1),c=a(`, and
			expand the above so that
			`),g=new Ce(!1),B=a(`. In this
			case, as `),N=new Ce(!1),z=a(`, we can calculate the greatest common divisor for
			`),A=new Ce(!1),ee=a(" with "),Q=new Ce(!1),C=a(" and "),k=new Ce(!1),P=a(` very quickly, which are
			`),j=new Ce(!1),W=a(" and "),U=new Ce(!1),ne=a(" respectively"),this.h()},l(E){i=s(E,"As "),f=We(E,!1),u=s(E," is even, so we can create "),y=We(E,!1),c=s(E,`, and
			expand the above so that
			`),g=We(E,!1),B=s(E,`. In this
			case, as `),N=We(E,!1),z=s(E,`, we can calculate the greatest common divisor for
			`),A=We(E,!1),ee=s(E," with "),Q=We(E,!1),C=s(E," and "),k=We(E,!1),P=s(E,` very quickly, which are
			`),j=We(E,!1),W=s(E," and "),U=We(E,!1),ne=s(E," respectively"),this.h()},h(){f.a=u,y.a=c,g.a=B,N.a=z,A.a=ee,Q.a=C,k.a=P,j.a=W,U.a=ne},m(E,F){_(E,i,F),f.m(d,E,F),_(E,u,F),y.m(v,E,F),_(E,c,F),g.m(b,E,F),_(E,B,F),N.m(L,E,F),_(E,z,F),A.m(V,E,F),_(E,ee,F),Q.m(S,E,F),_(E,C,F),k.m(O,E,F),_(E,P,F),j.m(M,E,F),_(E,W,F),U.m(G,E,F),_(E,ne,F)},p(E,F){F&32&&L!==(L=h(`b = ${E[5]}`)+"")&&N.p(L),F&33&&M!==(M=h(`${gs(E[0],E[5]-1)}`)+"")&&j.p(M),F&33&&G!==(G=h(`${gs(E[0],E[5]+1)}`)+"")&&U.p(G)},d(E){E&&t(i),E&&f.d(),E&&t(u),E&&y.d(),E&&t(c),E&&g.d(),E&&t(B),E&&N.d(),E&&t(z),E&&A.d(),E&&t(ee),E&&Q.d(),E&&t(C),E&&k.d(),E&&t(P),E&&j.d(),E&&t(W),E&&U.d(),E&&t(ne)}}}function Vh(n){let i,f,d,u,y,v,c,g,b,B,N,L,z,A,V,ee,Q,S=h(` = ${n[3]} \\cdot ${n[4]}`)+"",C,k,O,P,j=h(`a = ${n[1]}`)+"",M,W,U=h(`N = ${n[0]}`)+"",G,ne,E=h(`K = ${n[6]}`)+"",F,T,D,Y,_e;function K(w,$){return w[6]!=1?qh:Lh}let J=K(n),ge=J(n);return{c(){i=r("div"),f=r("div"),d=a("a:"),u=q(),y=r("input"),c=q(),g=r("input"),B=q(),N=r("div"),L=a("N:"),z=q(),A=r("input"),ee=q(),Q=r("div"),C=q(),k=r("p"),O=a("The greatest common divisor of "),P=new Ce(!1),M=a(" and "),W=new Ce(!1),G=a(` is
	`),ne=new Ce(!1),F=a(". This is very quick to calculate."),T=q(),ge.c(),D=Io(),this.h()},l(w){i=o(w,"DIV",{class:!0});var $=l(i);f=o($,"DIV",{class:!0});var Ne=l(f);d=s(Ne,"a:"),Ne.forEach(t),u=I($),y=o($,"INPUT",{class:!0,type:!0,min:!0,max:!0}),c=I($),g=o($,"INPUT",{class:!0,type:!0,min:!0,max:!0}),B=I($),N=o($,"DIV",{class:!0});var se=l(N);L=s(se,"N:"),se.forEach(t),z=I($),A=o($,"INPUT",{class:!0,type:!0,min:!0,max:!0}),ee=I($),Q=o($,"DIV",{id:!0,class:!0});var Z=l(Q);Z.forEach(t),$.forEach(t),C=I(w),k=o(w,"P",{});var ce=l(k);O=s(ce,"The greatest common divisor of "),P=We(ce,!1),M=s(ce," and "),W=We(ce,!1),G=s(ce,` is
	`),ne=We(ce,!1),F=s(ce,". This is very quick to calculate."),ce.forEach(t),T=I(w),ge.l(w),D=Io(),this.h()},h(){de(f,"class","varlabel svelte-zwcizk"),de(y,"class","numsel svelte-zwcizk"),de(y,"type","number"),de(y,"min",2),de(y,"max",v=n[0]-1),de(g,"class","slider svelte-zwcizk"),de(g,"type","range"),de(g,"min",2),de(g,"max",b=n[0]-1),de(N,"class","varlabel svelte-zwcizk"),de(A,"class","numsel svelte-zwcizk"),de(A,"type","number"),de(A,"min","1"),de(A,"max",n[7]),de(Q,"id","decomp"),de(Q,"class","svelte-zwcizk"),de(i,"class","cpanel svelte-zwcizk"),P.a=M,W.a=G,ne.a=F},m(w,$){_(w,i,$),e(i,f),e(f,d),e(i,u),e(i,y),on(y,n[1]),e(i,c),e(i,g),on(g,n[1]),e(i,B),e(i,N),e(N,L),e(i,z),e(i,A),on(A,n[0]),e(i,ee),e(i,Q),Q.innerHTML=S,_(w,C,$),_(w,k,$),e(k,O),P.m(j,k),e(k,M),W.m(U,k),e(k,G),ne.m(E,k),e(k,F),_(w,T,$),ge.m(w,$),_(w,D,$),Y||(_e=[m(y,"input",n[10]),m(g,"change",n[11]),m(g,"input",n[11]),Nh(V=n[8].call(null,A,n[0])),m(A,"input",n[12])],Y=!0)},p(w,[$]){$&1&&v!==(v=w[0]-1)&&de(y,"max",v),$&2&&Qn(y.value)!==w[1]&&on(y,w[1]),$&1&&b!==(b=w[0]-1)&&de(g,"max",b),$&2&&on(g,w[1]),V&&Th(V.update)&&$&1&&V.update.call(null,w[0]),$&1&&Qn(A.value)!==w[0]&&on(A,w[0]),$&24&&S!==(S=h(` = ${w[3]} \\cdot ${w[4]}`)+"")&&(Q.innerHTML=S),$&2&&j!==(j=h(`a = ${w[1]}`)+"")&&P.p(j),$&1&&U!==(U=h(`N = ${w[0]}`)+"")&&W.p(U),$&64&&E!==(E=h(`K = ${w[6]}`)+"")&&ne.p(E),J===(J=K(w))&&ge?ge.p(w,$):(ge.d(1),ge=J(w),ge&&(ge.c(),ge.m(D.parentNode,D)))},i:vt,o:vt,d(w){w&&t(i),w&&t(C),w&&t(k),w&&t(T),ge.d(w),w&&t(D),Y=!1,mn(_e)}}}function Bh(n,i){for(let f=1;f<i;f++){let d=n%i;for(let u=1;u<f;u++)d=d*n%i;if(d==1)return f}return 0}function Qh(n,i,f){let d,u,y,{bits:v=7}=i,c=Math.pow(2,v)-1;const g=new Set;for(let k=2;k<=c/2;k++){let O=!0;g.forEach(function(P){k%P==0&&(O=!1)}),O&&g.add(k)}let b=39,B=b,N=7,L,z;function A(k){for(const O of g)if(g.has(k/O))return f(3,L=O),f(4,z=k/O),!0;return!1}A(b);function V(k,O){return{update(P){let j=P-B;if(j!=0){for(;!A(P);)if(P+=j,P<=2||P>=c)return;ee(P)}}}}function ee(k){f(0,b=k),B=b,f(1,N=N>=b?b-1:N)}function Q(){N=Qn(this.value),f(1,N)}function S(){N=Qn(this.value),f(1,N)}function C(){b=Qn(this.value),f(0,b)}return n.$$set=k=>{"bits"in k&&f(9,v=k.bits)},n.$$.update=()=>{n.$$.dirty&3&&f(2,d=Bh(N,b)),n.$$.dirty&3&&f(6,u=gs(b,N)),n.$$.dirty&6&&f(5,y=Math.pow(N,d/2))},[b,N,d,L,z,y,u,c,V,v,Q,S,C]}class zh extends jt{constructor(i){super(),Dt(this,i,Qh,Vh,Rt,{bits:9})}}function Ch(n){const i=n-1;return i*i*i+1}function Wh(n){return--n*n*n*n*n+1}function jh(n,{delay:i=0,duration:f=400,easing:d=Ch,start:u=0,opacity:y=0}={}){const v=getComputedStyle(n),c=+v.opacity,g=v.transform==="none"?"":v.transform,b=1-u,B=c*(1-y);return{delay:i,duration:f,easing:d,css:(N,L)=>`
			transform: ${g} scale(${1-b*L});
			opacity: ${c-B*L}
		`}}function Qo(n){let i,f;return{c(){i=r("div"),this.h()},l(d){i=o(d,"DIV",{class:!0});var u=l(i);u.forEach(t),this.h()},h(){de(i,"class","hover-inner svelte-5qv8za")},m(d,u){_(d,i,u),i.innerHTML=n[0]},p(d,u){n=d,u&1&&(i.innerHTML=n[0])},i(d){f||Ah(()=>{f=Mh(i,jh,{duration:150,easing:Wh,opacity:0}),f.start()})},o:vt,d(d){d&&t(i)}}}function Dh(n){let i,f,d,u;const y=n[5].default,v=Ph(y,n,n[4],null);let c=n[1]&&Qo(n);return{c(){i=r("span"),v&&v.c(),c&&c.c(),this.h()},l(g){i=o(g,"SPAN",{class:!0});var b=l(i);v&&v.l(b),c&&c.l(b),b.forEach(t),this.h()},h(){de(i,"class","hover-outer svelte-5qv8za")},m(g,b){_(g,i,b),v&&v.m(i,null),c&&c.m(i,null),f=!0,d||(u=[m(i,"mouseenter",n[2]),m(i,"mouseleave",n[3])],d=!0)},p(g,[b]){v&&v.p&&(!f||b&16)&&$h(v,y,g,g[4],f?kh(y,g[4],b,null):Sh(g[4]),null),g[1]?c?(c.p(g,b),b&2&&Je(c,1)):(c=Qo(g),c.c(),Je(c,1),c.m(i,null)):c&&(c.d(1),c=null)},i(g){f||(Je(v,g),Je(c),f=!0)},o(g){ht(v,g),f=!1},d(g){g&&t(i),v&&v.d(g),c&&c.d(),d=!1,mn(u)}}}function Rh(n,i,f){let{$$slots:d={},$$scope:u}=i,{hovertext:y}=i,v=!1;const c=()=>f(1,v=!0),g=()=>f(1,v=!1);return n.$$set=b=>{"hovertext"in b&&f(0,y=b.hovertext),"$$scope"in b&&f(4,u=b.$$scope)},[y,v,c,g,u,d]}class ss extends jt{constructor(i){super(),Dt(this,i,Rh,Dh,Rt,{hovertext:0})}}const Uh=`<a href="https://en.wikipedia.org/wiki/Semiprime"><h3 class="text-lg font-semibold">Semiprime</h3></a><p>In mathematics, a <b>semiprime</b> is a natural number that is the product of exactly two prime numbers. The two primes in the product may equal each other, so the semiprimes include the squares of prime numbers.
Because there are infinitely many prime numbers, there are also infinitely many semiprimes. Semiprimes are also called <b>biprimes</b>.</p>`,Kh='<a href="https://en.wikipedia.org/wiki/Computational_complexity"><h3 class="text-lg font-semibold">Computational complexity</h3></a><p>In computer science, the <b>computational complexity</b> or simply <b>complexity</b> of an algorithm is the amount of resources required to run it. Particular focus is given to time and memory requirements. The complexity of a problem is the complexity of the best algorithms that allow solving the problem.</p>';function Oh(n){let i;return{c(){i=a("(semiprime)")},l(f){i=s(f,"(semiprime)")},m(f,d){_(f,i,d)},d(f){f&&t(i)}}}function Xh(n){let i;return{c(){i=a("Computational complexity")},l(f){i=s(f,"Computational complexity")},m(f,d){_(f,i,d)},d(f){f&&t(i)}}}function Gh(n){let i,f,d,u,y,v,c,g,b=h("N")+"",B,N,L=h("N = p \\cdot q")+"",z,A,V=h("15")+"",ee,Q,S=h("3")+"",C,k,O=h("5")+"",P,j,M=h("62615533")+"",W,U,G,ne,E,F,T,D,Y,_e,K,J,ge,w,$=h("^3")+"",Ne,se,Z,ce,me,he,ie,Fe,we,Pt,Be,Te,Pe,pe,fe,re,Ve,Qe,Ze,Ue;return v=new ss({props:{hovertext:Uh,$$slots:{default:[Oh]},$$scope:{ctx:n}}}),ce=new ss({props:{hovertext:Kh,$$slots:{default:[Xh]},$$scope:{ctx:n}}}),{c(){i=r("h3"),f=a("Description of the problem"),d=q(),u=r("p"),y=a("Take a large composite "),ft(v.$$.fragment),c=a(" number "),g=r("span"),B=a(" we try to find factors for, so that "),N=r("span"),z=a(". Finding the prime factors of a small semiprime, such as "),A=r("span"),ee=a(", is quite easy. In fact, you may figure it out just by looking at it and recalling your grade school studies: the factors are "),Q=r("span"),C=a(" and "),k=r("span"),P=a(". But what are the prime factors of, say, "),j=r("span"),W=a("? It turns out that, using the best known "),U=r("em"),G=a("classical"),ne=a(" algorithm (the so called "),E=r("em"),F=a("number field sieve"),T=a("), solving the factoring problem scales "),D=r("em"),Y=a("exponentially"),_e=a(" with the number of digits of the semiprime that we want to factor. With the help of Shor's algorithm and a sufficiently large quantum computer, the same problem scales roughly "),K=r("em"),J=a("cubically"),ge=a(" with the number of digits, meaning that the number of elementary operations required is proportional to (the number of digits)"),w=r("span"),Ne=a(". (In fact, the algorithm does slighly better than that, but the precise formula is a bit complicated and is beside the point.) To illustrate what this means in practical terms, imagine the following. If factoring a 100-digit number with Shor's algorithm on a quantum computer takes one second, factoring the same number with the number field sieve on a classical computer takes more than 3 hours. If we now try with a 200-digit number, Shor's algorithm finishes in roughly 5 seconds, while the classical solution would take more than a year!"),se=q(),Z=r("p"),ft(ce.$$.fragment),me=a(" refers to how the time - or number of "),he=r("em"),ie=a("elementary operations"),Fe=a(" - required to solve a given problem algorithmically grows with the size of the "),we=r("em"),Pt=a("input"),Be=a(`. Let's say you have to find the longest book you have ever read. One way to approach this problem is to list the books you have read one by one, label the first one as the longest, and whenever you encounter an even longer book, it takes the place of the former. This way, you only have to keep track of the largest page number so far, and the book associated with it. The "elementary operation" in this case is checking the number of pages of the next book and comparing that with the previous maximum. If you have twice or three times as many books, this procedure requires twice or three times as many elementary operations. In other words, it grows `),Te=r("em"),Pe=a("linearly"),pe=a(" in the number of books. So, while the solution can be found using the same algorithm, the number of elementary operations required to carry out that algorithm depends on the size of the input. This is true for almost all algorithms that are designed to solve mathematical problems. However, how "),fe=r("em"),re=a("fast"),Ve=a(" that growth is, makes all the difference between them.")},l(ue){i=o(ue,"H3",{});var $e=l(i);f=s($e,"Description of the problem"),$e.forEach(t),d=I(ue),u=o(ue,"P",{});var oe=l(u);y=s(oe,"Take a large composite "),_t(v.$$.fragment,oe),c=s(oe," number "),g=o(oe,"SPAN",{});var Le=l(g);Le.forEach(t),B=s(oe," we try to find factors for, so that "),N=o(oe,"SPAN",{});var wt=l(N);wt.forEach(t),z=s(oe,". Finding the prime factors of a small semiprime, such as "),A=o(oe,"SPAN",{});var nt=l(A);nt.forEach(t),ee=s(oe,", is quite easy. In fact, you may figure it out just by looking at it and recalling your grade school studies: the factors are "),Q=o(oe,"SPAN",{});var ze=l(Q);ze.forEach(t),C=s(oe," and "),k=o(oe,"SPAN",{});var bt=l(k);bt.forEach(t),P=s(oe,". But what are the prime factors of, say, "),j=o(oe,"SPAN",{});var at=l(j);at.forEach(t),W=s(oe,"? It turns out that, using the best known "),U=o(oe,"EM",{});var Ye=l(U);G=s(Ye,"classical"),Ye.forEach(t),ne=s(oe," algorithm (the so called "),E=o(oe,"EM",{});var Ke=l(E);F=s(Ke,"number field sieve"),Ke.forEach(t),T=s(oe,"), solving the factoring problem scales "),D=o(oe,"EM",{});var ae=l(D);Y=s(ae,"exponentially"),ae.forEach(t),_e=s(oe," with the number of digits of the semiprime that we want to factor. With the help of Shor's algorithm and a sufficiently large quantum computer, the same problem scales roughly "),K=o(oe,"EM",{});var ye=l(K);J=s(ye,"cubically"),ye.forEach(t),ge=s(oe," with the number of digits, meaning that the number of elementary operations required is proportional to (the number of digits)"),w=o(oe,"SPAN",{});var R=l(w);R.forEach(t),Ne=s(oe,". (In fact, the algorithm does slighly better than that, but the precise formula is a bit complicated and is beside the point.) To illustrate what this means in practical terms, imagine the following. If factoring a 100-digit number with Shor's algorithm on a quantum computer takes one second, factoring the same number with the number field sieve on a classical computer takes more than 3 hours. If we now try with a 200-digit number, Shor's algorithm finishes in roughly 5 seconds, while the classical solution would take more than a year!"),oe.forEach(t),se=I(ue),Z=o(ue,"P",{});var Ie=l(Z);_t(ce.$$.fragment,Ie),me=s(Ie," refers to how the time - or number of "),he=o(Ie,"EM",{});var xe=l(he);ie=s(xe,"elementary operations"),xe.forEach(t),Fe=s(Ie," - required to solve a given problem algorithmically grows with the size of the "),we=o(Ie,"EM",{});var gt=l(we);Pt=s(gt,"input"),gt.forEach(t),Be=s(Ie,`. Let's say you have to find the longest book you have ever read. One way to approach this problem is to list the books you have read one by one, label the first one as the longest, and whenever you encounter an even longer book, it takes the place of the former. This way, you only have to keep track of the largest page number so far, and the book associated with it. The "elementary operation" in this case is checking the number of pages of the next book and comparing that with the previous maximum. If you have twice or three times as many books, this procedure requires twice or three times as many elementary operations. In other words, it grows `),Te=o(Ie,"EM",{});var ut=l(Te);Pe=s(ut,"linearly"),ut.forEach(t),pe=s(Ie," in the number of books. So, while the solution can be found using the same algorithm, the number of elementary operations required to carry out that algorithm depends on the size of the input. This is true for almost all algorithms that are designed to solve mathematical problems. However, how "),fe=o(Ie,"EM",{});var et=l(fe);re=s(et,"fast"),et.forEach(t),Ve=s(Ie," that growth is, makes all the difference between them."),Ie.forEach(t)},m(ue,$e){_(ue,i,$e),e(i,f),_(ue,d,$e),_(ue,u,$e),e(u,y),dt(v,u,null),e(u,c),e(u,g),g.innerHTML=b,e(u,B),e(u,N),N.innerHTML=L,e(u,z),e(u,A),A.innerHTML=V,e(u,ee),e(u,Q),Q.innerHTML=S,e(u,C),e(u,k),k.innerHTML=O,e(u,P),e(u,j),j.innerHTML=M,e(u,W),e(u,U),e(U,G),e(u,ne),e(u,E),e(E,F),e(u,T),e(u,D),e(D,Y),e(u,_e),e(u,K),e(K,J),e(u,ge),e(u,w),w.innerHTML=$,e(u,Ne),_(ue,se,$e),_(ue,Z,$e),dt(ce,Z,null),e(Z,me),e(Z,he),e(he,ie),e(Z,Fe),e(Z,we),e(we,Pt),e(Z,Be),e(Z,Te),e(Te,Pe),e(Z,pe),e(Z,fe),e(fe,re),e(Z,Ve),Qe=!0,Ze||(Ue=[m(g,"mouseenter",n[0]),m(N,"mouseenter",n[1]),m(A,"mouseenter",n[2]),m(Q,"mouseenter",n[3]),m(k,"mouseenter",n[4]),m(j,"mouseenter",n[5]),m(w,"mouseenter",n[6])],Ze=!0)},p(ue,[$e]){const oe={};$e&128&&(oe.$$scope={dirty:$e,ctx:ue}),v.$set(oe);const Le={};$e&128&&(Le.$$scope={dirty:$e,ctx:ue}),ce.$set(Le)},i(ue){Qe||(Je(v.$$.fragment,ue),Je(ce.$$.fragment,ue),Qe=!0)},o(ue){ht(v.$$.fragment,ue),ht(ce.$$.fragment,ue),Qe=!1},d(ue){ue&&t(i),ue&&t(d),ue&&t(u),ct(v),ue&&t(se),ue&&t(Z),ct(ce),Ze=!1,mn(Ue)}}}function Dn(n){console.log(n)}function Jh(n){return[()=>Dn(["N"]),()=>Dn(["q","p","N"]),()=>Dn([]),()=>Dn([]),()=>Dn([]),()=>Dn([]),()=>Dn([])]}class Zh extends jt{constructor(i){super(),Dt(this,i,Jh,Gh,Rt,{})}}function Yh(n){let i,f,d,u,y,v,c,g,b,B,N,L=h("a \\in \\mathbb{N}, 1 < a < N")+"",z,A,V=h("a")+"",ee,Q,S=h("N")+"",C,k,O=h("1")+"",P,j,M=h("a")+"",W,U,G=h("N")+"",ne,E,F=h("N")+"",T,D,Y,_e,K,J,ge=h("f(r): \\mathbb{N} \\rightarrow \\mathbb{N} = a^r \\mod N")+"",w,$,Ne=h("0 < \\hat{r} < N")+"",se,Z,ce=h("f(\\hat{r}) = 1")+"",me,he,ie=h("\\hat{r}")+"",Fe,we,Pt=h("a")+"",Be,Te,Pe,pe,fe,re,Ve=h("\\hat{r}")+"",Qe,Ze,Ue=h("\\hat{r}")+"",ue,$e,oe=h("m \\in \\mathbb{N}")+"",Le,wt,nt=h("a^{\\hat{r}} = m \\cdot N + 1")+"",ze,bt,at=h("b = a^{\\frac{\\hat{r}}{2}}")+"",Ye,Ke,ae=h("b^2 = (a^{\\frac{\\hat{r}}{2}})^2 = a^{\\hat{r}}")+"",ye,R,Ie=h("b^2 - 1 = (b + 1)(b - 1)")+"",xe,gt,ut=h("(b + 1)(b - 1) = m \\cdot N")+"",et,Ut,lt,ke,Kt,it,mt=h("N")+"",Ot,pt,yt=h("\\gcd({a^{\\frac{r}{2} - 1}}, N)")+"",zt,te,qe=h("\\gcd({a^{\\frac{r}{2} + 1}}, N)")+"",le,st,rt=h("\\gcd")+"",pn,ot,$t,gn,Ct,x,ln,qt,Ht,hn,ve,Ee,Et,Xt,en=h("\\hat{r}")+"",En,Gt,fn=h("1")+"",Se,Jt,_n=h("N")+"",je,Wt,dn=h("N")+"",zn,Nn,un;return{c(){i=r("h3"),f=a("Solution"),d=q(),u=r("p"),y=a("The factoring problem can be solved with the following simple, but very time-consuming algorithm:"),v=q(),c=r("ol"),g=r("li"),b=r("p"),B=a("We pick a random number "),N=r("span"),z=a(" and make sure that "),A=r("span"),ee=a(" and "),Q=r("span"),C=a(" are relative primes, meaning their greatest common divisor is "),k=r("span"),P=a(". (In case "),j=r("span"),W=a(" happens to be a factor of "),U=r("span"),ne=a(", the entire problem is solved and no further steps are required, but that is highly unlikely if "),E=r("span"),T=a(" is large.)"),D=q(),Y=r("li"),_e=r("p"),K=a("Next, we construct the function "),J=r("span"),w=a(" and find the smallest integer "),$=r("span"),se=a(" such that "),Z=r("span"),me=a(". If "),he=r("span"),Fe=a(" turns out to be odd, we unfortunately have to repeat the entire procedure with a different "),we=r("span"),Be=a(" parameter."),Te=q(),Pe=r("li"),pe=r("p"),fe=a("If we're lucky and "),re=r("span"),Qe=a(" is even, we can proceed. From the definition of "),Ze=r("span"),ue=a(" follows that there's "),$e=r("span"),Le=a(" such that "),wt=r("span"),ze=a(". We can define the integer "),bt=r("span"),Ye=a(", which means "),Ke=r("span"),ye=a(". Also, we can make use of a well-known algebraic identity to write "),R=r("span"),xe=a(". Putting together these three equations, we find that "),gt=r("span"),et=a("."),Ut=q(),lt=r("li"),ke=r("p"),Kt=a("The sought prime factors of "),it=r("span"),Ot=a(" are "),pt=r("span"),zt=a(" and "),te=r("span"),le=a(" (where "),st=r("span"),pn=a(" stands for "),ot=r("em"),$t=a("greatest common divisor"),gn=a(")."),Ct=q(),x=r("p"),ln=a("For a more illuminating explanation, see the video "),qt=r("a"),Ht=a("Hacking at Quantum Speed with Shor's Algorithm"),hn=a(" by PBS Infinite Series."),ve=q(),Ee=r("p"),Et=a("The problem with this solution is that in order to find "),Xt=r("span"),En=a(", we might have to check all possible values between "),Gt=r("span"),Se=a(" and "),Jt=r("span"),je=a(" one after the other, which is an insane amount of computation if "),Wt=r("span"),zn=a(" is number with several hundreds of digits. But that's only the case if we're trying with a classical computer."),this.h()},l(He){i=o(He,"H3",{});var St=l(i);f=s(St,"Solution"),St.forEach(t),d=I(He),u=o(He,"P",{});var Ae=l(u);y=s(Ae,"The factoring problem can be solved with the following simple, but very time-consuming algorithm:"),Ae.forEach(t),v=I(He),c=o(He,"OL",{});var tn=l(c);g=o(tn,"LI",{});var Tn=l(g);b=o(Tn,"P",{});var tt=l(b);B=s(tt,"We pick a random number "),N=o(tt,"SPAN",{});var rs=l(N);rs.forEach(t),z=s(tt," and make sure that "),A=o(tt,"SPAN",{});var Cn=l(A);Cn.forEach(t),ee=s(tt," and "),Q=o(tt,"SPAN",{});var cn=l(Q);cn.forEach(t),C=s(tt," are relative primes, meaning their greatest common divisor is "),k=o(tt,"SPAN",{});var os=l(k);os.forEach(t),P=s(tt,". (In case "),j=o(tt,"SPAN",{});var Wn=l(j);Wn.forEach(t),W=s(tt," happens to be a factor of "),U=o(tt,"SPAN",{});var vn=l(U);vn.forEach(t),ne=s(tt,", the entire problem is solved and no further steps are required, but that is highly unlikely if "),E=o(tt,"SPAN",{});var ls=l(E);ls.forEach(t),T=s(tt," is large.)"),tt.forEach(t),Tn.forEach(t),D=I(tn),Y=o(tn,"LI",{});var Pn=l(Y);_e=o(Pn,"P",{});var De=l(_e);K=s(De,"Next, we construct the function "),J=o(De,"SPAN",{});var is=l(J);is.forEach(t),w=s(De," and find the smallest integer "),$=o(De,"SPAN",{});var jn=l($);jn.forEach(t),se=s(De," such that "),Z=o(De,"SPAN",{});var $n=l(Z);$n.forEach(t),me=s(De,". If "),he=o(De,"SPAN",{});var It=l(he);It.forEach(t),Fe=s(De," turns out to be odd, we unfortunately have to repeat the entire procedure with a different "),we=o(De,"SPAN",{});var hs=l(we);hs.forEach(t),Be=s(De," parameter."),De.forEach(t),Pn.forEach(t),Te=I(tn),Pe=o(tn,"LI",{});var Sn=l(Pe);pe=o(Sn,"P",{});var Nt=l(pe);fe=s(Nt,"If we're lucky and "),re=o(Nt,"SPAN",{});var us=l(re);us.forEach(t),Qe=s(Nt," is even, we can proceed. From the definition of "),Ze=o(Nt,"SPAN",{});var An=l(Ze);An.forEach(t),ue=s(Nt," follows that there's "),$e=o(Nt,"SPAN",{});var Os=l($e);Os.forEach(t),Le=s(Nt," such that "),wt=o(Nt,"SPAN",{});var ms=l(wt);ms.forEach(t),ze=s(Nt,". We can define the integer "),bt=o(Nt,"SPAN",{});var Mn=l(bt);Mn.forEach(t),Ye=s(Nt,", which means "),Ke=o(Nt,"SPAN",{});var Xs=l(Ke);Xs.forEach(t),ye=s(Nt,". Also, we can make use of a well-known algebraic identity to write "),R=o(Nt,"SPAN",{});var ps=l(R);ps.forEach(t),xe=s(Nt,". Putting together these three equations, we find that "),gt=o(Nt,"SPAN",{});var Hn=l(gt);Hn.forEach(t),et=s(Nt,"."),Nt.forEach(t),Sn.forEach(t),Ut=I(tn),lt=o(tn,"LI",{});var Es=l(lt);ke=o(Es,"P",{});var Ft=l(ke);Kt=s(Ft,"The sought prime factors of "),it=o(Ft,"SPAN",{});var Un=l(it);Un.forEach(t),Ot=s(Ft," are "),pt=o(Ft,"SPAN",{});var Oe=l(pt);Oe.forEach(t),zt=s(Ft," and "),te=o(Ft,"SPAN",{});var fs=l(te);fs.forEach(t),le=s(Ft," (where "),st=o(Ft,"SPAN",{});var Ln=l(st);Ln.forEach(t),pn=s(Ft," stands for "),ot=o(Ft,"EM",{});var Ns=l(ot);$t=s(Ns,"greatest common divisor"),Ns.forEach(t),gn=s(Ft,")."),Ft.forEach(t),Es.forEach(t),tn.forEach(t),Ct=I(He),x=o(He,"P",{});var qn=l(x);ln=s(qn,"For a more illuminating explanation, see the video "),qt=o(qn,"A",{href:!0});var kn=l(qt);Ht=s(kn,"Hacking at Quantum Speed with Shor's Algorithm"),kn.forEach(t),hn=s(qn," by PBS Infinite Series."),qn.forEach(t),ve=I(He),Ee=o(He,"P",{});var nn=l(Ee);Et=s(nn,"The problem with this solution is that in order to find "),Xt=o(nn,"SPAN",{});var _s=l(Xt);_s.forEach(t),En=s(nn,", we might have to check all possible values between "),Gt=o(nn,"SPAN",{});var In=l(Gt);In.forEach(t),Se=s(nn," and "),Jt=o(nn,"SPAN",{});var Gs=l(Jt);Gs.forEach(t),je=s(nn," one after the other, which is an insane amount of computation if "),Wt=o(nn,"SPAN",{});var ds=l(Wt);ds.forEach(t),zn=s(nn," is number with several hundreds of digits. But that's only the case if we're trying with a classical computer."),nn.forEach(t),this.h()},h(){de(qt,"href","https://www.youtube.com/watch?v=wUwZZaI5u0c&t=731s")},m(He,St){_(He,i,St),e(i,f),_(He,d,St),_(He,u,St),e(u,y),_(He,v,St),_(He,c,St),e(c,g),e(g,b),e(b,B),e(b,N),N.innerHTML=L,e(b,z),e(b,A),A.innerHTML=V,e(b,ee),e(b,Q),Q.innerHTML=S,e(b,C),e(b,k),k.innerHTML=O,e(b,P),e(b,j),j.innerHTML=M,e(b,W),e(b,U),U.innerHTML=G,e(b,ne),e(b,E),E.innerHTML=F,e(b,T),e(c,D),e(c,Y),e(Y,_e),e(_e,K),e(_e,J),J.innerHTML=ge,e(_e,w),e(_e,$),$.innerHTML=Ne,e(_e,se),e(_e,Z),Z.innerHTML=ce,e(_e,me),e(_e,he),he.innerHTML=ie,e(_e,Fe),e(_e,we),we.innerHTML=Pt,e(_e,Be),e(c,Te),e(c,Pe),e(Pe,pe),e(pe,fe),e(pe,re),re.innerHTML=Ve,e(pe,Qe),e(pe,Ze),Ze.innerHTML=Ue,e(pe,ue),e(pe,$e),$e.innerHTML=oe,e(pe,Le),e(pe,wt),wt.innerHTML=nt,e(pe,ze),e(pe,bt),bt.innerHTML=at,e(pe,Ye),e(pe,Ke),Ke.innerHTML=ae,e(pe,ye),e(pe,R),R.innerHTML=Ie,e(pe,xe),e(pe,gt),gt.innerHTML=ut,e(pe,et),e(c,Ut),e(c,lt),e(lt,ke),e(ke,Kt),e(ke,it),it.innerHTML=mt,e(ke,Ot),e(ke,pt),pt.innerHTML=yt,e(ke,zt),e(ke,te),te.innerHTML=qe,e(ke,le),e(ke,st),st.innerHTML=rt,e(ke,pn),e(ke,ot),e(ot,$t),e(ke,gn),_(He,Ct,St),_(He,x,St),e(x,ln),e(x,qt),e(qt,Ht),e(x,hn),_(He,ve,St),_(He,Ee,St),e(Ee,Et),e(Ee,Xt),Xt.innerHTML=en,e(Ee,En),e(Ee,Gt),Gt.innerHTML=fn,e(Ee,Se),e(Ee,Jt),Jt.innerHTML=_n,e(Ee,je),e(Ee,Wt),Wt.innerHTML=dn,e(Ee,zn),Nn||(un=[m(N,"mouseenter",n[0]),m(A,"mouseenter",n[1]),m(Q,"mouseenter",n[2]),m(k,"mouseenter",n[3]),m(j,"mouseenter",n[4]),m(U,"mouseenter",n[5]),m(E,"mouseenter",n[6]),m(J,"mouseenter",n[7]),m($,"mouseenter",n[8]),m(Z,"mouseenter",n[9]),m(he,"mouseenter",n[10]),m(we,"mouseenter",n[11]),m(re,"mouseenter",n[12]),m(Ze,"mouseenter",n[13]),m($e,"mouseenter",n[14]),m(wt,"mouseenter",n[15]),m(bt,"mouseenter",n[16]),m(Ke,"mouseenter",n[17]),m(R,"mouseenter",n[18]),m(gt,"mouseenter",n[19]),m(it,"mouseenter",n[20]),m(pt,"mouseenter",n[21]),m(te,"mouseenter",n[22]),m(st,"mouseenter",n[23]),m(Xt,"mouseenter",n[24]),m(Gt,"mouseenter",n[25]),m(Jt,"mouseenter",n[26]),m(Wt,"mouseenter",n[27])],Nn=!0)},p:vt,i:vt,o:vt,d(He){He&&t(i),He&&t(d),He&&t(u),He&&t(v),He&&t(c),He&&t(Ct),He&&t(x),He&&t(ve),He&&t(Ee),Nn=!1,mn(un)}}}function Re(n){console.log(n)}function xh(n){return[()=>Re(["a","N"]),()=>Re(["a"]),()=>Re(["N"]),()=>Re([]),()=>Re(["a"]),()=>Re(["N"]),()=>Re(["N"]),()=>Re(["r","a","f","N"]),()=>Re(["r","N"]),()=>Re(["r","f"]),()=>Re(["r"]),()=>Re(["a"]),()=>Re(["r"]),()=>Re(["r"]),()=>Re(["m","N"]),()=>Re(["r","m","a","N"]),()=>Re(["b","r","a"]),()=>Re(["b","r","a"]),()=>Re(["b"]),()=>Re(["b","m","N"]),()=>Re(["N"]),()=>Re(["r","a","N"]),()=>Re(["r","a","N"]),()=>Re([]),()=>Re(["r"]),()=>Re([]),()=>Re(["N"]),()=>Re(["N"])]}class eu extends jt{constructor(i){super(),Dt(this,i,xh,Yh,Rt,{})}}function tu(n){let i,f,d,u,y,v,c,g,b,B;return u=new Zh({}),v=new eu({}),b=new zh({}),{c(){i=r("h2"),f=a("Factoring"),d=q(),ft(u.$$.fragment),y=q(),ft(v.$$.fragment),c=q(),g=r("div"),ft(b.$$.fragment),this.h()},l(N){i=o(N,"H2",{});var L=l(i);f=s(L,"Factoring"),L.forEach(t),d=I(N),_t(u.$$.fragment,N),y=I(N),_t(v.$$.fragment,N),c=I(N),g=o(N,"DIV",{class:!0});var z=l(g);_t(b.$$.fragment,z),z.forEach(t),this.h()},h(){de(g,"class","interaction")},m(N,L){_(N,i,L),e(i,f),_(N,d,L),dt(u,N,L),_(N,y,L),dt(v,N,L),_(N,c,L),_(N,g,L),dt(b,g,null),B=!0},p:vt,i(N){B||(Je(u.$$.fragment,N),Je(v.$$.fragment,N),Je(b.$$.fragment,N),B=!0)},o(N){ht(u.$$.fragment,N),ht(v.$$.fragment,N),ht(b.$$.fragment,N),B=!1},d(N){N&&t(i),N&&t(d),ct(u,N),N&&t(y),ct(v,N),N&&t(c),N&&t(g),ct(b)}}}class nu extends jt{constructor(i){super(),Dt(this,i,null,tu,Rt,{})}}function au(n){let i,f,d,u=h("f")+"",y,v,c=h("\\Large \\hat{f}(\\xi) = \\int_{-\\infty}^{\\infty}{ f(x) \\cdot e^{-2 \\pi i x \\xi} dx}")+"",g,b,B,N,L,z=h("\\large x_0, \\ldots, x_{N - 1}")+"",A,V,ee,Q,S,C=h("\\large X_k = \\sum_{n=1}^{N - 1}{x_n \\cdot e^{-2 \\pi i \\frac{k}{N} n}}")+"",k,O,P,j,M,W=h("\\large f(x) = \\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d\\xi")+"",U,G,ne,E,F,T=h("\\large x_n = \\frac{1}{N} \\sum_{k=1}^{N - 1} X_k \\cdot e^{2 \\pi i \\frac{n}{N} k}")+"",D,Y,_e;return{c(){i=r("p"),f=a("The Fourier transform of a function "),d=r("span"),y=a(" is defined as: "),v=r("span"),g=a("."),b=q(),B=r("p"),N=a("Let "),L=r("span"),A=a(" be a sequence of complex numbers."),V=q(),ee=r("p"),Q=a("The discrete Fourier transform of that sequence is another sequence defined by the following formula: "),S=r("span"),k=a("."),O=q(),P=r("p"),j=a("We obtain original function by applying the inverse Fourier transform: "),M=r("span"),U=a("."),G=q(),ne=r("p"),E=a(`Analogously, we can obtain the original sequence with the help of the inverse discrete Fourier transform: 
`),F=r("span"),D=a(".")},l(K){i=o(K,"P",{});var J=l(i);f=s(J,"The Fourier transform of a function "),d=o(J,"SPAN",{});var ge=l(d);ge.forEach(t),y=s(J," is defined as: "),v=o(J,"SPAN",{});var w=l(v);w.forEach(t),g=s(J,"."),J.forEach(t),b=I(K),B=o(K,"P",{});var $=l(B);N=s($,"Let "),L=o($,"SPAN",{});var Ne=l(L);Ne.forEach(t),A=s($," be a sequence of complex numbers."),$.forEach(t),V=I(K),ee=o(K,"P",{});var se=l(ee);Q=s(se,"The discrete Fourier transform of that sequence is another sequence defined by the following formula: "),S=o(se,"SPAN",{});var Z=l(S);Z.forEach(t),k=s(se,"."),se.forEach(t),O=I(K),P=o(K,"P",{});var ce=l(P);j=s(ce,"We obtain original function by applying the inverse Fourier transform: "),M=o(ce,"SPAN",{});var me=l(M);me.forEach(t),U=s(ce,"."),ce.forEach(t),G=I(K),ne=o(K,"P",{});var he=l(ne);E=s(he,`Analogously, we can obtain the original sequence with the help of the inverse discrete Fourier transform: 
`),F=o(he,"SPAN",{});var ie=l(F);ie.forEach(t),D=s(he,"."),he.forEach(t)},m(K,J){_(K,i,J),e(i,f),e(i,d),d.innerHTML=u,e(i,y),e(i,v),v.innerHTML=c,e(i,g),_(K,b,J),_(K,B,J),e(B,N),e(B,L),L.innerHTML=z,e(B,A),_(K,V,J),_(K,ee,J),e(ee,Q),e(ee,S),S.innerHTML=C,e(ee,k),_(K,O,J),_(K,P,J),e(P,j),e(P,M),M.innerHTML=W,e(P,U),_(K,G,J),_(K,ne,J),e(ne,E),e(ne,F),F.innerHTML=T,e(ne,D),Y||(_e=[m(d,"mouseenter",n[0]),m(v,"mouseenter",n[1]),m(L,"mouseenter",n[2]),m(S,"mouseenter",n[3]),m(M,"mouseenter",n[4]),m(F,"mouseenter",n[5])],Y=!0)},p:vt,i:vt,o:vt,d(K){K&&t(i),K&&t(b),K&&t(B),K&&t(V),K&&t(ee),K&&t(O),K&&t(P),K&&t(G),K&&t(ne),Y=!1,mn(_e)}}}function as(n){console.log(n)}function su(n){return[()=>as(["f"]),()=>as(["x","\\xi","f","d"]),()=>as(["x","N"]),()=>as(["x","X","N","k","n"]),()=>as(["x","\\xi","f","d"]),()=>as(["x","X","N","k","n"])]}class ru extends jt{constructor(i){super(),Dt(this,i,su,au,Rt,{})}}function ou(n){let i,f,d,u,y,v,c,g,b,B=h("10")+"",N,L,z=h("0, 1, 2, 3, 4, 5, 6, 7, 8, 9")+"",A,V,ee=h("325")+"",Q,S,C=h("2")+"",k,O,P=h("2 \\cdot 10")+"",j,M,W=h("2847")+"",U,G,ne=h("2 \\cdot 1000")+"",E,F,T=h("n")+"",D,Y,_e=h("\\displaystyle{\\sum_{k = 1}^{n} d_k \\cdot 10^{n - k}}")+"",K,J,ge=h("d_k")+"",w,$,Ne=h("k")+"",se,Z,ce=h("2847 = 2 \\cdot 10^3 + 8 \\cdot 10^2 + 4 \\cdot 10^1 + 7 \\cdot 10^0 = 2 \\cdot 1000 + 8 \\cdot 100 + 4 \\cdot 10 + 7 \\cdot 1")+"",me,he,ie,Fe,we,Pt=h("2")+"",Be,Te,Pe=h("0")+"",pe,fe,re=h("1")+"",Ve,Qe,Ze=h("\\displaystyle{\\sum_{k = 1}^{n} d_k \\cdot 2^{n - k}}")+"",Ue,ue,$e=h("d_k")+"",oe,Le,wt=h("k")+"",nt,ze,bt=h("1011 = 1 \\cdot 2^3 + 0 \\cdot 2^2 + 1 \\cdot 2^1 + 1 \\cdot 2^0 = 1 \\cdot 8 + 0 \\cdot 4 + 1 \\cdot 2 + 1 \\cdot 1 = 11")+"",at,Ye,Ke,ae,ye,R,Ie,xe,gt=h("n")+"",ut,et,Ut=h("|0\\rangle")+"",lt,ke,Kt=h("|1\\rangle")+"",it,mt,Ot=h("\\underbrace{2 \\cdot \\ldots \\cdot 2}_\\text{n times} = 2^n")+"",pt,yt,zt=h("N := 2^n")+"",te,qe,le,st,rt,pn=h("0")+"",ot,$t,gn=h("N - 1")+"",Ct,x,ln=h("n = 5")+"",qt,Ht,hn=h("|0\\rangle \\otimes |1\\rangle \\otimes |0\\rangle \\otimes |0\\rangle \\otimes |1\\rangle")+"",ve,Ee,Et=h("01001")+"",Xt,en,En=h("0 \\cdot 2^4 + 1 \\cdot 2^3 + 0 \\cdot 2^2 + 0 \\cdot 2^1 + 1 \\cdot 2^0 = 0 + 8 + 0 + 0 + 1 = 9")+"",Gt,fn,Se,Jt,_n,je,Wt,dn,zn=h("x")+"",Nn,un,He=h("x = 9")+"",St,Ae,tn=h("k")+"",Tn,tt,rs=h("\\frac{1}{\\sqrt{2}} \\left( |0\\rangle + e^{\\frac{2 \\pi i x}{2^k}} |1\\rangle \\right)")+"",Cn,cn,os=h("\\alpha_k = \\frac{1}{\\sqrt{2}}")+"",Wn,vn,ls=h("\\beta_k = \\frac{1}{\\sqrt{2}} e^{\\frac{2 \\pi i x}{2^k}}")+"",Pn,De,is=h("k = 1, ..., n")+"",jn,$n,It,hs,Sn,Nt=h("\\alpha_k \\neq \\beta_k")+"",us,An,Os=h("\\Vert{\\alpha_k}\\Vert^2 = \\Vert{\\beta_k}\\Vert^2 = \\frac{1}{2}")+"",ms,Mn,Xs=h("k = 1, ..., n")+"",ps,Hn,Es=h("e^{\\frac{2 \\pi i x}{2^k}}")+"",Ft,Un,Oe,fs,Ln,Ns=h("|0\\rangle")+"",qn,kn,nn=h("|1\\rangle")+"",_s,In,Gs=h("n")+"",ds,Kn,zo=h("n")+"",Js,On,Co=h("0")+"",Zs,Xn,Wo=h("N - 1")+"",Ys,Gn,jo=h("\\frac{1}{2}")+"",xs,Jn,Do=h("n")+"",er,Zn,Ro=h("\\underbrace{\\frac{1}{2} \\cdot \\ldots \\cdot \\frac{1}{2}}_\\text{n terms} = \\frac{1}{2^n} = \\frac{1}{N}")+"",tr,Ts,Yn,nr,Ps,xn,ar,$s,ea,ta,Uo=h("\\underbrace{ \\frac{1}{\\sqrt{2}} \\left( |0\\rangle + e^{ \\frac{2 \\pi i x}{2^1} } |1\\rangle \\right) \\otimes \\ldots \\otimes \\frac{1}{\\sqrt{2}} \\left( |0\\rangle + e^{ \\frac{2 \\pi i x}{2^n} } |1\\rangle \\right) }_\\text{n terms}")+"",Ss,Fn,sr,na,Ko=h("\\frac{1}{\\sqrt{2}}")+"",rr,ks,aa,sa,Oo=h("\\frac{1}{\\sqrt{2^n}} \\left(\\left( |0\\rangle + e^{\\frac{2 \\pi i x}{2^1}} |1\\rangle \\right) \\otimes \\ldots \\otimes \\left( |0\\rangle + e^{\\frac{2 \\pi i x}{2^n}} |1\\rangle \\right) \\right) = \\frac{1}{\\sqrt{N}} \\left(\\left( |0\\rangle + e^{\\frac{2 \\pi i x}{2^1}} |1\\rangle \\right) \\otimes \\ldots \\otimes \\left( |0\\rangle + e^{\\frac{2 \\pi i x}{2^n}} |1\\rangle \\right) \\right)")+"",As,be,or,ra,Xo=h("y")+"",lr,oa,Go=h("n")+"",ir,la,Jo=h("y_k")+"",hr,ia,Zo=h("k")+"",ur,ha,Yo=h("y")+"",mr,ua,xo=h("y_k = 0")+"",pr,ma,el=h("k")+"",fr,pa,tl=h("|0\\rangle")+"",_r,fa,nl=h("y_k = 1")+"",dr,_a,al=h("|1\\rangle")+"",cr,da,sl=h("k = 1, \\ldots, n")+"",vr,ca,rl=h("y")+"",wr,va,ol=h("\\displaystyle{ y = \\sum_{k=1}^n y_k \\cdot 2^{n - k}}")+"",br,wa,ll=h("2^n")+"",yr,ba,il=h("k")+"",gr,ya,hl=h("\\displaystyle{ y = 2^n \\cdot \\sum_{k=1}^n y_k \\cdot 2^{-k} = N \\cdot \\sum_{k=1}^n \\frac{y_k}{2^k}}")+"",Er,Ms,ga,Nr,Hs,Ea,Na,ul=h("\\displaystyle{ \\frac{1}{\\sqrt{N}} \\underbrace{ \\sum_{y_1=0}^1 \\ldots \\sum_{y_{n}=0}^1}_\\text{n terms} \\overbrace{e^{\\frac{2 \\pi i x y_1}{2^1}} |y_1\\rangle \\otimes \\ldots \\otimes e^{\\frac{2 \\pi i x y_n}{2^n}}|y_n\\rangle}^\\text{n terms} }")+"",Ls,kt,Tr,Ta,ml=h("k")+"",Pr,Pa,pl=h("e^{\\frac{2 \\pi i x y_k}{2^k}}|y_k\\rangle")+"",$r,$a,fl=h("e^{\\frac{2 \\pi i x \\cdot 0}{2^k}}|0\\rangle = 1 \\cdot |0\\rangle = |0\\rangle")+"",Sr,Sa,_l=h("y_k = 0")+"",kr,ka,dl=h("e^{\\frac{2 \\pi i x \\cdot 1}{2^k}}|1\\rangle = e^{\\frac{2 \\pi i x }{2^k}}|1\\rangle")+"",Ar,Aa,cl=h("y_k = 1")+"",Mr,qs,an,Hr,Ma,vl=h("n")+"",Lr,cs,qr,Ir,vs,Fr,Vr,Is,Vn,Br,ws,Qr,zr,Fs,Ha,La,wl=h("\\displaystyle{ \\frac{1}{\\sqrt{N}} \\sum_{y_1=0}^1 \\ldots \\sum_{y_{n}=0}^1 \\left( e^{\\frac{2 \\pi i x y_1}{2^1}} \\cdot \\ldots \\cdot e^{\\frac{2 \\pi i x y_n}{2^n}} \\right) \\left( |y_1\\rangle \\otimes \\ldots \\otimes |y_n\\rangle \\right)}")+"",Vs,qa,Ia,bl=h("\\displaystyle{ = \\frac{1}{\\sqrt{N}} \\sum_{y_1=0}^1 \\ldots \\sum_{y_{n}=0}^1 \\prod_{k=1}^n e^{\\frac{2 \\pi i x y_k}{2^k}} \\left( |y_1\\rangle \\otimes \\ldots \\otimes |y_n\\rangle \\right)}")+"",Bs,Fa,Cr,Qs,Va,Ba,yl=h("\\displaystyle{ = \\frac{1}{\\sqrt{N}} \\sum_{y_1=0}^1 \\ldots \\sum_{y_{n}=0}^1 e^{\\sum_{k=1}^n \\frac{2 \\pi i x y_k}{2^k}} \\left( |y_1\\rangle \\otimes \\ldots \\otimes |y_n\\rangle \\right)}")+"",zs,wn,Wr,Qa,gl=h("2 \\pi i x")+"",jr,za,El=h("k")+"",Dr,Cs,Ca,Wa,Nl=h("\\displaystyle{ = \\frac{1}{\\sqrt{N}} \\sum_{y_1=0}^1 \\ldots \\sum_{y_{n}=0}^1 e^{2 \\pi i x \\sum_{k=1}^n \\frac{y_k}{2^k}} \\left( |y_1\\rangle \\otimes \\ldots \\otimes |y_n\\rangle \\right)}")+"",Ws,At,Rr,ja,Tl=h("\\displaystyle{ \\sum_{k=1}^n \\frac{y_k}{2^k}}")+"",Ur,Da,Pl=h("\\frac{y}{N}")+"",Kr,Ra,$l=h("y_k")+"",Or,Ua,Sl=h("y")+"",Xr,Ka,kl=h("y")+"",Gr,Oa,Al=h("|y\\rangle = |y_1\\rangle \\otimes \\ldots \\otimes |y_n\\rangle")+"",Jr,js,Xa,Ga,Ml=h("\\displaystyle{ \\frac{1}{\\sqrt{N}} \\sum_{y=0}^{N - 1} e^{\\frac{2 \\pi i x y}{N}} |y\\rangle}")+"",Ds,bn,Zr,bs,Yr,xr,ys,eo,to,Rs,Vt,no,Ja,Hl=h("x")+"",ao,Za,Ll=h("e^{\\frac{2 \\pi i x y}{N}}")+"",so,Ya,ql=h("y")+"",ro,xa,Il=h("x")+"",oo,es,Fl=h("x")+"",lo,io,po;return{c(){i=r("h2"),f=a("Quantum Fourier transform"),d=q(),u=r("h2"),y=a("Binary number system"),v=q(),c=r("p"),g=a("In the decimal number system, there are "),b=r("span"),N=a(" distinct symbols used to represent numbers: "),L=r("span"),A=a(". The value of these symbols depends on their place in a given number. For example, in the number "),V=r("span"),Q=a(", the symbol "),S=r("span"),k=a(" stands for "),O=r("span"),j=a(", whereas in the number "),M=r("span"),U=a(", it represents "),G=r("span"),E=a(". In general, an integer in decimal notation with "),F=r("span"),D=a(" digits equals "),Y=r("span"),K=a(", where "),J=r("span"),w=a(" is the "),$=r("span"),se=a("-th digit (going from left to right). To illustrate this with a concrete example, the number above "),Z=r("span"),me=a("."),he=q(),ie=r("p"),Fe=a("Analogously, in the binary number system, there are "),we=r("span"),Be=a(" distinct symbols used to represent numbers: "),Te=r("span"),pe=a(" and "),fe=r("span"),Ve=a(". The value of an integer in binary notation equals to "),Qe=r("span"),Ue=a(", where "),ue=r("span"),oe=a(" is the "),Le=r("span"),nt=a("-th (binary) digit. For instance, the binary number "),ze=r("span"),at=a("."),Ye=q(),Ke=r("h2"),ae=a("Representing numbers with qubits"),ye=q(),R=r("p"),Ie=a("Consider "),xe=r("span"),ut=a(" qubits aranged in a row, each of which are in either of the two basis states "),et=r("span"),lt=a(" or "),ke=r("span"),it=a(". With a little combinatorics, we can see that there are "),mt=r("span"),pt=a(" such combinations. For ease of notation, let "),yt=r("span"),te=a("."),qe=q(),le=r("p"),st=a("For our purposes, we'll interpret these combinations as the binary representations of the numbers from "),rt=r("span"),ot=a(" to "),$t=r("span"),Ct=a(". For example, let "),x=r("span"),qt=a(" and the qubits be in the following state: "),Ht=r("span"),ve=a('. We can "read out" this state as the binary number '),Ee=r("span"),Xt=a(", which - as we saw above - is equal to "),en=r("span"),Gt=a("."),fn=q(),Se=r("h2"),Jt=a("QFT on the qubit level"),_n=q(),je=r("p"),Wt=a("The quantum Fourier transform is an operation that modifies the states of qubits in a particular way. (How this is done in practice is another topic, for now we'll only look at the mathematics.) Namely, if "),dn=r("span"),Nn=a(" is the number represented by the qubits (in the example above, "),un=r("span"),St=a("), the QFT sets the state of the "),Ae=r("span"),Tn=a("-th qubit to "),tt=r("span"),Cn=a(". In other words, it sets "),cn=r("span"),Wn=a(" and "),vn=r("span"),Pn=a(" for all "),De=r("span"),jn=a("."),$n=q(),It=r("p"),hs=a("Notice that even though "),Sn=r("span"),us=a(", the associated measurement probabilities "),An=r("span"),ms=a(" for all "),Mn=r("span"),ps=a(". This is because the "),Hn=r("span"),Ft=a(" term - as we saw in section 2.3 - indicates the qubit's phase and does not affect measurement probabilities."),Un=q(),Oe=r("p"),fs=a("Just like the state of a single qubit can be the linear combination of "),Ln=r("span"),qn=a(" and "),kn=r("span"),_s=a(", the joint state of these "),In=r("span"),ds=a(" qubits is essentially the linear combination of all the possible combinations of the "),Kn=r("span"),Js=a(" basis states - which, as we saw in the previous section, represent the integers from "),On=r("span"),Zs=a(" to "),Xn=r("span"),Ys=a(". Since both basis states are measured with a probability of "),Gn=r("span"),xs=a(" for each qubit, one particular combination of the "),Jn=r("span"),er=a(" basis states is measured with a probability of "),Zn=r("span"),tr=a(". What differs across these combinations are the phase, as we'll see in the next section."),Ts=q(),Yn=r("h2"),nr=a("QFT on the representation level"),Ps=q(),xn=r("p"),ar=a("Next, let's write out the joint state of the qubits:"),$s=q(),ea=r("p"),ta=r("span"),Ss=q(),Fn=r("p"),sr=a("We can factor out the "),na=r("span"),rr=a(" term to get:"),ks=q(),aa=r("p"),sa=r("span"),As=q(),be=r("p"),or=a("Let "),ra=r("span"),lr=a(" denote the binary number represented by the "),oa=r("span"),ir=a(" qubits in a given basis state, and "),la=r("span"),hr=a(" the "),ia=r("span"),ur=a("-th digit of "),ha=r("span"),mr=a(". In other words, "),ua=r("span"),pr=a("\xA0if the "),ma=r("span"),fr=a("-th qubit is in the "),pa=r("span"),_r=a(" state, and "),fa=r("span"),dr=a("\xA0if it's in the "),_a=r("span"),cr=a(" state for all "),da=r("span"),vr=a(". Recalling the section on the binary number system, we can write "),ca=r("span"),wr=a(" as the weighted sum of its digits: "),va=r("span"),br=a(". Notice that the "),wa=r("span"),yr=a(" term within the sum does not depend on "),ba=r("span"),gr=a(" and so we can factor it out: "),ya=r("span"),Er=a(". Remember this step, as it is going to be important shortly!"),Ms=q(),ga=r("p"),Nr=a("Using this new notation, we can write the joint state of the qubits in the form of a sum instead of a product:"),Hs=q(),Ea=r("p"),Na=r("span"),Ls=q(),kt=r("p"),Tr=a("In case you're wondering how the formula above can be derived from the definition we started with, note that for all "),Ta=r("span"),Pr=a(", the term "),Pa=r("span"),$r=a(` equals
* `),$a=r("span"),Sr=a(" if "),Sa=r("span"),kr=a(`, and
* `),ka=r("span"),Ar=a(" if "),Aa=r("span"),Mr=a(", which is exactly how we defined the QFT."),qs=q(),an=r("p"),Hr=a("The "),Ma=r("span"),Lr=a(" embedded summations might seem confusing at first, but what they actually do is iterate over all possible combinations of basis states. In the final sum, these are included with "),cs=r("em"),qr=a("equal weight"),Ir=a(" (meaning they are measured with equal probability), but the composing basis states will have "),vs=r("em"),Fr=a("different phases"),Vr=a(" in each combination, as already mentioned at the end of the previous section."),Is=q(),Vn=r("p"),Br=a("Let's now define the "),ws=r("em"),Qr=a("phase of the combination"),zr=a(" as the product of the phases of individual qubits within that combination, and factor it out as shown below:"),Fs=q(),Ha=r("p"),La=r("span"),Vs=q(),qa=r("p"),Ia=r("span"),Bs=q(),Fa=r("p"),Cr=a("After making use of the product rule for exponents..."),Qs=q(),Va=r("p"),Ba=r("span"),zs=q(),wn=r("p"),Wr=a("and factoring out the "),Qa=r("span"),jr=a(" term that does not depend on "),za=r("span"),Dr=a(", we arrive at the formula below:"),Cs=q(),Ca=r("p"),Wa=r("span"),Ws=q(),At=r("p"),Rr=a("Recall what I asked you to keep in mind a few paragraphs ago, and notice that the sum in the exponential "),ja=r("span"),Ur=a(" is actually equal to "),Da=r("span"),Kr=a(". Thus, we can now replace the individual "),Ra=r("span"),Or=a(" digits with the number "),Ua=r("span"),Xr=a(" itself and the multiple, embedded summations with a single one that iterates over all possible values of "),Ka=r("span"),Gr=a(". In addition, let's abbreviate the notation we used for the product of the basis states with "),Oa=r("span"),Jr=a(", to finally obtain this way more elegant formula for the QFT:"),js=q(),Xa=r("p"),Ga=r("span"),Ds=q(),bn=r("p"),Zr=a("The elegance comes from the fact that it shows what the qubits "),bs=r("em"),Yr=a("represent on a symbolic level"),xr=a(", as opposed to the expression we started with that is a direct insight into the "),ys=r("em"),eo=a("bit-level"),to=a(" implementation."),Rs=q(),Vt=r("p"),no=a("Now let's illustrate visually what the formula above actually means. To give a proper intuition, we'll look at multiple systems with increasing number of qubits. For the chosen value of "),Ja=r("span"),ao=a(", the plot below shows the "),Za=r("span"),so=a(" terms for all possible values of "),Ya=r("span"),ro=a(" that these systems can represent. Because this term is a complex number, the geometric representation of which would require 2 dimensions, the real and imaginary components are shown separately. Notice that as the number of qubits increases, the plots gradually turn into sinusoidal wave patterns. Furthermore, the number of peaks of these waves - their frequency - equals "),xa=r("span"),oo=a(", which you can verify by modifying "),es=r("span"),lo=a(" with the help of the slider.")},l(p){i=o(p,"H2",{});var X=l(i);f=s(X,"Quantum Fourier transform"),X.forEach(t),d=I(p),u=o(p,"H2",{});var fo=l(u);y=s(fo,"Binary number system"),fo.forEach(t),v=I(p),c=o(p,"P",{});var Xe=l(c);g=s(Xe,"In the decimal number system, there are "),b=o(Xe,"SPAN",{});var Vl=l(b);Vl.forEach(t),N=s(Xe," distinct symbols used to represent numbers: "),L=o(Xe,"SPAN",{});var Bl=l(L);Bl.forEach(t),A=s(Xe,". The value of these symbols depends on their place in a given number. For example, in the number "),V=o(Xe,"SPAN",{});var Ql=l(V);Ql.forEach(t),Q=s(Xe,", the symbol "),S=o(Xe,"SPAN",{});var zl=l(S);zl.forEach(t),k=s(Xe," stands for "),O=o(Xe,"SPAN",{});var Cl=l(O);Cl.forEach(t),j=s(Xe,", whereas in the number "),M=o(Xe,"SPAN",{});var Wl=l(M);Wl.forEach(t),U=s(Xe,", it represents "),G=o(Xe,"SPAN",{});var jl=l(G);jl.forEach(t),E=s(Xe,". In general, an integer in decimal notation with "),F=o(Xe,"SPAN",{});var Dl=l(F);Dl.forEach(t),D=s(Xe," digits equals "),Y=o(Xe,"SPAN",{});var Rl=l(Y);Rl.forEach(t),K=s(Xe,", where "),J=o(Xe,"SPAN",{});var Ul=l(J);Ul.forEach(t),w=s(Xe," is the "),$=o(Xe,"SPAN",{});var Kl=l($);Kl.forEach(t),se=s(Xe,"-th digit (going from left to right). To illustrate this with a concrete example, the number above "),Z=o(Xe,"SPAN",{});var Ol=l(Z);Ol.forEach(t),me=s(Xe,"."),Xe.forEach(t),he=I(p),ie=o(p,"P",{});var Bt=l(ie);Fe=s(Bt,"Analogously, in the binary number system, there are "),we=o(Bt,"SPAN",{});var Xl=l(we);Xl.forEach(t),Be=s(Bt," distinct symbols used to represent numbers: "),Te=o(Bt,"SPAN",{});var Gl=l(Te);Gl.forEach(t),pe=s(Bt," and "),fe=o(Bt,"SPAN",{});var Jl=l(fe);Jl.forEach(t),Ve=s(Bt,". The value of an integer in binary notation equals to "),Qe=o(Bt,"SPAN",{});var Zl=l(Qe);Zl.forEach(t),Ue=s(Bt,", where "),ue=o(Bt,"SPAN",{});var Yl=l(ue);Yl.forEach(t),oe=s(Bt," is the "),Le=o(Bt,"SPAN",{});var xl=l(Le);xl.forEach(t),nt=s(Bt,"-th (binary) digit. For instance, the binary number "),ze=o(Bt,"SPAN",{});var ei=l(ze);ei.forEach(t),at=s(Bt,"."),Bt.forEach(t),Ye=I(p),Ke=o(p,"H2",{});var _o=l(Ke);ae=s(_o,"Representing numbers with qubits"),_o.forEach(t),ye=I(p),R=o(p,"P",{});var sn=l(R);Ie=s(sn,"Consider "),xe=o(sn,"SPAN",{});var ti=l(xe);ti.forEach(t),ut=s(sn," qubits aranged in a row, each of which are in either of the two basis states "),et=o(sn,"SPAN",{});var ni=l(et);ni.forEach(t),lt=s(sn," or "),ke=o(sn,"SPAN",{});var ai=l(ke);ai.forEach(t),it=s(sn,". With a little combinatorics, we can see that there are "),mt=o(sn,"SPAN",{});var si=l(mt);si.forEach(t),pt=s(sn," such combinations. For ease of notation, let "),yt=o(sn,"SPAN",{});var ri=l(yt);ri.forEach(t),te=s(sn,"."),sn.forEach(t),qe=I(p),le=o(p,"P",{});var Zt=l(le);st=s(Zt,"For our purposes, we'll interpret these combinations as the binary representations of the numbers from "),rt=o(Zt,"SPAN",{});var oi=l(rt);oi.forEach(t),ot=s(Zt," to "),$t=o(Zt,"SPAN",{});var li=l($t);li.forEach(t),Ct=s(Zt,". For example, let "),x=o(Zt,"SPAN",{});var ii=l(x);ii.forEach(t),qt=s(Zt," and the qubits be in the following state: "),Ht=o(Zt,"SPAN",{});var hi=l(Ht);hi.forEach(t),ve=s(Zt,'. We can "read out" this state as the binary number '),Ee=o(Zt,"SPAN",{});var ui=l(Ee);ui.forEach(t),Xt=s(Zt,", which - as we saw above - is equal to "),en=o(Zt,"SPAN",{});var mi=l(en);mi.forEach(t),Gt=s(Zt,"."),Zt.forEach(t),fn=I(p),Se=o(p,"H2",{});var co=l(Se);Jt=s(co,"QFT on the qubit level"),co.forEach(t),_n=I(p),je=o(p,"P",{});var Qt=l(je);Wt=s(Qt,"The quantum Fourier transform is an operation that modifies the states of qubits in a particular way. (How this is done in practice is another topic, for now we'll only look at the mathematics.) Namely, if "),dn=o(Qt,"SPAN",{});var pi=l(dn);pi.forEach(t),Nn=s(Qt," is the number represented by the qubits (in the example above, "),un=o(Qt,"SPAN",{});var fi=l(un);fi.forEach(t),St=s(Qt,"), the QFT sets the state of the "),Ae=o(Qt,"SPAN",{});var _i=l(Ae);_i.forEach(t),Tn=s(Qt,"-th qubit to "),tt=o(Qt,"SPAN",{});var di=l(tt);di.forEach(t),Cn=s(Qt,". In other words, it sets "),cn=o(Qt,"SPAN",{});var ci=l(cn);ci.forEach(t),Wn=s(Qt," and "),vn=o(Qt,"SPAN",{});var vi=l(vn);vi.forEach(t),Pn=s(Qt," for all "),De=o(Qt,"SPAN",{});var wi=l(De);wi.forEach(t),jn=s(Qt,"."),Qt.forEach(t),$n=I(p),It=o(p,"P",{});var yn=l(It);hs=s(yn,"Notice that even though "),Sn=o(yn,"SPAN",{});var bi=l(Sn);bi.forEach(t),us=s(yn,", the associated measurement probabilities "),An=o(yn,"SPAN",{});var yi=l(An);yi.forEach(t),ms=s(yn," for all "),Mn=o(yn,"SPAN",{});var gi=l(Mn);gi.forEach(t),ps=s(yn,". This is because the "),Hn=o(yn,"SPAN",{});var Ei=l(Hn);Ei.forEach(t),Ft=s(yn," term - as we saw in section 2.3 - indicates the qubit's phase and does not affect measurement probabilities."),yn.forEach(t),Un=I(p),Oe=o(p,"P",{});var Tt=l(Oe);fs=s(Tt,"Just like the state of a single qubit can be the linear combination of "),Ln=o(Tt,"SPAN",{});var Ni=l(Ln);Ni.forEach(t),qn=s(Tt," and "),kn=o(Tt,"SPAN",{});var Ti=l(kn);Ti.forEach(t),_s=s(Tt,", the joint state of these "),In=o(Tt,"SPAN",{});var Pi=l(In);Pi.forEach(t),ds=s(Tt," qubits is essentially the linear combination of all the possible combinations of the "),Kn=o(Tt,"SPAN",{});var $i=l(Kn);$i.forEach(t),Js=s(Tt," basis states - which, as we saw in the previous section, represent the integers from "),On=o(Tt,"SPAN",{});var Si=l(On);Si.forEach(t),Zs=s(Tt," to "),Xn=o(Tt,"SPAN",{});var ki=l(Xn);ki.forEach(t),Ys=s(Tt,". Since both basis states are measured with a probability of "),Gn=o(Tt,"SPAN",{});var Ai=l(Gn);Ai.forEach(t),xs=s(Tt," for each qubit, one particular combination of the "),Jn=o(Tt,"SPAN",{});var Mi=l(Jn);Mi.forEach(t),er=s(Tt," basis states is measured with a probability of "),Zn=o(Tt,"SPAN",{});var Hi=l(Zn);Hi.forEach(t),tr=s(Tt,". What differs across these combinations are the phase, as we'll see in the next section."),Tt.forEach(t),Ts=I(p),Yn=o(p,"H2",{});var vo=l(Yn);nr=s(vo,"QFT on the representation level"),vo.forEach(t),Ps=I(p),xn=o(p,"P",{});var wo=l(xn);ar=s(wo,"Next, let's write out the joint state of the qubits:"),wo.forEach(t),$s=I(p),ea=o(p,"P",{});var bo=l(ea);ta=o(bo,"SPAN",{});var Li=l(ta);Li.forEach(t),bo.forEach(t),Ss=I(p),Fn=o(p,"P",{});var Us=l(Fn);sr=s(Us,"We can factor out the "),na=o(Us,"SPAN",{});var qi=l(na);qi.forEach(t),rr=s(Us," term to get:"),Us.forEach(t),ks=I(p),aa=o(p,"P",{});var yo=l(aa);sa=o(yo,"SPAN",{});var Ii=l(sa);Ii.forEach(t),yo.forEach(t),As=I(p),be=o(p,"P",{});var Me=l(be);or=s(Me,"Let "),ra=o(Me,"SPAN",{});var Fi=l(ra);Fi.forEach(t),lr=s(Me," denote the binary number represented by the "),oa=o(Me,"SPAN",{});var Vi=l(oa);Vi.forEach(t),ir=s(Me," qubits in a given basis state, and "),la=o(Me,"SPAN",{});var Bi=l(la);Bi.forEach(t),hr=s(Me," the "),ia=o(Me,"SPAN",{});var Qi=l(ia);Qi.forEach(t),ur=s(Me,"-th digit of "),ha=o(Me,"SPAN",{});var zi=l(ha);zi.forEach(t),mr=s(Me,". In other words, "),ua=o(Me,"SPAN",{});var Ci=l(ua);Ci.forEach(t),pr=s(Me,"\xA0if the "),ma=o(Me,"SPAN",{});var Wi=l(ma);Wi.forEach(t),fr=s(Me,"-th qubit is in the "),pa=o(Me,"SPAN",{});var ji=l(pa);ji.forEach(t),_r=s(Me," state, and "),fa=o(Me,"SPAN",{});var Di=l(fa);Di.forEach(t),dr=s(Me,"\xA0if it's in the "),_a=o(Me,"SPAN",{});var Ri=l(_a);Ri.forEach(t),cr=s(Me," state for all "),da=o(Me,"SPAN",{});var Ui=l(da);Ui.forEach(t),vr=s(Me,". Recalling the section on the binary number system, we can write "),ca=o(Me,"SPAN",{});var Ki=l(ca);Ki.forEach(t),wr=s(Me," as the weighted sum of its digits: "),va=o(Me,"SPAN",{});var Oi=l(va);Oi.forEach(t),br=s(Me,". Notice that the "),wa=o(Me,"SPAN",{});var Xi=l(wa);Xi.forEach(t),yr=s(Me," term within the sum does not depend on "),ba=o(Me,"SPAN",{});var Gi=l(ba);Gi.forEach(t),gr=s(Me," and so we can factor it out: "),ya=o(Me,"SPAN",{});var Ji=l(ya);Ji.forEach(t),Er=s(Me,". Remember this step, as it is going to be important shortly!"),Me.forEach(t),Ms=I(p),ga=o(p,"P",{});var go=l(ga);Nr=s(go,"Using this new notation, we can write the joint state of the qubits in the form of a sum instead of a product:"),go.forEach(t),Hs=I(p),Ea=o(p,"P",{});var Eo=l(Ea);Na=o(Eo,"SPAN",{});var Zi=l(Na);Zi.forEach(t),Eo.forEach(t),Ls=I(p),kt=o(p,"P",{});var Yt=l(kt);Tr=s(Yt,"In case you're wondering how the formula above can be derived from the definition we started with, note that for all "),Ta=o(Yt,"SPAN",{});var Yi=l(Ta);Yi.forEach(t),Pr=s(Yt,", the term "),Pa=o(Yt,"SPAN",{});var xi=l(Pa);xi.forEach(t),$r=s(Yt,` equals
* `),$a=o(Yt,"SPAN",{});var eh=l($a);eh.forEach(t),Sr=s(Yt," if "),Sa=o(Yt,"SPAN",{});var th=l(Sa);th.forEach(t),kr=s(Yt,`, and
* `),ka=o(Yt,"SPAN",{});var nh=l(ka);nh.forEach(t),Ar=s(Yt," if "),Aa=o(Yt,"SPAN",{});var ah=l(Aa);ah.forEach(t),Mr=s(Yt,", which is exactly how we defined the QFT."),Yt.forEach(t),qs=I(p),an=o(p,"P",{});var Bn=l(an);Hr=s(Bn,"The "),Ma=o(Bn,"SPAN",{});var sh=l(Ma);sh.forEach(t),Lr=s(Bn," embedded summations might seem confusing at first, but what they actually do is iterate over all possible combinations of basis states. In the final sum, these are included with "),cs=o(Bn,"EM",{});var No=l(cs);qr=s(No,"equal weight"),No.forEach(t),Ir=s(Bn," (meaning they are measured with equal probability), but the composing basis states will have "),vs=o(Bn,"EM",{});var To=l(vs);Fr=s(To,"different phases"),To.forEach(t),Vr=s(Bn," in each combination, as already mentioned at the end of the previous section."),Bn.forEach(t),Is=I(p),Vn=o(p,"P",{});var Ks=l(Vn);Br=s(Ks,"Let's now define the "),ws=o(Ks,"EM",{});var Po=l(ws);Qr=s(Po,"phase of the combination"),Po.forEach(t),zr=s(Ks," as the product of the phases of individual qubits within that combination, and factor it out as shown below:"),Ks.forEach(t),Fs=I(p),Ha=o(p,"P",{});var $o=l(Ha);La=o($o,"SPAN",{});var rh=l(La);rh.forEach(t),$o.forEach(t),Vs=I(p),qa=o(p,"P",{});var So=l(qa);Ia=o(So,"SPAN",{});var oh=l(Ia);oh.forEach(t),So.forEach(t),Bs=I(p),Fa=o(p,"P",{});var ko=l(Fa);Cr=s(ko,"After making use of the product rule for exponents..."),ko.forEach(t),Qs=I(p),Va=o(p,"P",{});var Ao=l(Va);Ba=o(Ao,"SPAN",{});var lh=l(Ba);lh.forEach(t),Ao.forEach(t),zs=I(p),wn=o(p,"P",{});var ts=l(wn);Wr=s(ts,"and factoring out the "),Qa=o(ts,"SPAN",{});var ih=l(Qa);ih.forEach(t),jr=s(ts," term that does not depend on "),za=o(ts,"SPAN",{});var hh=l(za);hh.forEach(t),Dr=s(ts,", we arrive at the formula below:"),ts.forEach(t),Cs=I(p),Ca=o(p,"P",{});var Mo=l(Ca);Wa=o(Mo,"SPAN",{});var uh=l(Wa);uh.forEach(t),Mo.forEach(t),Ws=I(p),At=o(p,"P",{});var xt=l(At);Rr=s(xt,"Recall what I asked you to keep in mind a few paragraphs ago, and notice that the sum in the exponential "),ja=o(xt,"SPAN",{});var mh=l(ja);mh.forEach(t),Ur=s(xt," is actually equal to "),Da=o(xt,"SPAN",{});var ph=l(Da);ph.forEach(t),Kr=s(xt,". Thus, we can now replace the individual "),Ra=o(xt,"SPAN",{});var fh=l(Ra);fh.forEach(t),Or=s(xt," digits with the number "),Ua=o(xt,"SPAN",{});var _h=l(Ua);_h.forEach(t),Xr=s(xt," itself and the multiple, embedded summations with a single one that iterates over all possible values of "),Ka=o(xt,"SPAN",{});var dh=l(Ka);dh.forEach(t),Gr=s(xt,". In addition, let's abbreviate the notation we used for the product of the basis states with "),Oa=o(xt,"SPAN",{});var ch=l(Oa);ch.forEach(t),Jr=s(xt,", to finally obtain this way more elegant formula for the QFT:"),xt.forEach(t),js=I(p),Xa=o(p,"P",{});var Ho=l(Xa);Ga=o(Ho,"SPAN",{});var vh=l(Ga);vh.forEach(t),Ho.forEach(t),Ds=I(p),bn=o(p,"P",{});var ns=l(bn);Zr=s(ns,"The elegance comes from the fact that it shows what the qubits "),bs=o(ns,"EM",{});var Lo=l(bs);Yr=s(Lo,"represent on a symbolic level"),Lo.forEach(t),xr=s(ns,", as opposed to the expression we started with that is a direct insight into the "),ys=o(ns,"EM",{});var qo=l(ys);eo=s(qo,"bit-level"),qo.forEach(t),to=s(ns," implementation."),ns.forEach(t),Rs=I(p),Vt=o(p,"P",{});var rn=l(Vt);no=s(rn,"Now let's illustrate visually what the formula above actually means. To give a proper intuition, we'll look at multiple systems with increasing number of qubits. For the chosen value of "),Ja=o(rn,"SPAN",{});var wh=l(Ja);wh.forEach(t),ao=s(rn,", the plot below shows the "),Za=o(rn,"SPAN",{});var bh=l(Za);bh.forEach(t),so=s(rn," terms for all possible values of "),Ya=o(rn,"SPAN",{});var yh=l(Ya);yh.forEach(t),ro=s(rn," that these systems can represent. Because this term is a complex number, the geometric representation of which would require 2 dimensions, the real and imaginary components are shown separately. Notice that as the number of qubits increases, the plots gradually turn into sinusoidal wave patterns. Furthermore, the number of peaks of these waves - their frequency - equals "),xa=o(rn,"SPAN",{});var gh=l(xa);gh.forEach(t),oo=s(rn,", which you can verify by modifying "),es=o(rn,"SPAN",{});var Eh=l(es);Eh.forEach(t),lo=s(rn," with the help of the slider."),rn.forEach(t)},m(p,X){_(p,i,X),e(i,f),_(p,d,X),_(p,u,X),e(u,y),_(p,v,X),_(p,c,X),e(c,g),e(c,b),b.innerHTML=B,e(c,N),e(c,L),L.innerHTML=z,e(c,A),e(c,V),V.innerHTML=ee,e(c,Q),e(c,S),S.innerHTML=C,e(c,k),e(c,O),O.innerHTML=P,e(c,j),e(c,M),M.innerHTML=W,e(c,U),e(c,G),G.innerHTML=ne,e(c,E),e(c,F),F.innerHTML=T,e(c,D),e(c,Y),Y.innerHTML=_e,e(c,K),e(c,J),J.innerHTML=ge,e(c,w),e(c,$),$.innerHTML=Ne,e(c,se),e(c,Z),Z.innerHTML=ce,e(c,me),_(p,he,X),_(p,ie,X),e(ie,Fe),e(ie,we),we.innerHTML=Pt,e(ie,Be),e(ie,Te),Te.innerHTML=Pe,e(ie,pe),e(ie,fe),fe.innerHTML=re,e(ie,Ve),e(ie,Qe),Qe.innerHTML=Ze,e(ie,Ue),e(ie,ue),ue.innerHTML=$e,e(ie,oe),e(ie,Le),Le.innerHTML=wt,e(ie,nt),e(ie,ze),ze.innerHTML=bt,e(ie,at),_(p,Ye,X),_(p,Ke,X),e(Ke,ae),_(p,ye,X),_(p,R,X),e(R,Ie),e(R,xe),xe.innerHTML=gt,e(R,ut),e(R,et),et.innerHTML=Ut,e(R,lt),e(R,ke),ke.innerHTML=Kt,e(R,it),e(R,mt),mt.innerHTML=Ot,e(R,pt),e(R,yt),yt.innerHTML=zt,e(R,te),_(p,qe,X),_(p,le,X),e(le,st),e(le,rt),rt.innerHTML=pn,e(le,ot),e(le,$t),$t.innerHTML=gn,e(le,Ct),e(le,x),x.innerHTML=ln,e(le,qt),e(le,Ht),Ht.innerHTML=hn,e(le,ve),e(le,Ee),Ee.innerHTML=Et,e(le,Xt),e(le,en),en.innerHTML=En,e(le,Gt),_(p,fn,X),_(p,Se,X),e(Se,Jt),_(p,_n,X),_(p,je,X),e(je,Wt),e(je,dn),dn.innerHTML=zn,e(je,Nn),e(je,un),un.innerHTML=He,e(je,St),e(je,Ae),Ae.innerHTML=tn,e(je,Tn),e(je,tt),tt.innerHTML=rs,e(je,Cn),e(je,cn),cn.innerHTML=os,e(je,Wn),e(je,vn),vn.innerHTML=ls,e(je,Pn),e(je,De),De.innerHTML=is,e(je,jn),_(p,$n,X),_(p,It,X),e(It,hs),e(It,Sn),Sn.innerHTML=Nt,e(It,us),e(It,An),An.innerHTML=Os,e(It,ms),e(It,Mn),Mn.innerHTML=Xs,e(It,ps),e(It,Hn),Hn.innerHTML=Es,e(It,Ft),_(p,Un,X),_(p,Oe,X),e(Oe,fs),e(Oe,Ln),Ln.innerHTML=Ns,e(Oe,qn),e(Oe,kn),kn.innerHTML=nn,e(Oe,_s),e(Oe,In),In.innerHTML=Gs,e(Oe,ds),e(Oe,Kn),Kn.innerHTML=zo,e(Oe,Js),e(Oe,On),On.innerHTML=Co,e(Oe,Zs),e(Oe,Xn),Xn.innerHTML=Wo,e(Oe,Ys),e(Oe,Gn),Gn.innerHTML=jo,e(Oe,xs),e(Oe,Jn),Jn.innerHTML=Do,e(Oe,er),e(Oe,Zn),Zn.innerHTML=Ro,e(Oe,tr),_(p,Ts,X),_(p,Yn,X),e(Yn,nr),_(p,Ps,X),_(p,xn,X),e(xn,ar),_(p,$s,X),_(p,ea,X),e(ea,ta),ta.innerHTML=Uo,_(p,Ss,X),_(p,Fn,X),e(Fn,sr),e(Fn,na),na.innerHTML=Ko,e(Fn,rr),_(p,ks,X),_(p,aa,X),e(aa,sa),sa.innerHTML=Oo,_(p,As,X),_(p,be,X),e(be,or),e(be,ra),ra.innerHTML=Xo,e(be,lr),e(be,oa),oa.innerHTML=Go,e(be,ir),e(be,la),la.innerHTML=Jo,e(be,hr),e(be,ia),ia.innerHTML=Zo,e(be,ur),e(be,ha),ha.innerHTML=Yo,e(be,mr),e(be,ua),ua.innerHTML=xo,e(be,pr),e(be,ma),ma.innerHTML=el,e(be,fr),e(be,pa),pa.innerHTML=tl,e(be,_r),e(be,fa),fa.innerHTML=nl,e(be,dr),e(be,_a),_a.innerHTML=al,e(be,cr),e(be,da),da.innerHTML=sl,e(be,vr),e(be,ca),ca.innerHTML=rl,e(be,wr),e(be,va),va.innerHTML=ol,e(be,br),e(be,wa),wa.innerHTML=ll,e(be,yr),e(be,ba),ba.innerHTML=il,e(be,gr),e(be,ya),ya.innerHTML=hl,e(be,Er),_(p,Ms,X),_(p,ga,X),e(ga,Nr),_(p,Hs,X),_(p,Ea,X),e(Ea,Na),Na.innerHTML=ul,_(p,Ls,X),_(p,kt,X),e(kt,Tr),e(kt,Ta),Ta.innerHTML=ml,e(kt,Pr),e(kt,Pa),Pa.innerHTML=pl,e(kt,$r),e(kt,$a),$a.innerHTML=fl,e(kt,Sr),e(kt,Sa),Sa.innerHTML=_l,e(kt,kr),e(kt,ka),ka.innerHTML=dl,e(kt,Ar),e(kt,Aa),Aa.innerHTML=cl,e(kt,Mr),_(p,qs,X),_(p,an,X),e(an,Hr),e(an,Ma),Ma.innerHTML=vl,e(an,Lr),e(an,cs),e(cs,qr),e(an,Ir),e(an,vs),e(vs,Fr),e(an,Vr),_(p,Is,X),_(p,Vn,X),e(Vn,Br),e(Vn,ws),e(ws,Qr),e(Vn,zr),_(p,Fs,X),_(p,Ha,X),e(Ha,La),La.innerHTML=wl,_(p,Vs,X),_(p,qa,X),e(qa,Ia),Ia.innerHTML=bl,_(p,Bs,X),_(p,Fa,X),e(Fa,Cr),_(p,Qs,X),_(p,Va,X),e(Va,Ba),Ba.innerHTML=yl,_(p,zs,X),_(p,wn,X),e(wn,Wr),e(wn,Qa),Qa.innerHTML=gl,e(wn,jr),e(wn,za),za.innerHTML=El,e(wn,Dr),_(p,Cs,X),_(p,Ca,X),e(Ca,Wa),Wa.innerHTML=Nl,_(p,Ws,X),_(p,At,X),e(At,Rr),e(At,ja),ja.innerHTML=Tl,e(At,Ur),e(At,Da),Da.innerHTML=Pl,e(At,Kr),e(At,Ra),Ra.innerHTML=$l,e(At,Or),e(At,Ua),Ua.innerHTML=Sl,e(At,Xr),e(At,Ka),Ka.innerHTML=kl,e(At,Gr),e(At,Oa),Oa.innerHTML=Al,e(At,Jr),_(p,js,X),_(p,Xa,X),e(Xa,Ga),Ga.innerHTML=Ml,_(p,Ds,X),_(p,bn,X),e(bn,Zr),e(bn,bs),e(bs,Yr),e(bn,xr),e(bn,ys),e(ys,eo),e(bn,to),_(p,Rs,X),_(p,Vt,X),e(Vt,no),e(Vt,Ja),Ja.innerHTML=Hl,e(Vt,ao),e(Vt,Za),Za.innerHTML=Ll,e(Vt,so),e(Vt,Ya),Ya.innerHTML=ql,e(Vt,ro),e(Vt,xa),xa.innerHTML=Il,e(Vt,oo),e(Vt,es),es.innerHTML=Fl,e(Vt,lo),io||(po=[m(b,"mouseenter",n[0]),m(L,"mouseenter",n[1]),m(V,"mouseenter",n[2]),m(S,"mouseenter",n[3]),m(O,"mouseenter",n[4]),m(M,"mouseenter",n[5]),m(G,"mouseenter",n[6]),m(F,"mouseenter",n[7]),m(Y,"mouseenter",n[8]),m(J,"mouseenter",n[9]),m($,"mouseenter",n[10]),m(Z,"mouseenter",n[11]),m(we,"mouseenter",n[12]),m(Te,"mouseenter",n[13]),m(fe,"mouseenter",n[14]),m(Qe,"mouseenter",n[15]),m(ue,"mouseenter",n[16]),m(Le,"mouseenter",n[17]),m(ze,"mouseenter",n[18]),m(xe,"mouseenter",n[19]),m(et,"mouseenter",n[20]),m(ke,"mouseenter",n[21]),m(mt,"mouseenter",n[22]),m(yt,"mouseenter",n[23]),m(rt,"mouseenter",n[24]),m($t,"mouseenter",n[25]),m(x,"mouseenter",n[26]),m(Ht,"mouseenter",n[27]),m(Ee,"mouseenter",n[28]),m(en,"mouseenter",n[29]),m(dn,"mouseenter",n[30]),m(un,"mouseenter",n[31]),m(Ae,"mouseenter",n[32]),m(tt,"mouseenter",n[33]),m(cn,"mouseenter",n[34]),m(vn,"mouseenter",n[35]),m(De,"mouseenter",n[36]),m(Sn,"mouseenter",n[37]),m(An,"mouseenter",n[38]),m(Mn,"mouseenter",n[39]),m(Hn,"mouseenter",n[40]),m(Ln,"mouseenter",n[41]),m(kn,"mouseenter",n[42]),m(In,"mouseenter",n[43]),m(Kn,"mouseenter",n[44]),m(On,"mouseenter",n[45]),m(Xn,"mouseenter",n[46]),m(Gn,"mouseenter",n[47]),m(Jn,"mouseenter",n[48]),m(Zn,"mouseenter",n[49]),m(ta,"mouseenter",n[50]),m(na,"mouseenter",n[51]),m(sa,"mouseenter",n[52]),m(ra,"mouseenter",n[53]),m(oa,"mouseenter",n[54]),m(la,"mouseenter",n[55]),m(ia,"mouseenter",n[56]),m(ha,"mouseenter",n[57]),m(ua,"mouseenter",n[58]),m(ma,"mouseenter",n[59]),m(pa,"mouseenter",n[60]),m(fa,"mouseenter",n[61]),m(_a,"mouseenter",n[62]),m(da,"mouseenter",n[63]),m(ca,"mouseenter",n[64]),m(va,"mouseenter",n[65]),m(wa,"mouseenter",n[66]),m(ba,"mouseenter",n[67]),m(ya,"mouseenter",n[68]),m(Na,"mouseenter",n[69]),m(Ta,"mouseenter",n[70]),m(Pa,"mouseenter",n[71]),m($a,"mouseenter",n[72]),m(Sa,"mouseenter",n[73]),m(ka,"mouseenter",n[74]),m(Aa,"mouseenter",n[75]),m(Ma,"mouseenter",n[76]),m(La,"mouseenter",n[77]),m(Ia,"mouseenter",n[78]),m(Ba,"mouseenter",n[79]),m(Qa,"mouseenter",n[80]),m(za,"mouseenter",n[81]),m(Wa,"mouseenter",n[82]),m(ja,"mouseenter",n[83]),m(Da,"mouseenter",n[84]),m(Ra,"mouseenter",n[85]),m(Ua,"mouseenter",n[86]),m(Ka,"mouseenter",n[87]),m(Oa,"mouseenter",n[88]),m(Ga,"mouseenter",n[89]),m(Ja,"mouseenter",n[90]),m(Za,"mouseenter",n[91]),m(Ya,"mouseenter",n[92]),m(xa,"mouseenter",n[93]),m(es,"mouseenter",n[94])],io=!0)},p:vt,i:vt,o:vt,d(p){p&&t(i),p&&t(d),p&&t(u),p&&t(v),p&&t(c),p&&t(he),p&&t(ie),p&&t(Ye),p&&t(Ke),p&&t(ye),p&&t(R),p&&t(qe),p&&t(le),p&&t(fn),p&&t(Se),p&&t(_n),p&&t(je),p&&t($n),p&&t(It),p&&t(Un),p&&t(Oe),p&&t(Ts),p&&t(Yn),p&&t(Ps),p&&t(xn),p&&t($s),p&&t(ea),p&&t(Ss),p&&t(Fn),p&&t(ks),p&&t(aa),p&&t(As),p&&t(be),p&&t(Ms),p&&t(ga),p&&t(Hs),p&&t(Ea),p&&t(Ls),p&&t(kt),p&&t(qs),p&&t(an),p&&t(Is),p&&t(Vn),p&&t(Fs),p&&t(Ha),p&&t(Vs),p&&t(qa),p&&t(Bs),p&&t(Fa),p&&t(Qs),p&&t(Va),p&&t(zs),p&&t(wn),p&&t(Cs),p&&t(Ca),p&&t(Ws),p&&t(At),p&&t(js),p&&t(Xa),p&&t(Ds),p&&t(bn),p&&t(Rs),p&&t(Vt),io=!1,mn(po)}}}function H(n){console.log(n)}function lu(n){return[()=>H([]),()=>H([]),()=>H([]),()=>H([]),()=>H([]),()=>H([]),()=>H([]),()=>H(["n"]),()=>H(["d","n","k"]),()=>H(["k","d"]),()=>H(["k"]),()=>H([]),()=>H([]),()=>H([]),()=>H([]),()=>H(["d","n","k"]),()=>H(["k","d"]),()=>H(["k"]),()=>H([]),()=>H(["n"]),()=>H([]),()=>H([]),()=>H(["s","t","m","n"]),()=>H(["n","N"]),()=>H([]),()=>H(["N"]),()=>H(["n"]),()=>H([]),()=>H([]),()=>H([]),()=>H(["x"]),()=>H(["x"]),()=>H(["k"]),()=>H(["x","k"]),()=>H(["k","\\alpha"]),()=>H(["x","\\beta","k"]),()=>H(["n","k"]),()=>H(["\\beta","k","\\alpha"]),()=>H(["\\beta","k","\\alpha"]),()=>H(["n","k"]),()=>H(["x","k"]),()=>H([]),()=>H([]),()=>H(["n"]),()=>H(["n"]),()=>H([]),()=>H(["N"]),()=>H([]),()=>H(["n"]),()=>H(["m","r","t","s","N","n"]),()=>H(["m","x","r","t","s","n"]),()=>H([]),()=>H(["x","n","N"]),()=>H(["y"]),()=>H(["n"]),()=>H(["y","k"]),()=>H(["k"]),()=>H(["y"]),()=>H(["y","k"]),()=>H(["k"]),()=>H([]),()=>H(["y","k"]),()=>H([]),()=>H(["n","k"]),()=>H(["y"]),()=>H(["y","n","k"]),()=>H(["n"]),()=>H(["k"]),()=>H(["y","n","N","k"]),()=>H(["y","m","r","x","t","s","N","n"]),()=>H(["k"]),()=>H(["x","y","k"]),()=>H(["x","k"]),()=>H(["y","k"]),()=>H(["x","k"]),()=>H(["y","k"]),()=>H(["n"]),()=>H(["x","n","y","N"]),()=>H(["y","x","N","k","n"]),()=>H(["y","x","N","k","n"]),()=>H(["x"]),()=>H(["k"]),()=>H(["y","x","N","k","n"]),()=>H(["y","n","k"]),()=>H(["y","N"]),()=>H(["y","k"]),()=>H(["y"]),()=>H(["y"]),()=>H(["y","n"]),()=>H(["x","y","N"]),()=>H(["x"]),()=>H(["x","y","N"]),()=>H(["y"]),()=>H(["x"]),()=>H(["x"])]}class iu extends jt{constructor(i){super(),Dt(this,i,lu,ou,Rt,{},null,[-1,-1,-1,-1])}}function hu(n){let i,f,d,u;return i=new ru({}),d=new iu({}),{c(){ft(i.$$.fragment),f=q(),ft(d.$$.fragment)},l(y){_t(i.$$.fragment,y),f=I(y),_t(d.$$.fragment,y)},m(y,v){dt(i,y,v),_(y,f,v),dt(d,y,v),u=!0},p:vt,i(y){u||(Je(i.$$.fragment,y),Je(d.$$.fragment,y),u=!0)},o(y){ht(i.$$.fragment,y),ht(d.$$.fragment,y),u=!1},d(y){ct(i,y),y&&t(f),ct(d,y)}}}class uu extends jt{constructor(i){super(),Dt(this,i,null,hu,Rt,{})}}function mu(n){let i,f,d,u,y,v,c=h("\\alpha")+"",g,b,B=h("\\beta")+"",N,L,z=h("\\alpha = \\Vert{\\alpha}\\Vert \\cdot e^{i \\phi_{\\alpha}}")+"",A,V,ee=h("\\beta = \\Vert{\\beta}\\Vert \\cdot e^{i \\phi_{\\beta}}")+"",Q,S,C=h("\\Vert{\\alpha}\\Vert \\cdot e^{i \\phi_{\\alpha}} |0\\rangle + \\Vert{\\beta}\\Vert \\cdot e^{i \\phi_{\\beta}} |1\\rangle")+"",k,O,P,j,M,W=h("e^{i \\phi_{\\alpha}}")+"",U,G,ne=h("\\Vert{e^{i \\phi_{\\alpha}}}\\Vert^2")+"",E,F,T=h("1")+"",D,Y,_e=h("\\phi_{\\alpha}")+"",K,J,ge=h("\\phi_{\\beta}")+"",w,$,Ne=h("e^{i \\phi_{\\alpha}}")+"",se,Z,ce=h("\\Vert{\\alpha}\\Vert \\cdot |0\\rangle + \\Vert{\\beta}\\Vert \\cdot \\frac{e^{i \\phi_{\\beta}}}{e^{i \\phi_{\\alpha}}} |1\\rangle")+"",me,he,ie=h("\\frac{e^{i \\phi_{\\beta}}}{e^{i \\phi_{\\alpha}}} = e^{i (\\phi_{\\beta} - \\phi_{\\alpha})}")+"",Fe,we,Pt=h("\\phi = \\phi_{\\beta} - \\phi_{\\alpha}")+"",Be,Te,Pe=h("\\Vert{\\alpha}\\Vert \\cdot |0\\rangle + \\Vert{\\beta}\\Vert \\cdot e^{i \\phi} |1\\rangle")+"",pe,fe,re,Ve,Qe,Ze=h("\\Vert{\\alpha}\\Vert^2 + \\Vert{\\beta}\\Vert^2 = 1")+"",Ue,ue,$e,oe,Le,wt=h("\\theta")+"",nt,ze,bt=h("\\cos{(\\frac{\\theta}{2})} \\cdot |0 \\rangle + \\sin{(\\frac{\\theta}{2})} \\cdot e^{i \\phi} |1 \\rangle")+"",at,Ye,Ke=h("\\theta")+"",ae,ye,R=h("\\phi")+"",Ie,xe,gt=h("\\theta")+"",ut,et,Ut=h("z")+"",lt,ke,Kt=h("\\phi")+"",it,mt,Ot=h("x-y")+"",pt,yt,zt,te,qe,le,st,rt,pn=h("\\theta")+"",ot,$t,gn=h("\\phi")+"",Ct,x,ln,qt,Ht,hn;return{c(){i=r("h2"),f=a("The Bloch-sphere"),d=q(),u=r("p"),y=a("As the coefficients "),v=r("span"),g=a(" and "),b=r("span"),N=a(" are complex numbers, they can be expressed in the form "),L=r("span"),A=a(" and "),V=r("span"),Q=a(". Thus, the state of the qubit can be rewritten as "),S=r("span"),k=a("."),O=q(),P=r("p"),j=a("Remember that "),M=r("span"),U=a(" is a unit vector rotated around the origin, and therefore the square of its norm "),G=r("span"),E=a(" also equals to "),F=r("span"),D=a(". This means that we can modify the angles "),Y=r("span"),K=a(" and "),J=r("span"),w=a(" freely without affecting the measurement probabilities. Therefore, we can do an algebraic trick to simplify the expression above. Namely, let's divide the state by "),$=r("span"),se=a(" to obtain "),Z=r("span"),me=a(". By the rules of exponentiation, "),he=r("span"),Fe=a(". Next, let's introduce a new variable "),we=r("span"),Be=a(", with the help of which the state can be further simplified to "),Te=r("span"),pe=a("."),fe=q(),re=r("p"),Ve=a("We know that "),Qe=r("span"),Ue=a(". Consequently, these two numbers can also be represented geometrically as vector of unit length rotated around the origin by some angle, the "),ue=r("em"),$e=a("double"),oe=a(" of which we'll denote as "),Le=r("span"),nt=a(". Using trigonometry, we can now rewrite the state as "),ze=r("span"),at=a(". Notice, that we now only need two variables to express the state of the qubit: the angles "),Ye=r("span"),ae=a(" and "),ye=r("span"),Ie=a(". Geometrically, this can be represented as a vector pointing to the surface of 3-dimensional sphere with unit radius, where "),xe=r("span"),ut=a(" is the angle of the vector and the "),et=r("span"),lt=a(" axis, and "),ke=r("span"),it=a(" is the angle of the vertical projection of the vector on the "),mt=r("span"),pt=a(" plane. This representation of qubit states is called the "),yt=r("em"),zt=a("Bloch sphere"),te=a("."),qe=q(),le=r("p"),st=a("It's important to note that of the two degrees of freedom on the Bloch sphere, only the angle "),rt=r("span"),ot=a(" is related to measurement probabilities. "),$t=r("span"),Ct=a(" is an inherently quantum property called the "),x=r("em"),ln=a("phase"),qt=a(" that does not have physical manifestation directly observable to us. Because of this, it's hard to find any intuitive analogy from everyday life that could help us understand what exactly the phase is. The most useful approach in this context is to look at the phase as a matematical property of quantum objects that we can leverage to design clever algorithms.")},l(ve){i=o(ve,"H2",{});var Ee=l(i);f=s(Ee,"The Bloch-sphere"),Ee.forEach(t),d=I(ve),u=o(ve,"P",{});var Et=l(u);y=s(Et,"As the coefficients "),v=o(Et,"SPAN",{});var Xt=l(v);Xt.forEach(t),g=s(Et," and "),b=o(Et,"SPAN",{});var en=l(b);en.forEach(t),N=s(Et," are complex numbers, they can be expressed in the form "),L=o(Et,"SPAN",{});var En=l(L);En.forEach(t),A=s(Et," and "),V=o(Et,"SPAN",{});var Gt=l(V);Gt.forEach(t),Q=s(Et,". Thus, the state of the qubit can be rewritten as "),S=o(Et,"SPAN",{});var fn=l(S);fn.forEach(t),k=s(Et,"."),Et.forEach(t),O=I(ve),P=o(ve,"P",{});var Se=l(P);j=s(Se,"Remember that "),M=o(Se,"SPAN",{});var Jt=l(M);Jt.forEach(t),U=s(Se," is a unit vector rotated around the origin, and therefore the square of its norm "),G=o(Se,"SPAN",{});var _n=l(G);_n.forEach(t),E=s(Se," also equals to "),F=o(Se,"SPAN",{});var je=l(F);je.forEach(t),D=s(Se,". This means that we can modify the angles "),Y=o(Se,"SPAN",{});var Wt=l(Y);Wt.forEach(t),K=s(Se," and "),J=o(Se,"SPAN",{});var dn=l(J);dn.forEach(t),w=s(Se," freely without affecting the measurement probabilities. Therefore, we can do an algebraic trick to simplify the expression above. Namely, let's divide the state by "),$=o(Se,"SPAN",{});var zn=l($);zn.forEach(t),se=s(Se," to obtain "),Z=o(Se,"SPAN",{});var Nn=l(Z);Nn.forEach(t),me=s(Se,". By the rules of exponentiation, "),he=o(Se,"SPAN",{});var un=l(he);un.forEach(t),Fe=s(Se,". Next, let's introduce a new variable "),we=o(Se,"SPAN",{});var He=l(we);He.forEach(t),Be=s(Se,", with the help of which the state can be further simplified to "),Te=o(Se,"SPAN",{});var St=l(Te);St.forEach(t),pe=s(Se,"."),Se.forEach(t),fe=I(ve),re=o(ve,"P",{});var Ae=l(re);Ve=s(Ae,"We know that "),Qe=o(Ae,"SPAN",{});var tn=l(Qe);tn.forEach(t),Ue=s(Ae,". Consequently, these two numbers can also be represented geometrically as vector of unit length rotated around the origin by some angle, the "),ue=o(Ae,"EM",{});var Tn=l(ue);$e=s(Tn,"double"),Tn.forEach(t),oe=s(Ae," of which we'll denote as "),Le=o(Ae,"SPAN",{});var tt=l(Le);tt.forEach(t),nt=s(Ae,". Using trigonometry, we can now rewrite the state as "),ze=o(Ae,"SPAN",{});var rs=l(ze);rs.forEach(t),at=s(Ae,". Notice, that we now only need two variables to express the state of the qubit: the angles "),Ye=o(Ae,"SPAN",{});var Cn=l(Ye);Cn.forEach(t),ae=s(Ae," and "),ye=o(Ae,"SPAN",{});var cn=l(ye);cn.forEach(t),Ie=s(Ae,". Geometrically, this can be represented as a vector pointing to the surface of 3-dimensional sphere with unit radius, where "),xe=o(Ae,"SPAN",{});var os=l(xe);os.forEach(t),ut=s(Ae," is the angle of the vector and the "),et=o(Ae,"SPAN",{});var Wn=l(et);Wn.forEach(t),lt=s(Ae," axis, and "),ke=o(Ae,"SPAN",{});var vn=l(ke);vn.forEach(t),it=s(Ae," is the angle of the vertical projection of the vector on the "),mt=o(Ae,"SPAN",{});var ls=l(mt);ls.forEach(t),pt=s(Ae," plane. This representation of qubit states is called the "),yt=o(Ae,"EM",{});var Pn=l(yt);zt=s(Pn,"Bloch sphere"),Pn.forEach(t),te=s(Ae,"."),Ae.forEach(t),qe=I(ve),le=o(ve,"P",{});var De=l(le);st=s(De,"It's important to note that of the two degrees of freedom on the Bloch sphere, only the angle "),rt=o(De,"SPAN",{});var is=l(rt);is.forEach(t),ot=s(De," is related to measurement probabilities. "),$t=o(De,"SPAN",{});var jn=l($t);jn.forEach(t),Ct=s(De," is an inherently quantum property called the "),x=o(De,"EM",{});var $n=l(x);ln=s($n,"phase"),$n.forEach(t),qt=s(De," that does not have physical manifestation directly observable to us. Because of this, it's hard to find any intuitive analogy from everyday life that could help us understand what exactly the phase is. The most useful approach in this context is to look at the phase as a matematical property of quantum objects that we can leverage to design clever algorithms."),De.forEach(t)},m(ve,Ee){_(ve,i,Ee),e(i,f),_(ve,d,Ee),_(ve,u,Ee),e(u,y),e(u,v),v.innerHTML=c,e(u,g),e(u,b),b.innerHTML=B,e(u,N),e(u,L),L.innerHTML=z,e(u,A),e(u,V),V.innerHTML=ee,e(u,Q),e(u,S),S.innerHTML=C,e(u,k),_(ve,O,Ee),_(ve,P,Ee),e(P,j),e(P,M),M.innerHTML=W,e(P,U),e(P,G),G.innerHTML=ne,e(P,E),e(P,F),F.innerHTML=T,e(P,D),e(P,Y),Y.innerHTML=_e,e(P,K),e(P,J),J.innerHTML=ge,e(P,w),e(P,$),$.innerHTML=Ne,e(P,se),e(P,Z),Z.innerHTML=ce,e(P,me),e(P,he),he.innerHTML=ie,e(P,Fe),e(P,we),we.innerHTML=Pt,e(P,Be),e(P,Te),Te.innerHTML=Pe,e(P,pe),_(ve,fe,Ee),_(ve,re,Ee),e(re,Ve),e(re,Qe),Qe.innerHTML=Ze,e(re,Ue),e(re,ue),e(ue,$e),e(re,oe),e(re,Le),Le.innerHTML=wt,e(re,nt),e(re,ze),ze.innerHTML=bt,e(re,at),e(re,Ye),Ye.innerHTML=Ke,e(re,ae),e(re,ye),ye.innerHTML=R,e(re,Ie),e(re,xe),xe.innerHTML=gt,e(re,ut),e(re,et),et.innerHTML=Ut,e(re,lt),e(re,ke),ke.innerHTML=Kt,e(re,it),e(re,mt),mt.innerHTML=Ot,e(re,pt),e(re,yt),e(yt,zt),e(re,te),_(ve,qe,Ee),_(ve,le,Ee),e(le,st),e(le,rt),rt.innerHTML=pn,e(le,ot),e(le,$t),$t.innerHTML=gn,e(le,Ct),e(le,x),e(x,ln),e(le,qt),Ht||(hn=[m(v,"mouseenter",n[0]),m(b,"mouseenter",n[1]),m(L,"mouseenter",n[2]),m(V,"mouseenter",n[3]),m(S,"mouseenter",n[4]),m(M,"mouseenter",n[5]),m(G,"mouseenter",n[6]),m(F,"mouseenter",n[7]),m(Y,"mouseenter",n[8]),m(J,"mouseenter",n[9]),m($,"mouseenter",n[10]),m(Z,"mouseenter",n[11]),m(he,"mouseenter",n[12]),m(we,"mouseenter",n[13]),m(Te,"mouseenter",n[14]),m(Qe,"mouseenter",n[15]),m(Le,"mouseenter",n[16]),m(ze,"mouseenter",n[17]),m(Ye,"mouseenter",n[18]),m(ye,"mouseenter",n[19]),m(xe,"mouseenter",n[20]),m(et,"mouseenter",n[21]),m(ke,"mouseenter",n[22]),m(mt,"mouseenter",n[23]),m(rt,"mouseenter",n[24]),m($t,"mouseenter",n[25])],Ht=!0)},p:vt,i:vt,o:vt,d(ve){ve&&t(i),ve&&t(d),ve&&t(u),ve&&t(O),ve&&t(P),ve&&t(fe),ve&&t(re),ve&&t(qe),ve&&t(le),Ht=!1,mn(hn)}}}function Ge(n){console.log(n)}function pu(n){return[()=>Ge(["\\alpha"]),()=>Ge(["\\beta"]),()=>Ge(["\\phi","\\alpha"]),()=>Ge(["\\beta","\\phi"]),()=>Ge(["\\beta","\\phi","\\alpha"]),()=>Ge(["\\phi","\\alpha"]),()=>Ge(["\\phi","\\alpha"]),()=>Ge([]),()=>Ge(["\\phi","\\alpha"]),()=>Ge(["\\beta","\\phi"]),()=>Ge(["\\phi","\\alpha"]),()=>Ge(["\\beta","\\phi","\\alpha"]),()=>Ge(["\\beta","\\phi","\\alpha"]),()=>Ge(["\\beta","\\phi","\\alpha"]),()=>Ge(["\\beta","\\phi","\\alpha"]),()=>Ge(["\\beta","\\alpha"]),()=>Ge(["\\theta"]),()=>Ge(["\\theta","\\phi"]),()=>Ge(["\\theta"]),()=>Ge(["\\phi"]),()=>Ge(["\\theta"]),()=>Ge(["z"]),()=>Ge(["\\phi"]),()=>Ge(["x","y"]),()=>Ge(["\\theta"]),()=>Ge(["\\phi"])]}class fu extends jt{constructor(i){super(),Dt(this,i,pu,mu,Rt,{})}}const _u='<a href="https://en.wikipedia.org/wiki/Bit"><h3 class="text-lg font-semibold">Bit</h3></a><p>The <b>bit</b> is the most basic unit of information in computing and digital communications. The name is a portmanteau of <b>binary digit</b>. The bit represents a logical state with one of two possible values. These values are most commonly represented as either <span class="nowrap">"<span class="monospaced">1</span>" or "<span class="monospaced">0</span>"</span>, but other representations such as <i>true</i>/<i>false</i>, <i>yes</i>/<i>no</i>, <i>on</i>/<i>off</i>, or <i>+</i>/<i>\u2212</i> are also commonly used.</p>',du='<a href="https://en.wikipedia.org/wiki/Qubit"><h3 class="text-lg font-semibold">Qubit</h3></a><p>In quantum computing, a <b>qubit</b> or <b>quantum bit</b> is a basic unit of quantum information\u2014the quantum version of the classic binary bit physically realized with a two-state device. A qubit is a two-state quantum-mechanical system, one of the simplest quantum systems displaying the peculiarity of quantum mechanics. Examples include the spin of the electron in which the two levels can be taken as spin up and spin down; or the polarization of a single photon in which the two states can be taken to be the vertical polarization and the horizontal polarization. In a classical system, a bit would have to be in one state or the other. However, quantum mechanics allows the qubit to be in a coherent superposition of both states simultaneously, a property that is fundamental to quantum mechanics and quantum computing.</p>',cu='<a href="https://en.wikipedia.org/wiki/Complex_number"><h3 class="text-lg font-semibold">Complex number</h3></a><p>In mathematics, a <b>complex number</b> is an element of a number system that extends the real numbers with a specific element denoted <span class="texhtml mvar" style="font-style:italic">i</span>, called the imaginary unit and satisfying the equation <span class="texhtml "><i>i</i><sup>2</sup> = \u22121</span>; every complex number can be expressed in the form <span class="texhtml "><i>a</i> + <i>bi</i></span>, where <span class="texhtml mvar" style="font-style:italic">a</span> and <span class="texhtml mvar" style="font-style:italic">b</span> are real numbers. Because no real number satisfies the above equation, <span class="texhtml mvar" style="font-style:italic">i</span> was called an imaginary number by Ren\xE9 Descartes. For the complex number <span class="texhtml "><i>a</i> + <i>bi</i></span>, <span class="texhtml mvar" style="font-style:italic">a</span> is called the <b><span class="vanchor"><span class="vanchor-text">real part</span></span></b> and <span class="texhtml mvar" style="font-style:italic">b</span> is called the <b><span class="vanchor"><span class="vanchor-text">imaginary part</span></span></b>. The set of complex numbers is denoted by either of the symbols <span class="mwe-math-element"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f9add4085095b9b6d28d045fd9c92c2c09f549a7" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align:-0.338ex;width:1.678ex;height:2.176ex" /></span> or <span class="texhtml "><b>C</b></span>. Despite the historical nomenclature "imaginary", complex numbers are regarded in the mathematical sciences as just as "real" as the real numbers and are fundamental in many aspects of the scientific description of the natural world.</p>';function vu(n){let i;return{c(){i=a("bits")},l(f){i=s(f,"bits")},m(f,d){_(f,i,d)},d(f){f&&t(i)}}}function wu(n){let i;return{c(){i=a("Qubits")},l(f){i=s(f,"Qubits")},m(f,d){_(f,i,d)},d(f){f&&t(i)}}}function bu(n){let i;return{c(){i=a("complex numbers")},l(f){i=s(f,"complex numbers")},m(f,d){_(f,i,d)},d(f){f&&t(i)}}}function yu(n){let i,f,d,u,y,v,c,g,b,B,N,L=h("0")+"",z,A,V=h("1")+"",ee,Q,S,C,k,O,P=h("0")+"",j,M,W=h("1")+"",U,G,ne,E,F,T,D,Y,_e=h("|0\\rangle")+"",K,J,ge=h("|1\\rangle")+"",w,$,Ne,se,Z,ce,me,he,ie=h("\\alpha |0\\rangle + \\beta |1\\rangle")+"",Fe,we,Pt=h("\\alpha")+"",Be,Te,Pe=h("\\beta")+"",pe,fe,re,Ve,Qe=h("|0\\rangle")+"",Ze,Ue,ue=h("\\Vert{\\alpha}\\Vert^2")+"",$e,oe,Le=h("|1\\rangle")+"",wt,nt,ze=h("\\Vert{\\beta}\\Vert^2")+"",bt,at,Ye=h("|0\\rangle")+"",Ke,ae,ye=h("|1\\rangle")+"",R,Ie,xe=h("\\Vert{\\alpha}\\Vert^2 + \\Vert{\\beta}\\Vert^2 = 1")+"",gt,ut,et=h("\\Vert{\\alpha}\\Vert^2")+"",Ut,lt,ke=h("\\Vert{\\beta}\\Vert^2")+"",Kt,it,mt,Ot,pt,yt,zt;return v=new ss({props:{hovertext:_u,$$slots:{default:[vu]},$$scope:{ctx:n}}}),C=new ss({props:{hovertext:du,$$slots:{default:[wu]},$$scope:{ctx:n}}}),fe=new ss({props:{hovertext:cu,$$slots:{default:[bu]},$$scope:{ctx:n}}}),{c(){i=r("h2"),f=a("Qubit states"),d=q(),u=r("p"),y=a("The elementary units of information in classical computing are "),ft(v.$$.fragment),c=a(". As their name suggests, bits represent one single "),g=r("em"),b=a("bit"),B=a(" of information, which means they can take on either of two values "),N=r("span"),z=a(" and "),A=r("span"),ee=a(" at a time."),Q=q(),S=r("p"),ft(C.$$.fragment),k=a(" are the quantum computing equivalent of bits. They differ from classical bits - among other things - in that they can take on a multitude of values instead of just "),O=r("span"),j=a(" and "),M=r("span"),U=a(", until that value is "),G=r("em"),ne=a("measured"),E=a(", at which point they behave just like classical bits. To explain what this means exactly, we'll need to introduce some further concepts."),F=q(),T=r("p"),D=a("Let "),Y=r("span"),K=a(" and "),J=r("span"),w=a(" denote the so called "),$=r("em"),Ne=a("basis states"),se=a(" of a qubit that are the quantum-equivalent of classical bit states. If you look at a qubit directly to learn it's value, you'll see one of these basis states. But while you're not looking - due to it's quantum nature - the state of a qubit may be something more intricate. Generally, it can be expressed as the "),Z=r("em"),ce=a("linear combination"),me=a(" of the two basis states: "),he=r("span"),Fe=a(". Here, "),we=r("span"),Be=a(" and "),Te=r("span"),pe=a(" are "),ft(fe.$$.fragment),re=a(" that indicate the relative weight, with which the two basis states are present in this combination. More precisely, if we now look at the qubit, we'll see the basis state "),Ve=r("span"),Ze=a(" with a probability of "),Ue=r("span"),$e=a(", and the basis state "),oe=r("span"),wt=a(" with a probability of "),nt=r("span"),bt=a(". Because these probabilities must add up to one - as "),at=r("span"),Ke=a(" and "),ae=r("span"),R=a(" are the only possible outcomes - the equation "),Ie=r("span"),gt=a(" must hold for all possible qubit states. Let's call "),ut=r("span"),Ut=a(" and "),lt=r("span"),Kt=a(" the "),it=r("em"),mt=a("measurement probabilities"),Ot=a(" of the basis states.")},l(te){i=o(te,"H2",{});var qe=l(i);f=s(qe,"Qubit states"),qe.forEach(t),d=I(te),u=o(te,"P",{});var le=l(u);y=s(le,"The elementary units of information in classical computing are "),_t(v.$$.fragment,le),c=s(le,". As their name suggests, bits represent one single "),g=o(le,"EM",{});var st=l(g);b=s(st,"bit"),st.forEach(t),B=s(le," of information, which means they can take on either of two values "),N=o(le,"SPAN",{});var rt=l(N);rt.forEach(t),z=s(le," and "),A=o(le,"SPAN",{});var pn=l(A);pn.forEach(t),ee=s(le," at a time."),le.forEach(t),Q=I(te),S=o(te,"P",{});var ot=l(S);_t(C.$$.fragment,ot),k=s(ot," are the quantum computing equivalent of bits. They differ from classical bits - among other things - in that they can take on a multitude of values instead of just "),O=o(ot,"SPAN",{});var $t=l(O);$t.forEach(t),j=s(ot," and "),M=o(ot,"SPAN",{});var gn=l(M);gn.forEach(t),U=s(ot,", until that value is "),G=o(ot,"EM",{});var Ct=l(G);ne=s(Ct,"measured"),Ct.forEach(t),E=s(ot,", at which point they behave just like classical bits. To explain what this means exactly, we'll need to introduce some further concepts."),ot.forEach(t),F=I(te),T=o(te,"P",{});var x=l(T);D=s(x,"Let "),Y=o(x,"SPAN",{});var ln=l(Y);ln.forEach(t),K=s(x," and "),J=o(x,"SPAN",{});var qt=l(J);qt.forEach(t),w=s(x," denote the so called "),$=o(x,"EM",{});var Ht=l($);Ne=s(Ht,"basis states"),Ht.forEach(t),se=s(x," of a qubit that are the quantum-equivalent of classical bit states. If you look at a qubit directly to learn it's value, you'll see one of these basis states. But while you're not looking - due to it's quantum nature - the state of a qubit may be something more intricate. Generally, it can be expressed as the "),Z=o(x,"EM",{});var hn=l(Z);ce=s(hn,"linear combination"),hn.forEach(t),me=s(x," of the two basis states: "),he=o(x,"SPAN",{});var ve=l(he);ve.forEach(t),Fe=s(x,". Here, "),we=o(x,"SPAN",{});var Ee=l(we);Ee.forEach(t),Be=s(x," and "),Te=o(x,"SPAN",{});var Et=l(Te);Et.forEach(t),pe=s(x," are "),_t(fe.$$.fragment,x),re=s(x," that indicate the relative weight, with which the two basis states are present in this combination. More precisely, if we now look at the qubit, we'll see the basis state "),Ve=o(x,"SPAN",{});var Xt=l(Ve);Xt.forEach(t),Ze=s(x," with a probability of "),Ue=o(x,"SPAN",{});var en=l(Ue);en.forEach(t),$e=s(x,", and the basis state "),oe=o(x,"SPAN",{});var En=l(oe);En.forEach(t),wt=s(x," with a probability of "),nt=o(x,"SPAN",{});var Gt=l(nt);Gt.forEach(t),bt=s(x,". Because these probabilities must add up to one - as "),at=o(x,"SPAN",{});var fn=l(at);fn.forEach(t),Ke=s(x," and "),ae=o(x,"SPAN",{});var Se=l(ae);Se.forEach(t),R=s(x," are the only possible outcomes - the equation "),Ie=o(x,"SPAN",{});var Jt=l(Ie);Jt.forEach(t),gt=s(x," must hold for all possible qubit states. Let's call "),ut=o(x,"SPAN",{});var _n=l(ut);_n.forEach(t),Ut=s(x," and "),lt=o(x,"SPAN",{});var je=l(lt);je.forEach(t),Kt=s(x," the "),it=o(x,"EM",{});var Wt=l(it);mt=s(Wt,"measurement probabilities"),Wt.forEach(t),Ot=s(x," of the basis states."),x.forEach(t)},m(te,qe){_(te,i,qe),e(i,f),_(te,d,qe),_(te,u,qe),e(u,y),dt(v,u,null),e(u,c),e(u,g),e(g,b),e(u,B),e(u,N),N.innerHTML=L,e(u,z),e(u,A),A.innerHTML=V,e(u,ee),_(te,Q,qe),_(te,S,qe),dt(C,S,null),e(S,k),e(S,O),O.innerHTML=P,e(S,j),e(S,M),M.innerHTML=W,e(S,U),e(S,G),e(G,ne),e(S,E),_(te,F,qe),_(te,T,qe),e(T,D),e(T,Y),Y.innerHTML=_e,e(T,K),e(T,J),J.innerHTML=ge,e(T,w),e(T,$),e($,Ne),e(T,se),e(T,Z),e(Z,ce),e(T,me),e(T,he),he.innerHTML=ie,e(T,Fe),e(T,we),we.innerHTML=Pt,e(T,Be),e(T,Te),Te.innerHTML=Pe,e(T,pe),dt(fe,T,null),e(T,re),e(T,Ve),Ve.innerHTML=Qe,e(T,Ze),e(T,Ue),Ue.innerHTML=ue,e(T,$e),e(T,oe),oe.innerHTML=Le,e(T,wt),e(T,nt),nt.innerHTML=ze,e(T,bt),e(T,at),at.innerHTML=Ye,e(T,Ke),e(T,ae),ae.innerHTML=ye,e(T,R),e(T,Ie),Ie.innerHTML=xe,e(T,gt),e(T,ut),ut.innerHTML=et,e(T,Ut),e(T,lt),lt.innerHTML=ke,e(T,Kt),e(T,it),e(it,mt),e(T,Ot),pt=!0,yt||(zt=[m(N,"mouseenter",n[0]),m(A,"mouseenter",n[1]),m(O,"mouseenter",n[2]),m(M,"mouseenter",n[3]),m(Y,"mouseenter",n[4]),m(J,"mouseenter",n[5]),m(he,"mouseenter",n[6]),m(we,"mouseenter",n[7]),m(Te,"mouseenter",n[8]),m(Ve,"mouseenter",n[9]),m(Ue,"mouseenter",n[10]),m(oe,"mouseenter",n[11]),m(nt,"mouseenter",n[12]),m(at,"mouseenter",n[13]),m(ae,"mouseenter",n[14]),m(Ie,"mouseenter",n[15]),m(ut,"mouseenter",n[16]),m(lt,"mouseenter",n[17])],yt=!0)},p(te,[qe]){const le={};qe&262144&&(le.$$scope={dirty:qe,ctx:te}),v.$set(le);const st={};qe&262144&&(st.$$scope={dirty:qe,ctx:te}),C.$set(st);const rt={};qe&262144&&(rt.$$scope={dirty:qe,ctx:te}),fe.$set(rt)},i(te){pt||(Je(v.$$.fragment,te),Je(C.$$.fragment,te),Je(fe.$$.fragment,te),pt=!0)},o(te){ht(v.$$.fragment,te),ht(C.$$.fragment,te),ht(fe.$$.fragment,te),pt=!1},d(te){te&&t(i),te&&t(d),te&&t(u),ct(v),te&&t(Q),te&&t(S),ct(C),te&&t(F),te&&t(T),ct(fe),yt=!1,mn(zt)}}}function Mt(n){console.log(n)}function gu(n){return[()=>Mt([]),()=>Mt([]),()=>Mt([]),()=>Mt([]),()=>Mt([]),()=>Mt([]),()=>Mt(["\\beta","\\alpha"]),()=>Mt(["\\alpha"]),()=>Mt(["\\beta"]),()=>Mt([]),()=>Mt(["\\alpha"]),()=>Mt([]),()=>Mt(["\\beta"]),()=>Mt([]),()=>Mt([]),()=>Mt(["\\beta","\\alpha"]),()=>Mt(["\\alpha"]),()=>Mt(["\\beta"])]}class Eu extends jt{constructor(i){super(),Dt(this,i,gu,yu,Rt,{})}}function Nu(n){let i,f,d,u,y,v,c,g,b,B,N,L,z,A,V,ee=h("|0\\rangle")+"",Q,S,C=h("|1\\rangle")+"",k,O,P,j,M,W=h("n")+"",U,G,ne,E,F,T=h("\\left( \\alpha_1 |0\\rangle + \\beta_1 |1\\rangle \\right) \\otimes ... \\otimes \\left( \\alpha_n |0\\rangle + \\beta_n |1\\rangle \\right)")+"",D,Y,_e=h("\\alpha_k, \\beta_k")+"",K,J,ge=h("k")+"",w,$,Ne=h("\\otimes")+"",se,Z,ce;return{c(){i=r("h2"),f=a("Multiple qubits"),d=q(),u=r("p"),y=a("Most quantum algorithms require not only one, but several qubits. These qubits may be "),v=r("em"),c=a("independent"),g=a(" from each other, meaning their states can be expressed individually. However, it is possible for multiple qubits to "),b=r("em"),B=a("share"),N=a(" some information with each other, in which case they no longer have states of their own, but represent a unit of information together. This is called "),L=r("em"),z=a("entaglement"),A=a(", and it is another fundamental difference between classical and quantum computing. As an example, two qubits can be entangled in a way that, if we look at one of them and find it's in the basis state "),V=r("span"),Q=a(", we learn immediately that the other one must be in the basis state "),S=r("span"),k=a(", and vice versa."),O=q(),P=r("p"),j=a("The joint state of a sequence of "),M=r("span"),U=q(),G=r("em"),ne=a("independent"),E=a(" qubits can be written as "),F=r("span"),D=a(", where "),Y=r("span"),K=a(" are the coefficients associated with the state of the "),J=r("span"),w=a("-th qubit as described above, and the operator "),$=r("span"),se=a(" indicates that none of the qubits are entagled with each other.")},l(me){i=o(me,"H2",{});var he=l(i);f=s(he,"Multiple qubits"),he.forEach(t),d=I(me),u=o(me,"P",{});var ie=l(u);y=s(ie,"Most quantum algorithms require not only one, but several qubits. These qubits may be "),v=o(ie,"EM",{});var Fe=l(v);c=s(Fe,"independent"),Fe.forEach(t),g=s(ie," from each other, meaning their states can be expressed individually. However, it is possible for multiple qubits to "),b=o(ie,"EM",{});var we=l(b);B=s(we,"share"),we.forEach(t),N=s(ie," some information with each other, in which case they no longer have states of their own, but represent a unit of information together. This is called "),L=o(ie,"EM",{});var Pt=l(L);z=s(Pt,"entaglement"),Pt.forEach(t),A=s(ie,", and it is another fundamental difference between classical and quantum computing. As an example, two qubits can be entangled in a way that, if we look at one of them and find it's in the basis state "),V=o(ie,"SPAN",{});var Be=l(V);Be.forEach(t),Q=s(ie,", we learn immediately that the other one must be in the basis state "),S=o(ie,"SPAN",{});var Te=l(S);Te.forEach(t),k=s(ie,", and vice versa."),ie.forEach(t),O=I(me),P=o(me,"P",{});var Pe=l(P);j=s(Pe,"The joint state of a sequence of "),M=o(Pe,"SPAN",{});var pe=l(M);pe.forEach(t),U=I(Pe),G=o(Pe,"EM",{});var fe=l(G);ne=s(fe,"independent"),fe.forEach(t),E=s(Pe," qubits can be written as "),F=o(Pe,"SPAN",{});var re=l(F);re.forEach(t),D=s(Pe,", where "),Y=o(Pe,"SPAN",{});var Ve=l(Y);Ve.forEach(t),K=s(Pe," are the coefficients associated with the state of the "),J=o(Pe,"SPAN",{});var Qe=l(J);Qe.forEach(t),w=s(Pe,"-th qubit as described above, and the operator "),$=o(Pe,"SPAN",{});var Ze=l($);Ze.forEach(t),se=s(Pe," indicates that none of the qubits are entagled with each other."),Pe.forEach(t)},m(me,he){_(me,i,he),e(i,f),_(me,d,he),_(me,u,he),e(u,y),e(u,v),e(v,c),e(u,g),e(u,b),e(b,B),e(u,N),e(u,L),e(L,z),e(u,A),e(u,V),V.innerHTML=ee,e(u,Q),e(u,S),S.innerHTML=C,e(u,k),_(me,O,he),_(me,P,he),e(P,j),e(P,M),M.innerHTML=W,e(P,U),e(P,G),e(G,ne),e(P,E),e(P,F),F.innerHTML=T,e(P,D),e(P,Y),Y.innerHTML=_e,e(P,K),e(P,J),J.innerHTML=ge,e(P,w),e(P,$),$.innerHTML=Ne,e(P,se),Z||(ce=[m(V,"mouseenter",n[0]),m(S,"mouseenter",n[1]),m(M,"mouseenter",n[2]),m(F,"mouseenter",n[3]),m(Y,"mouseenter",n[4]),m(J,"mouseenter",n[5]),m($,"mouseenter",n[6])],Z=!0)},p:vt,i:vt,o:vt,d(me){me&&t(i),me&&t(d),me&&t(u),me&&t(O),me&&t(P),Z=!1,mn(ce)}}}function Rn(n){console.log(n)}function Tu(n){return[()=>Rn([]),()=>Rn([]),()=>Rn(["n"]),()=>Rn(["\\beta","n","\\alpha"]),()=>Rn(["\\beta","k","\\alpha"]),()=>Rn(["k"]),()=>Rn([])]}class Pu extends jt{constructor(i){super(),Dt(this,i,Tu,Nu,Rt,{})}}function $u(n){let i,f,d,u,y,v,c,g,b=h("\\phi \\alpha")+"",B,N,L,z=h("\\phi \\beta")+"",A,V,ee,Q=h("r \\alpha")+"",S,C,k,O,P,j,M,W,U,G,ne,E,F,T,D,Y,_e;u=new Eu({}),k=new Vo({props:{displayBloch:!1,phiAlpha:n[4],phiBeta:n[3],rAlpha:n[5]}}),P=new fu({});function K(w){n[10](w)}function J(w){n[11](w)}let ge={minX:1.5,polar:!0};return n[0]!==void 0&&(ge.disabledScroll=n[0]),n[6]!==void 0&&(ge.cameraPosition=n[6]),W=new Hh({props:ge}),ho.push(()=>uo(W,"disabledScroll",K)),ho.push(()=>uo(W,"cameraPosition",J)),E=new Vo({props:{displayVectors:!1,phiAlpha:n[4],phiBeta:n[3],rAlpha:n[5],cameraPosition:n[6]}}),T=new Pu({}),{c(){i=r("h2"),f=a("Quantum Basics"),d=q(),ft(u.$$.fragment),y=q(),v=r("div"),c=r("div"),g=new Ce(!1),B=r("input"),N=q(),L=new Ce(!1),A=r("input"),V=q(),ee=new Ce(!1),S=r("input"),C=q(),ft(k.$$.fragment),O=q(),ft(P.$$.fragment),j=q(),M=r("div"),ft(W.$$.fragment),ne=q(),ft(E.$$.fragment),F=q(),ft(T.$$.fragment),this.h()},l(w){i=o(w,"H2",{});var $=l(i);f=s($,"Quantum Basics"),$.forEach(t),d=I(w),_t(u.$$.fragment,w),y=I(w),v=o(w,"DIV",{class:!0});var Ne=l(v);c=o(Ne,"DIV",{class:!0});var se=l(c);g=We(se,!1),B=o(se,"INPUT",{class:!0,type:!0,min:!0,max:!0,step:!0}),N=I(se),L=We(se,!1),A=o(se,"INPUT",{class:!0,type:!0,min:!0,max:!0,step:!0}),V=I(se),ee=We(se,!1),S=o(se,"INPUT",{class:!0,type:!0,min:!0,max:!0,step:!0}),se.forEach(t),C=I(Ne),_t(k.$$.fragment,Ne),Ne.forEach(t),O=I(w),_t(P.$$.fragment,w),j=I(w),M=o(w,"DIV",{class:!0});var Z=l(M);_t(W.$$.fragment,Z),ne=I(Z),_t(E.$$.fragment,Z),Z.forEach(t),F=I(w),_t(T.$$.fragment,w),this.h()},h(){g.a=B,de(B,"class","slider"),de(B,"type","range"),de(B,"min",0),de(B,"max",360),de(B,"step",1),L.a=A,de(A,"class","slider"),de(A,"type","range"),de(A,"min",0),de(A,"max",360),de(A,"step",1),ee.a=S,de(S,"class","slider"),de(S,"type","range"),de(S,"min",0),de(S,"max",1),de(S,"step",.01),de(c,"class","cpanel svelte-vlthtg"),de(v,"class","interaction"),de(M,"class","interaction")},m(w,$){_(w,i,$),e(i,f),_(w,d,$),dt(u,w,$),_(w,y,$),_(w,v,$),e(v,c),g.m(b,c),e(c,B),on(B,n[2]),e(c,N),L.m(z,c),e(c,A),on(A,n[1]),e(c,V),ee.m(Q,c),e(c,S),on(S,n[5]),e(v,C),dt(k,v,null),_(w,O,$),dt(P,w,$),_(w,j,$),_(w,M,$),dt(W,M,null),e(M,ne),dt(E,M,null),_(w,F,$),dt(T,w,$),D=!0,Y||(_e=[m(B,"change",n[7]),m(B,"input",n[7]),m(A,"change",n[8]),m(A,"input",n[8]),m(S,"change",n[9]),m(S,"input",n[9])],Y=!0)},p(w,[$]){$&4&&on(B,w[2]),$&2&&on(A,w[1]),$&32&&on(S,w[5]);const Ne={};$&16&&(Ne.phiAlpha=w[4]),$&8&&(Ne.phiBeta=w[3]),$&32&&(Ne.rAlpha=w[5]),k.$set(Ne);const se={};!U&&$&1&&(U=!0,se.disabledScroll=w[0],mo(()=>U=!1)),!G&&$&64&&(G=!0,se.cameraPosition=w[6],mo(()=>G=!1)),W.$set(se);const Z={};$&16&&(Z.phiAlpha=w[4]),$&8&&(Z.phiBeta=w[3]),$&32&&(Z.rAlpha=w[5]),$&64&&(Z.cameraPosition=w[6]),E.$set(Z)},i(w){D||(Je(u.$$.fragment,w),Je(k.$$.fragment,w),Je(P.$$.fragment,w),Je(W.$$.fragment,w),Je(E.$$.fragment,w),Je(T.$$.fragment,w),D=!0)},o(w){ht(u.$$.fragment,w),ht(k.$$.fragment,w),ht(P.$$.fragment,w),ht(W.$$.fragment,w),ht(E.$$.fragment,w),ht(T.$$.fragment,w),D=!1},d(w){w&&t(i),w&&t(d),ct(u,w),w&&t(y),w&&t(v),ct(k),w&&t(O),ct(P,w),w&&t(j),w&&t(M),ct(W),ct(E),w&&t(F),ct(T,w),Y=!1,mn(_e)}}}function Su(n,i,f){let d,u,y,v,c,g,{disabledScroll:b=!1}=i;function B(){u=Qn(this.value),f(2,u)}function N(){y=Qn(this.value),f(1,y)}function L(){v=Qn(this.value),f(5,v)}function z(V){b=V,f(0,b)}function A(V){d=V,f(6,d)}return n.$$set=V=>{"disabledScroll"in V&&f(0,b=V.disabledScroll)},n.$$.update=()=>{n.$$.dirty&4&&f(4,c=u/180*Bo),n.$$.dirty&2&&f(3,g=y/180*Bo)},f(6,d={x:3,y:2,z:1.5}),f(2,u=15),f(1,y=310),f(5,v=.9),[b,y,u,g,c,v,d,B,N,L,z,A]}class ku extends jt{constructor(i){super(),Dt(this,i,Su,$u,Rt,{disabledScroll:0})}}const Au='<a href="https://en.wikipedia.org/wiki/Periodic_function"><h3 class="text-lg font-semibold">Periodic function</h3></a><p>A <b>periodic function</b> is a function that repeats its values at regular intervals. For example, the trigonometric functions, which repeat at intervals of <span class="mwe-math-element"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/73efd1f6493490b058097060a572606d2c550a06" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align:-0.338ex;width:2.494ex;height:2.176ex" /></span> radians, are periodic functions. Periodic functions are used throughout science to describe oscillations, waves, and other phenomena that exhibit periodicity. Any function that is not periodic is called <b>aperiodic</b>.</p>';function Mu(n){let i;return{c(){i=a("periodic")},l(f){i=s(f,"periodic")},m(f,d){_(f,i,d)},d(f){f&&t(i)}}}function Hu(n){let i,f,d,u,y,v,c=h("N")+"",g,b,B=h("1 < \\hat{r} < N")+"",N,L,z=h("f(\\hat{r}) = a^{\\hat{r}} \\mod N = 1")+"",A,V,ee=h("f")+"",Q,S,C,k,O=h("\\hat{r}")+"",P,j,M=h("f")+"",W,U,G=h("0 < p")+"",ne,E,F=h("f(r) = f(r + p)")+"",T,D,Y=h("r")+"",_e,K,J=h("f(0) = a^{0} \\mod N = 1 \\mod N = 1")+"",ge,w,$=h("f(0) = f(0 + p) = f(p) = 1")+"",Ne,se,Z=h("p")+"",ce,me,he=h("f")+"",ie,Fe,we=h("1")+"",Pt,Be,Te=h("\\hat{r}")+"",Pe,pe,fe,re,Ve,Qe=h("\\hat{r}")+"",Ze,Ue,ue=h("f")+"",$e,oe,Le,wt,nt,ze,bt,at,Ye,Ke;return S=new ss({props:{hovertext:Au,$$slots:{default:[Mu]},$$scope:{ctx:n}}}),{c(){i=r("h3"),f=a("The period-finding problem"),d=q(),u=r("p"),y=a("So, why is Shor's algorithm so efficient? Recall the steps for computing the prime factors of a large integer "),v=r("span"),g=a(", the hard part of which was finding the smallest "),b=r("span"),N=a(" such that "),L=r("span"),A=a(". It turns out that "),V=r("span"),Q=a(" is a"),ft(S.$$.fragment),C=a(" function, and the integer "),k=r("span"),P=a(" we're looking for is its period. This is because the period of "),j=r("span"),W=a(" is defined as the smallest integer "),U=r("span"),ne=a(", for which "),E=r("span"),T=a(" for all "),D=r("span"),_e=a(". We know for sure that "),K=r("span"),ge=a(", from which follows that "),w=r("span"),Ne=a(". Thus, the period "),se=r("span"),ce=a(" is the smallest positive integer, at which the value of "),me=r("span"),ie=a(" is "),Fe=r("span"),Pt=a(", and this is exactly how we originally defined "),Be=r("span"),Pe=a("."),pe=q(),fe=r("p"),re=a("Thus, finding "),Ve=r("span"),Ze=a(" can be reformulated as finding the period of the function "),Ue=r("span"),$e=a(", which is where the quantum Fourier transform will prove extremely useful."),oe=q(),Le=r("h3"),wt=a("Finding the period with the help of interference"),nt=q(),ze=r("p"),bt=a("...")},l(ae){i=o(ae,"H3",{});var ye=l(i);f=s(ye,"The period-finding problem"),ye.forEach(t),d=I(ae),u=o(ae,"P",{});var R=l(u);y=s(R,"So, why is Shor's algorithm so efficient? Recall the steps for computing the prime factors of a large integer "),v=o(R,"SPAN",{});var Ie=l(v);Ie.forEach(t),g=s(R,", the hard part of which was finding the smallest "),b=o(R,"SPAN",{});var xe=l(b);xe.forEach(t),N=s(R," such that "),L=o(R,"SPAN",{});var gt=l(L);gt.forEach(t),A=s(R,". It turns out that "),V=o(R,"SPAN",{});var ut=l(V);ut.forEach(t),Q=s(R," is a"),_t(S.$$.fragment,R),C=s(R," function, and the integer "),k=o(R,"SPAN",{});var et=l(k);et.forEach(t),P=s(R," we're looking for is its period. This is because the period of "),j=o(R,"SPAN",{});var Ut=l(j);Ut.forEach(t),W=s(R," is defined as the smallest integer "),U=o(R,"SPAN",{});var lt=l(U);lt.forEach(t),ne=s(R,", for which "),E=o(R,"SPAN",{});var ke=l(E);ke.forEach(t),T=s(R," for all "),D=o(R,"SPAN",{});var Kt=l(D);Kt.forEach(t),_e=s(R,". We know for sure that "),K=o(R,"SPAN",{});var it=l(K);it.forEach(t),ge=s(R,", from which follows that "),w=o(R,"SPAN",{});var mt=l(w);mt.forEach(t),Ne=s(R,". Thus, the period "),se=o(R,"SPAN",{});var Ot=l(se);Ot.forEach(t),ce=s(R," is the smallest positive integer, at which the value of "),me=o(R,"SPAN",{});var pt=l(me);pt.forEach(t),ie=s(R," is "),Fe=o(R,"SPAN",{});var yt=l(Fe);yt.forEach(t),Pt=s(R,", and this is exactly how we originally defined "),Be=o(R,"SPAN",{});var zt=l(Be);zt.forEach(t),Pe=s(R,"."),R.forEach(t),pe=I(ae),fe=o(ae,"P",{});var te=l(fe);re=s(te,"Thus, finding "),Ve=o(te,"SPAN",{});var qe=l(Ve);qe.forEach(t),Ze=s(te," can be reformulated as finding the period of the function "),Ue=o(te,"SPAN",{});var le=l(Ue);le.forEach(t),$e=s(te,", which is where the quantum Fourier transform will prove extremely useful."),te.forEach(t),oe=I(ae),Le=o(ae,"H3",{});var st=l(Le);wt=s(st,"Finding the period with the help of interference"),st.forEach(t),nt=I(ae),ze=o(ae,"P",{});var rt=l(ze);bt=s(rt,"..."),rt.forEach(t)},m(ae,ye){_(ae,i,ye),e(i,f),_(ae,d,ye),_(ae,u,ye),e(u,y),e(u,v),v.innerHTML=c,e(u,g),e(u,b),b.innerHTML=B,e(u,N),e(u,L),L.innerHTML=z,e(u,A),e(u,V),V.innerHTML=ee,e(u,Q),dt(S,u,null),e(u,C),e(u,k),k.innerHTML=O,e(u,P),e(u,j),j.innerHTML=M,e(u,W),e(u,U),U.innerHTML=G,e(u,ne),e(u,E),E.innerHTML=F,e(u,T),e(u,D),D.innerHTML=Y,e(u,_e),e(u,K),K.innerHTML=J,e(u,ge),e(u,w),w.innerHTML=$,e(u,Ne),e(u,se),se.innerHTML=Z,e(u,ce),e(u,me),me.innerHTML=he,e(u,ie),e(u,Fe),Fe.innerHTML=we,e(u,Pt),e(u,Be),Be.innerHTML=Te,e(u,Pe),_(ae,pe,ye),_(ae,fe,ye),e(fe,re),e(fe,Ve),Ve.innerHTML=Qe,e(fe,Ze),e(fe,Ue),Ue.innerHTML=ue,e(fe,$e),_(ae,oe,ye),_(ae,Le,ye),e(Le,wt),_(ae,nt,ye),_(ae,ze,ye),e(ze,bt),at=!0,Ye||(Ke=[m(v,"mouseenter",n[0]),m(b,"mouseenter",n[1]),m(L,"mouseenter",n[2]),m(V,"mouseenter",n[3]),m(k,"mouseenter",n[4]),m(j,"mouseenter",n[5]),m(U,"mouseenter",n[6]),m(E,"mouseenter",n[7]),m(D,"mouseenter",n[8]),m(K,"mouseenter",n[9]),m(w,"mouseenter",n[10]),m(se,"mouseenter",n[11]),m(me,"mouseenter",n[12]),m(Fe,"mouseenter",n[13]),m(Be,"mouseenter",n[14]),m(Ve,"mouseenter",n[15]),m(Ue,"mouseenter",n[16])],Ye=!0)},p(ae,[ye]){const R={};ye&131072&&(R.$$scope={dirty:ye,ctx:ae}),S.$set(R)},i(ae){at||(Je(S.$$.fragment,ae),at=!0)},o(ae){ht(S.$$.fragment,ae),at=!1},d(ae){ae&&t(i),ae&&t(d),ae&&t(u),ct(S),ae&&t(pe),ae&&t(fe),ae&&t(oe),ae&&t(Le),ae&&t(nt),ae&&t(ze),Ye=!1,mn(Ke)}}}function Lt(n){console.log(n)}function Lu(n){return[()=>Lt(["N"]),()=>Lt(["r","N"]),()=>Lt(["r","a","f","N"]),()=>Lt(["f"]),()=>Lt(["r"]),()=>Lt(["f"]),()=>Lt(["p"]),()=>Lt(["r","p","f"]),()=>Lt(["r"]),()=>Lt(["a","f","N"]),()=>Lt(["p","f"]),()=>Lt(["p"]),()=>Lt(["f"]),()=>Lt([]),()=>Lt(["r"]),()=>Lt(["r"]),()=>Lt(["f"])]}class qu extends jt{constructor(i){super(),Dt(this,i,Lu,Hu,Rt,{})}}function Iu(n){let i,f,d,u,y;return u=new qu({}),{c(){i=r("h2"),f=a("Shor's Algorithm"),d=q(),ft(u.$$.fragment)},l(v){i=o(v,"H2",{});var c=l(i);f=s(c,"Shor's Algorithm"),c.forEach(t),d=I(v),_t(u.$$.fragment,v)},m(v,c){_(v,i,c),e(i,f),_(v,d,c),dt(u,v,c),y=!0},p:vt,i(v){y||(Je(u.$$.fragment,v),y=!0)},o(v){ht(u.$$.fragment,v),y=!1},d(v){v&&t(i),v&&t(d),ct(u,v)}}}class Fu extends jt{constructor(i){super(),Dt(this,i,null,Iu,Rt,{})}}function Vu(n){let i,f,d,u,y,v,c,g,b,B,N,L,z,A,V,ee,Q,S,C,k,O;z=new nu({});function P(M){n[1](M)}let j={};return n[0]!==void 0&&(j.disabledScroll=n[0]),V=new ku({props:j}),ho.push(()=>uo(V,"disabledScroll",P)),S=new uu({}),k=new Fu({}),{c(){i=r("div"),f=q(),d=r("main"),u=r("h1"),y=a("Interactive Quantum Computing"),v=q(),c=r("p"),g=a("This page intends to introduce concepts, connect them and derive a practical use case"),b=q(),B=r("h2"),N=a("Clickable Table of Contents"),L=q(),ft(z.$$.fragment),A=q(),ft(V.$$.fragment),Q=q(),ft(S.$$.fragment),C=q(),ft(k.$$.fragment),this.h()},l(M){i=o(M,"DIV",{class:!0}),l(i).forEach(t),f=I(M),d=o(M,"MAIN",{class:!0});var W=l(d);u=o(W,"H1",{});var U=l(u);y=s(U,"Interactive Quantum Computing"),U.forEach(t),v=I(W),c=o(W,"P",{});var G=l(c);g=s(G,"This page intends to introduce concepts, connect them and derive a practical use case"),G.forEach(t),b=I(W),B=o(W,"H2",{});var ne=l(B);N=s(ne,"Clickable Table of Contents"),ne.forEach(t),L=I(W),_t(z.$$.fragment,W),A=I(W),_t(V.$$.fragment,W),Q=I(W),_t(S.$$.fragment,W),C=I(W),_t(k.$$.fragment,W),W.forEach(t),this.h()},h(){de(i,"class","sidebar"),de(d,"class","svelte-1tkfm11"),Fo(d,"scroll-lock",n[0])},m(M,W){_(M,i,W),_(M,f,W),_(M,d,W),e(d,u),e(u,y),e(d,v),e(d,c),e(c,g),e(d,b),e(d,B),e(B,N),e(d,L),dt(z,d,null),e(d,A),dt(V,d,null),e(d,Q),dt(S,d,null),e(d,C),dt(k,d,null),O=!0},p(M,[W]){const U={};!ee&&W&1&&(ee=!0,U.disabledScroll=M[0],mo(()=>ee=!1)),V.$set(U),W&1&&Fo(d,"scroll-lock",M[0])},i(M){O||(Je(z.$$.fragment,M),Je(V.$$.fragment,M),Je(S.$$.fragment,M),Je(k.$$.fragment,M),O=!0)},o(M){ht(z.$$.fragment,M),ht(V.$$.fragment,M),ht(S.$$.fragment,M),ht(k.$$.fragment,M),O=!1},d(M){M&&t(i),M&&t(f),M&&t(d),ct(z),ct(V),ct(S),ct(k)}}}const Cu=!0;function Bu(n,i,f){let d=!1;function u(y){d=y,f(0,d)}return[d,u]}class Wu extends jt{constructor(i){super(),Dt(this,i,Bu,Vu,Rt,{})}}export{Wu as default,Cu as prerender};
